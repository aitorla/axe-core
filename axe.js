/*! axe v3.4.1
 * Copyright (c) 2019 Deque Systems, Inc.
 *
 * Your use of this Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * This entire copyright notice must appear in every copy of this file you
 * distribute or in any file that contains substantial portions of this source
 * code.
 */
(function axeFunction(window) {
	// A window reference is required to access the axe object in a "global".
	var global = window;
	var document = window.document;

	('use strict');

	function _typeof(obj) {
		if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
			_typeof = function _typeof(obj) {
				return typeof obj;
			};
		} else {
			_typeof = function _typeof(obj) {
				return obj &&
					typeof Symbol === 'function' &&
					obj.constructor === Symbol &&
					obj !== Symbol.prototype
					? 'symbol'
					: typeof obj;
			};
		}
		return _typeof(obj);
	}

	/*exported axe, commons */

	/*global axeFunction, module, define */
	// exported namespace for axe

	/*eslint no-use-before-define: 0, no-unused-vars: 0*/
	var axe = axe || {};
	axe.version = '3.4.1';

	if (typeof define === 'function' && define.amd) {
		// Explicitly naming the module to avoid mismatched anonymous define() modules when injected in a page
		define('axe-core', [], function() {
			'use strict';

			return axe;
		});
	}

	if (
		(typeof module === 'undefined' ? 'undefined' : _typeof(module)) ===
			'object' &&
		module.exports &&
		typeof axeFunction.toString === 'function'
	) {
		axe.source =
			'(' +
			axeFunction.toString() +
			')(typeof window === "object" ? window : this);';
		module.exports = axe;
	}

	if (typeof window.getComputedStyle === 'function') {
		window.axe = axe;
	} // local namespace for common functions

	var commons;

	function SupportError(error) {
		this.name = 'SupportError';
		this.cause = error.cause;
		this.message = '`'.concat(
			error.cause,
			'` - feature unsupported in your environment.'
		);

		if (error.ruleId) {
			this.ruleId = error.ruleId;
			this.message += ' Skipping '.concat(this.ruleId, ' rule.');
		}

		this.stack = new Error().stack;
	}

	SupportError.prototype = Object.create(Error.prototype);
	SupportError.prototype.constructor = SupportError;

	(function() {
		function r(e, n, t) {
			function o(i, f) {
				if (!n[i]) {
					if (!e[i]) {
						var c = 'function' == typeof require && require;
						if (!f && c) return c(i, !0);
						if (u) return u(i, !0);
						var a = new Error("Cannot find module '" + i + "'");
						throw ((a.code = 'MODULE_NOT_FOUND'), a);
					}
					var p = (n[i] = { exports: {} });
					e[i][0].call(
						p.exports,
						function(r) {
							var n = e[i][1][r];
							return o(n || r);
						},
						p,
						p.exports,
						r,
						e,
						n,
						t
					);
				}
				return n[i].exports;
			}
			for (
				var u = 'function' == typeof require && require, i = 0;
				i < t.length;
				i++
			)
				o(t[i]);
			return o;
		}
		return r;
	})()(
		{
			1: [
				function(_dereq_, module, exports) {
					/* global axe */

					/**
					 * Note:
					 * This file is run via browserify to pull in the required dependencies.
					 * See - './build/imports-generator'
					 */

					/**
					 * Polyfill `Promise`
					 * Reference: https://www.npmjs.com/package/es6-promise
					 */
					if (!('Promise' in window)) {
						_dereq_('es6-promise').polyfill();
					}

					/**
					 * Polyfill required TypedArray and functions
					 * Reference https://github.com/zloirock/core-js/
					 */
					if (!('Uint32Array' in window)) {
						_dereq_('core-js/features/typed-array/uint32-array');
					}
					if (window.Uint32Array) {
						if (!('some' in window.Uint32Array.prototype)) {
							_dereq_('core-js/features/typed-array/some');
						}
						if (!('reduce' in window.Uint32Array.prototype)) {
							_dereq_('core-js/features/typed-array/reduce');
						}
					}

					/**
					 * Polyfill `WeakMap`
					 * Reference: https://github.com/polygonplanet/weakmap-polyfill
					 */
					_dereq_('weakmap-polyfill');

					/**
					 * Namespace `axe.imports` which holds required external dependencies
					 *
					 * @namespace imports
					 * @memberof axe
					 */
					axe.imports = {
						axios: _dereq_('axios'),
						CssSelectorParser: _dereq_('css-selector-parser').CssSelectorParser,
						doT: _dereq_('@deque/dot'),
						emojiRegexText: _dereq_('emoji-regex'),
						memoize: _dereq_('memoizee')
					};
				},
				{
					'@deque/dot': 2,
					axios: 3,
					'core-js/features/typed-array/reduce': 30,
					'core-js/features/typed-array/some': 31,
					'core-js/features/typed-array/uint32-array': 32,
					'css-selector-parser': 152,
					'emoji-regex': 155,
					'es6-promise': 199,
					memoizee: 221,
					'weakmap-polyfill': 243
				}
			],
			2: [
				function(_dereq_, module, exports) {
					(function(global) {
						/* globals __magic__, globalThis, window, self, global */

						// doT.js
						// 2011-2014, Laura Doktorova, https://github.com/olado/doT
						// Licensed under the MIT license.

						(function() {
							'use strict';

							var doT = {
								name: 'doT',
								version: '1.1.1',
								templateSettings: {
									evaluate: /\{\{([\s\S]+?(\}?)+)\}\}/g,
									interpolate: /\{\{=([\s\S]+?)\}\}/g,
									encode: /\{\{!([\s\S]+?)\}\}/g,
									use: /\{\{#([\s\S]+?)\}\}/g,
									useParams: /(^|[^\w$])def(?:\.|\[[\'\"])([\w$\.]+)(?:[\'\"]\])?\s*\:\s*([\w$\.]+|\"[^\"]+\"|\'[^\']+\'|\{[^\}]+\})/g,
									define: /\{\{##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\}\}/g,
									defineParams: /^\s*([\w$]+):([\s\S]+)/,
									conditional: /\{\{\?(\?)?\s*([\s\S]*?)\s*\}\}/g,
									iterate: /\{\{~\s*(?:\}\}|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\}\})/g,
									varname: 'it',
									strip: true,
									append: true,
									selfcontained: false,
									doNotSkipEncoded: false
								},
								template: undefined, //fn, compile template
								compile: undefined, //fn, for express
								log: true
							};

							// a globalThis polyfill (used to replace the eval pattern of returning the this object)
							// @see https://mathiasbynens.be/notes/globalthis
							(function() {
								if (typeof globalThis === 'object') return;

								try {
									Object.defineProperty(Object.prototype, '__magic__', {
										get: function() {
											return this;
										},
										configurable: true // This makes it possible to `delete` the getter later.
									});
									__magic__.globalThis = __magic__; // lolwat
									delete Object.prototype.__magic__;
								} catch (e) {
									// the polyfill doesn't work in safari 11, so we need to add a fallback to handle that
									// @see https://github.com/dequelabs/axe-core/issues/1764
									window.globalThis = (function() {
										if (typeof self !== 'undefined') return self;
										if (typeof window !== 'undefined') return window;
										if (typeof global !== 'undefined') return global;
										if (typeof this !== 'undefined') return this;
										throw new Error('Unable to locate global `this`');
									})();
								}
							})();

							doT.encodeHTMLSource = function(doNotSkipEncoded) {
								var encodeHTMLRules = {
										'&': '&#38;',
										'<': '&#60;',
										'>': '&#62;',
										'"': '&#34;',
										"'": '&#39;',
										'/': '&#47;'
									},
									matchHTML = doNotSkipEncoded
										? /[&<>"'\/]/g
										: /&(?!#?\w+;)|<|>|"|'|\//g;
								return function(code) {
									return code
										? code.toString().replace(matchHTML, function(m) {
												return encodeHTMLRules[m] || m;
										  })
										: '';
								};
							};

							/* istanbul ignore else */
							if (typeof module !== 'undefined' && module.exports) {
								module.exports = doT;
							} else if (typeof define === 'function' && define.amd) {
								define(function() {
									return doT;
								});
							} else {
								globalThis.doT = doT;
							}

							var startend = {
									append: {
										start: "'+(",
										end: ")+'",
										startencode: "'+encodeHTML("
									},
									split: {
										start: "';out+=(",
										end: ");out+='",
										startencode: "';out+=encodeHTML("
									}
								},
								skip = /$^/;

							function resolveDefs(c, block, def) {
								return (typeof block === 'string' ? block : block.toString())
									.replace(c.define || skip, function(m, code, assign, value) {
										if (code.indexOf('def.') === 0) {
											code = code.substring(4);
										}
										if (!(code in def)) {
											if (assign === ':') {
												if (c.defineParams)
													value.replace(c.defineParams, function(m, param, v) {
														def[code] = { arg: param, text: v };
													});
												if (!(code in def)) def[code] = value;
											} else {
												new Function('def', "def['" + code + "']=" + value)(
													def
												);
											}
										}
										return '';
									})
									.replace(c.use || skip, function(m, code) {
										if (c.useParams)
											code = code.replace(c.useParams, function(
												m,
												s,
												d,
												param
											) {
												if (def[d] && def[d].arg && param) {
													var rw = (d + ':' + param).replace(/'|\\/g, '_');
													def.__exp = def.__exp || {};
													def.__exp[rw] = def[d].text.replace(
														new RegExp(
															'(^|[^\\w$])' + def[d].arg + '([^\\w$])',
															'g'
														),
														'$1' + param + '$2'
													);
													return s + "def.__exp['" + rw + "']";
												}
											});
										var v = new Function('def', 'return ' + code)(def);
										return v ? resolveDefs(c, v, def) : v;
									});
							}

							function unescape(code) {
								return code
									.replace(/\\('|\\)/g, '$1')
									.replace(/[\r\t\n]/g, ' ');
							}

							doT.template = function(tmpl, c, def) {
								c = c || doT.templateSettings;
								var cse = c.append ? startend.append : startend.split,
									needhtmlencode,
									sid = 0,
									indv,
									str =
										c.use || c.define ? resolveDefs(c, tmpl, def || {}) : tmpl;

								str = (
									"var out='" +
									(c.strip
										? str
												.replace(/(^|\r|\n)\t* +| +\t*(\r|\n|$)/g, ' ')
												.replace(/\r|\n|\t|\/\*[\s\S]*?\*\//g, '')
										: str
									)
										.replace(/'|\\/g, '\\$&')
										.replace(c.interpolate || skip, function(m, code) {
											return cse.start + unescape(code) + cse.end;
										})
										.replace(c.encode || skip, function(m, code) {
											needhtmlencode = true;
											return cse.startencode + unescape(code) + cse.end;
										})
										.replace(c.conditional || skip, function(
											m,
											elsecase,
											code
										) {
											return elsecase
												? code
													? "';}else if(" + unescape(code) + "){out+='"
													: "';}else{out+='"
												: code
												? "';if(" + unescape(code) + "){out+='"
												: "';}out+='";
										})
										.replace(c.iterate || skip, function(
											m,
											iterate,
											vname,
											iname
										) {
											if (!iterate) return "';} } out+='";
											sid += 1;
											indv = iname || 'i' + sid;
											iterate = unescape(iterate);
											return (
												"';var arr" +
												sid +
												'=' +
												iterate +
												';if(arr' +
												sid +
												'){var ' +
												vname +
												',' +
												indv +
												'=-1,l' +
												sid +
												'=arr' +
												sid +
												'.length-1;while(' +
												indv +
												'<l' +
												sid +
												'){' +
												vname +
												'=arr' +
												sid +
												'[' +
												indv +
												"+=1];out+='"
											);
										})
										.replace(c.evaluate || skip, function(m, code) {
											return "';" + unescape(code) + "out+='";
										}) +
									"';return out;"
								)
									.replace(/\n/g, '\\n')
									.replace(/\t/g, '\\t')
									.replace(/\r/g, '\\r')
									.replace(/(\s|;|\}|^|\{)out\+='';/g, '$1')
									.replace(/\+''/g, '');
								//.replace(/(\s|;|\}|^|\{)out\+=''\+/g,'$1out+=');

								if (needhtmlencode) {
									if (!c.selfcontained && globalThis && !globalThis._encodeHTML)
										globalThis._encodeHTML = doT.encodeHTMLSource(
											c.doNotSkipEncoded
										);
									str =
										"var encodeHTML = typeof _encodeHTML !== 'undefined' ? _encodeHTML : (" +
										doT.encodeHTMLSource.toString() +
										'(' +
										(c.doNotSkipEncoded || '') +
										'));' +
										str;
								}
								try {
									return new Function(c.varname, str);
								} catch (e) {
									/* istanbul ignore else */
									if (typeof console !== 'undefined')
										console.log('Could not create a template function: ' + str);
									throw e;
								}
							};

							doT.compile = function(tmpl, def) {
								return doT.template(tmpl, null, def);
							};
						})();
					}.call(
						this,
						typeof global !== 'undefined'
							? global
							: typeof self !== 'undefined'
							? self
							: typeof window !== 'undefined'
							? window
							: {}
					));
				},
				{}
			],
			3: [
				function(_dereq_, module, exports) {
					module.exports = _dereq_('./lib/axios');
				},
				{ './lib/axios': 5 }
			],
			4: [
				function(_dereq_, module, exports) {
					'use strict';

					var utils = _dereq_('./../utils');
					var settle = _dereq_('./../core/settle');
					var buildURL = _dereq_('./../helpers/buildURL');
					var parseHeaders = _dereq_('./../helpers/parseHeaders');
					var isURLSameOrigin = _dereq_('./../helpers/isURLSameOrigin');
					var createError = _dereq_('../core/createError');

					module.exports = function xhrAdapter(config) {
						return new Promise(function dispatchXhrRequest(resolve, reject) {
							var requestData = config.data;
							var requestHeaders = config.headers;

							if (utils.isFormData(requestData)) {
								delete requestHeaders['Content-Type']; // Let the browser set it
							}

							var request = new XMLHttpRequest();

							// HTTP basic authentication
							if (config.auth) {
								var username = config.auth.username || '';
								var password = config.auth.password || '';
								requestHeaders.Authorization =
									'Basic ' + btoa(username + ':' + password);
							}

							request.open(
								config.method.toUpperCase(),
								buildURL(config.url, config.params, config.paramsSerializer),
								true
							);

							// Set the request timeout in MS
							request.timeout = config.timeout;

							// Listen for ready state
							request.onreadystatechange = function handleLoad() {
								if (!request || request.readyState !== 4) {
									return;
								}

								// The request errored out and we didn't get a response, this will be
								// handled by onerror instead
								// With one exception: request that using file: protocol, most browsers
								// will return status as 0 even though it's a successful request
								if (
									request.status === 0 &&
									!(
										request.responseURL &&
										request.responseURL.indexOf('file:') === 0
									)
								) {
									return;
								}

								// Prepare the response
								var responseHeaders =
									'getAllResponseHeaders' in request
										? parseHeaders(request.getAllResponseHeaders())
										: null;
								var responseData =
									!config.responseType || config.responseType === 'text'
										? request.responseText
										: request.response;
								var response = {
									data: responseData,
									status: request.status,
									statusText: request.statusText,
									headers: responseHeaders,
									config: config,
									request: request
								};

								settle(resolve, reject, response);

								// Clean up request
								request = null;
							};

							// Handle browser request cancellation (as opposed to a manual cancellation)
							request.onabort = function handleAbort() {
								if (!request) {
									return;
								}

								reject(
									createError(
										'Request aborted',
										config,
										'ECONNABORTED',
										request
									)
								);

								// Clean up request
								request = null;
							};

							// Handle low level network errors
							request.onerror = function handleError() {
								// Real errors are hidden from us by the browser
								// onerror should only fire if it's a network error
								reject(createError('Network Error', config, null, request));

								// Clean up request
								request = null;
							};

							// Handle timeout
							request.ontimeout = function handleTimeout() {
								reject(
									createError(
										'timeout of ' + config.timeout + 'ms exceeded',
										config,
										'ECONNABORTED',
										request
									)
								);

								// Clean up request
								request = null;
							};

							// Add xsrf header
							// This is only done if running in a standard browser environment.
							// Specifically not if we're in a web worker, or react-native.
							if (utils.isStandardBrowserEnv()) {
								var cookies = _dereq_('./../helpers/cookies');

								// Add xsrf header
								var xsrfValue =
									(config.withCredentials || isURLSameOrigin(config.url)) &&
									config.xsrfCookieName
										? cookies.read(config.xsrfCookieName)
										: undefined;

								if (xsrfValue) {
									requestHeaders[config.xsrfHeaderName] = xsrfValue;
								}
							}

							// Add headers to the request
							if ('setRequestHeader' in request) {
								utils.forEach(requestHeaders, function setRequestHeader(
									val,
									key
								) {
									if (
										typeof requestData === 'undefined' &&
										key.toLowerCase() === 'content-type'
									) {
										// Remove Content-Type if data is undefined
										delete requestHeaders[key];
									} else {
										// Otherwise add header to the request
										request.setRequestHeader(key, val);
									}
								});
							}

							// Add withCredentials to request if needed
							if (config.withCredentials) {
								request.withCredentials = true;
							}

							// Add responseType to request if needed
							if (config.responseType) {
								try {
									request.responseType = config.responseType;
								} catch (e) {
									// Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
									// But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
									if (config.responseType !== 'json') {
										throw e;
									}
								}
							}

							// Handle progress if needed
							if (typeof config.onDownloadProgress === 'function') {
								request.addEventListener('progress', config.onDownloadProgress);
							}

							// Not all browsers support upload events
							if (
								typeof config.onUploadProgress === 'function' &&
								request.upload
							) {
								request.upload.addEventListener(
									'progress',
									config.onUploadProgress
								);
							}

							if (config.cancelToken) {
								// Handle cancellation
								config.cancelToken.promise.then(function onCanceled(cancel) {
									if (!request) {
										return;
									}

									request.abort();
									reject(cancel);
									// Clean up request
									request = null;
								});
							}

							if (requestData === undefined) {
								requestData = null;
							}

							// Send the request
							request.send(requestData);
						});
					};
				},
				{
					'../core/createError': 11,
					'./../core/settle': 15,
					'./../helpers/buildURL': 19,
					'./../helpers/cookies': 21,
					'./../helpers/isURLSameOrigin': 23,
					'./../helpers/parseHeaders': 25,
					'./../utils': 27
				}
			],
			5: [
				function(_dereq_, module, exports) {
					'use strict';

					var utils = _dereq_('./utils');
					var bind = _dereq_('./helpers/bind');
					var Axios = _dereq_('./core/Axios');
					var mergeConfig = _dereq_('./core/mergeConfig');
					var defaults = _dereq_('./defaults');

					/**
					 * Create an instance of Axios
					 *
					 * @param {Object} defaultConfig The default config for the instance
					 * @return {Axios} A new instance of Axios
					 */
					function createInstance(defaultConfig) {
						var context = new Axios(defaultConfig);
						var instance = bind(Axios.prototype.request, context);

						// Copy axios.prototype to instance
						utils.extend(instance, Axios.prototype, context);

						// Copy context to instance
						utils.extend(instance, context);

						return instance;
					}

					// Create the default instance to be exported
					var axios = createInstance(defaults);

					// Expose Axios class to allow class inheritance
					axios.Axios = Axios;

					// Factory for creating new instances
					axios.create = function create(instanceConfig) {
						return createInstance(mergeConfig(axios.defaults, instanceConfig));
					};

					// Expose Cancel & CancelToken
					axios.Cancel = _dereq_('./cancel/Cancel');
					axios.CancelToken = _dereq_('./cancel/CancelToken');
					axios.isCancel = _dereq_('./cancel/isCancel');

					// Expose all/spread
					axios.all = function all(promises) {
						return Promise.all(promises);
					};
					axios.spread = _dereq_('./helpers/spread');

					module.exports = axios;

					// Allow use of default import syntax in TypeScript
					module.exports.default = axios;
				},
				{
					'./cancel/Cancel': 6,
					'./cancel/CancelToken': 7,
					'./cancel/isCancel': 8,
					'./core/Axios': 9,
					'./core/mergeConfig': 14,
					'./defaults': 17,
					'./helpers/bind': 18,
					'./helpers/spread': 26,
					'./utils': 27
				}
			],
			6: [
				function(_dereq_, module, exports) {
					'use strict';

					/**
					 * A `Cancel` is an object that is thrown when an operation is canceled.
					 *
					 * @class
					 * @param {string=} message The message.
					 */
					function Cancel(message) {
						this.message = message;
					}

					Cancel.prototype.toString = function toString() {
						return 'Cancel' + (this.message ? ': ' + this.message : '');
					};

					Cancel.prototype.__CANCEL__ = true;

					module.exports = Cancel;
				},
				{}
			],
			7: [
				function(_dereq_, module, exports) {
					'use strict';

					var Cancel = _dereq_('./Cancel');

					/**
					 * A `CancelToken` is an object that can be used to request cancellation of an operation.
					 *
					 * @class
					 * @param {Function} executor The executor function.
					 */
					function CancelToken(executor) {
						if (typeof executor !== 'function') {
							throw new TypeError('executor must be a function.');
						}

						var resolvePromise;
						this.promise = new Promise(function promiseExecutor(resolve) {
							resolvePromise = resolve;
						});

						var token = this;
						executor(function cancel(message) {
							if (token.reason) {
								// Cancellation has already been requested
								return;
							}

							token.reason = new Cancel(message);
							resolvePromise(token.reason);
						});
					}

					/**
					 * Throws a `Cancel` if cancellation has been requested.
					 */
					CancelToken.prototype.throwIfRequested = function throwIfRequested() {
						if (this.reason) {
							throw this.reason;
						}
					};

					/**
					 * Returns an object that contains a new `CancelToken` and a function that, when called,
					 * cancels the `CancelToken`.
					 */
					CancelToken.source = function source() {
						var cancel;
						var token = new CancelToken(function executor(c) {
							cancel = c;
						});
						return {
							token: token,
							cancel: cancel
						};
					};

					module.exports = CancelToken;
				},
				{ './Cancel': 6 }
			],
			8: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = function isCancel(value) {
						return !!(value && value.__CANCEL__);
					};
				},
				{}
			],
			9: [
				function(_dereq_, module, exports) {
					'use strict';

					var utils = _dereq_('./../utils');
					var buildURL = _dereq_('../helpers/buildURL');
					var InterceptorManager = _dereq_('./InterceptorManager');
					var dispatchRequest = _dereq_('./dispatchRequest');
					var mergeConfig = _dereq_('./mergeConfig');

					/**
					 * Create a new instance of Axios
					 *
					 * @param {Object} instanceConfig The default config for the instance
					 */
					function Axios(instanceConfig) {
						this.defaults = instanceConfig;
						this.interceptors = {
							request: new InterceptorManager(),
							response: new InterceptorManager()
						};
					}

					/**
					 * Dispatch a request
					 *
					 * @param {Object} config The config specific for this request (merged with this.defaults)
					 */
					Axios.prototype.request = function request(config) {
						/*eslint no-param-reassign:0*/
						// Allow for axios('example/url'[, config]) a la fetch API
						if (typeof config === 'string') {
							config = arguments[1] || {};
							config.url = arguments[0];
						} else {
							config = config || {};
						}

						config = mergeConfig(this.defaults, config);
						config.method = config.method ? config.method.toLowerCase() : 'get';

						// Hook up interceptors middleware
						var chain = [dispatchRequest, undefined];
						var promise = Promise.resolve(config);

						this.interceptors.request.forEach(
							function unshiftRequestInterceptors(interceptor) {
								chain.unshift(interceptor.fulfilled, interceptor.rejected);
							}
						);

						this.interceptors.response.forEach(
							function pushResponseInterceptors(interceptor) {
								chain.push(interceptor.fulfilled, interceptor.rejected);
							}
						);

						while (chain.length) {
							promise = promise.then(chain.shift(), chain.shift());
						}

						return promise;
					};

					Axios.prototype.getUri = function getUri(config) {
						config = mergeConfig(this.defaults, config);
						return buildURL(
							config.url,
							config.params,
							config.paramsSerializer
						).replace(/^\?/, '');
					};

					// Provide aliases for supported request methods
					utils.forEach(
						['delete', 'get', 'head', 'options'],
						function forEachMethodNoData(method) {
							/*eslint func-names:0*/
							Axios.prototype[method] = function(url, config) {
								return this.request(
									utils.merge(config || {}, {
										method: method,
										url: url
									})
								);
							};
						}
					);

					utils.forEach(
						['post', 'put', 'patch'],
						function forEachMethodWithData(method) {
							/*eslint func-names:0*/
							Axios.prototype[method] = function(url, data, config) {
								return this.request(
									utils.merge(config || {}, {
										method: method,
										url: url,
										data: data
									})
								);
							};
						}
					);

					module.exports = Axios;
				},
				{
					'../helpers/buildURL': 19,
					'./../utils': 27,
					'./InterceptorManager': 10,
					'./dispatchRequest': 12,
					'./mergeConfig': 14
				}
			],
			10: [
				function(_dereq_, module, exports) {
					'use strict';

					var utils = _dereq_('./../utils');

					function InterceptorManager() {
						this.handlers = [];
					}

					/**
					 * Add a new interceptor to the stack
					 *
					 * @param {Function} fulfilled The function to handle `then` for a `Promise`
					 * @param {Function} rejected The function to handle `reject` for a `Promise`
					 *
					 * @return {Number} An ID used to remove interceptor later
					 */
					InterceptorManager.prototype.use = function use(fulfilled, rejected) {
						this.handlers.push({
							fulfilled: fulfilled,
							rejected: rejected
						});
						return this.handlers.length - 1;
					};

					/**
					 * Remove an interceptor from the stack
					 *
					 * @param {Number} id The ID that was returned by `use`
					 */
					InterceptorManager.prototype.eject = function eject(id) {
						if (this.handlers[id]) {
							this.handlers[id] = null;
						}
					};

					/**
					 * Iterate over all the registered interceptors
					 *
					 * This method is particularly useful for skipping over any
					 * interceptors that may have become `null` calling `eject`.
					 *
					 * @param {Function} fn The function to call for each interceptor
					 */
					InterceptorManager.prototype.forEach = function forEach(fn) {
						utils.forEach(this.handlers, function forEachHandler(h) {
							if (h !== null) {
								fn(h);
							}
						});
					};

					module.exports = InterceptorManager;
				},
				{ './../utils': 27 }
			],
			11: [
				function(_dereq_, module, exports) {
					'use strict';

					var enhanceError = _dereq_('./enhanceError');

					/**
					 * Create an Error with the specified message, config, error code, request and response.
					 *
					 * @param {string} message The error message.
					 * @param {Object} config The config.
					 * @param {string} [code] The error code (for example, 'ECONNABORTED').
					 * @param {Object} [request] The request.
					 * @param {Object} [response] The response.
					 * @returns {Error} The created error.
					 */
					module.exports = function createError(
						message,
						config,
						code,
						request,
						response
					) {
						var error = new Error(message);
						return enhanceError(error, config, code, request, response);
					};
				},
				{ './enhanceError': 13 }
			],
			12: [
				function(_dereq_, module, exports) {
					'use strict';

					var utils = _dereq_('./../utils');
					var transformData = _dereq_('./transformData');
					var isCancel = _dereq_('../cancel/isCancel');
					var defaults = _dereq_('../defaults');
					var isAbsoluteURL = _dereq_('./../helpers/isAbsoluteURL');
					var combineURLs = _dereq_('./../helpers/combineURLs');

					/**
					 * Throws a `Cancel` if cancellation has been requested.
					 */
					function throwIfCancellationRequested(config) {
						if (config.cancelToken) {
							config.cancelToken.throwIfRequested();
						}
					}

					/**
					 * Dispatch a request to the server using the configured adapter.
					 *
					 * @param {object} config The config that is to be used for the request
					 * @returns {Promise} The Promise to be fulfilled
					 */
					module.exports = function dispatchRequest(config) {
						throwIfCancellationRequested(config);

						// Support baseURL config
						if (config.baseURL && !isAbsoluteURL(config.url)) {
							config.url = combineURLs(config.baseURL, config.url);
						}

						// Ensure headers exist
						config.headers = config.headers || {};

						// Transform request data
						config.data = transformData(
							config.data,
							config.headers,
							config.transformRequest
						);

						// Flatten headers
						config.headers = utils.merge(
							config.headers.common || {},
							config.headers[config.method] || {},
							config.headers || {}
						);

						utils.forEach(
							['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
							function cleanHeaderConfig(method) {
								delete config.headers[method];
							}
						);

						var adapter = config.adapter || defaults.adapter;

						return adapter(config).then(
							function onAdapterResolution(response) {
								throwIfCancellationRequested(config);

								// Transform response data
								response.data = transformData(
									response.data,
									response.headers,
									config.transformResponse
								);

								return response;
							},
							function onAdapterRejection(reason) {
								if (!isCancel(reason)) {
									throwIfCancellationRequested(config);

									// Transform response data
									if (reason && reason.response) {
										reason.response.data = transformData(
											reason.response.data,
											reason.response.headers,
											config.transformResponse
										);
									}
								}

								return Promise.reject(reason);
							}
						);
					};
				},
				{
					'../cancel/isCancel': 8,
					'../defaults': 17,
					'./../helpers/combineURLs': 20,
					'./../helpers/isAbsoluteURL': 22,
					'./../utils': 27,
					'./transformData': 16
				}
			],
			13: [
				function(_dereq_, module, exports) {
					'use strict';

					/**
					 * Update an Error with the specified config, error code, and response.
					 *
					 * @param {Error} error The error to update.
					 * @param {Object} config The config.
					 * @param {string} [code] The error code (for example, 'ECONNABORTED').
					 * @param {Object} [request] The request.
					 * @param {Object} [response] The response.
					 * @returns {Error} The error.
					 */
					module.exports = function enhanceError(
						error,
						config,
						code,
						request,
						response
					) {
						error.config = config;
						if (code) {
							error.code = code;
						}

						error.request = request;
						error.response = response;
						error.isAxiosError = true;

						error.toJSON = function() {
							return {
								// Standard
								message: this.message,
								name: this.name,
								// Microsoft
								description: this.description,
								number: this.number,
								// Mozilla
								fileName: this.fileName,
								lineNumber: this.lineNumber,
								columnNumber: this.columnNumber,
								stack: this.stack,
								// Axios
								config: this.config,
								code: this.code
							};
						};
						return error;
					};
				},
				{}
			],
			14: [
				function(_dereq_, module, exports) {
					'use strict';

					var utils = _dereq_('../utils');

					/**
					 * Config-specific merge-function which creates a new config-object
					 * by merging two configuration objects together.
					 *
					 * @param {Object} config1
					 * @param {Object} config2
					 * @returns {Object} New object resulting from merging config2 to config1
					 */
					module.exports = function mergeConfig(config1, config2) {
						// eslint-disable-next-line no-param-reassign
						config2 = config2 || {};
						var config = {};

						utils.forEach(
							['url', 'method', 'params', 'data'],
							function valueFromConfig2(prop) {
								if (typeof config2[prop] !== 'undefined') {
									config[prop] = config2[prop];
								}
							}
						);

						utils.forEach(
							['headers', 'auth', 'proxy'],
							function mergeDeepProperties(prop) {
								if (utils.isObject(config2[prop])) {
									config[prop] = utils.deepMerge(config1[prop], config2[prop]);
								} else if (typeof config2[prop] !== 'undefined') {
									config[prop] = config2[prop];
								} else if (utils.isObject(config1[prop])) {
									config[prop] = utils.deepMerge(config1[prop]);
								} else if (typeof config1[prop] !== 'undefined') {
									config[prop] = config1[prop];
								}
							}
						);

						utils.forEach(
							[
								'baseURL',
								'transformRequest',
								'transformResponse',
								'paramsSerializer',
								'timeout',
								'withCredentials',
								'adapter',
								'responseType',
								'xsrfCookieName',
								'xsrfHeaderName',
								'onUploadProgress',
								'onDownloadProgress',
								'maxContentLength',
								'validateStatus',
								'maxRedirects',
								'httpAgent',
								'httpsAgent',
								'cancelToken',
								'socketPath'
							],
							function defaultToConfig2(prop) {
								if (typeof config2[prop] !== 'undefined') {
									config[prop] = config2[prop];
								} else if (typeof config1[prop] !== 'undefined') {
									config[prop] = config1[prop];
								}
							}
						);

						return config;
					};
				},
				{ '../utils': 27 }
			],
			15: [
				function(_dereq_, module, exports) {
					'use strict';

					var createError = _dereq_('./createError');

					/**
					 * Resolve or reject a Promise based on response status.
					 *
					 * @param {Function} resolve A function that resolves the promise.
					 * @param {Function} reject A function that rejects the promise.
					 * @param {object} response The response.
					 */
					module.exports = function settle(resolve, reject, response) {
						var validateStatus = response.config.validateStatus;
						if (!validateStatus || validateStatus(response.status)) {
							resolve(response);
						} else {
							reject(
								createError(
									'Request failed with status code ' + response.status,
									response.config,
									null,
									response.request,
									response
								)
							);
						}
					};
				},
				{ './createError': 11 }
			],
			16: [
				function(_dereq_, module, exports) {
					'use strict';

					var utils = _dereq_('./../utils');

					/**
					 * Transform the data for a request or a response
					 *
					 * @param {Object|String} data The data to be transformed
					 * @param {Array} headers The headers for the request or response
					 * @param {Array|Function} fns A single function or Array of functions
					 * @returns {*} The resulting transformed data
					 */
					module.exports = function transformData(data, headers, fns) {
						/*eslint no-param-reassign:0*/
						utils.forEach(fns, function transform(fn) {
							data = fn(data, headers);
						});

						return data;
					};
				},
				{ './../utils': 27 }
			],
			17: [
				function(_dereq_, module, exports) {
					(function(process) {
						'use strict';

						var utils = _dereq_('./utils');
						var normalizeHeaderName = _dereq_('./helpers/normalizeHeaderName');

						var DEFAULT_CONTENT_TYPE = {
							'Content-Type': 'application/x-www-form-urlencoded'
						};

						function setContentTypeIfUnset(headers, value) {
							if (
								!utils.isUndefined(headers) &&
								utils.isUndefined(headers['Content-Type'])
							) {
								headers['Content-Type'] = value;
							}
						}

						function getDefaultAdapter() {
							var adapter;
							// Only Node.JS has a process variable that is of [[Class]] process
							if (
								typeof process !== 'undefined' &&
								Object.prototype.toString.call(process) === '[object process]'
							) {
								// For node use HTTP adapter
								adapter = _dereq_('./adapters/http');
							} else if (typeof XMLHttpRequest !== 'undefined') {
								// For browsers use XHR adapter
								adapter = _dereq_('./adapters/xhr');
							}
							return adapter;
						}

						var defaults = {
							adapter: getDefaultAdapter(),

							transformRequest: [
								function transformRequest(data, headers) {
									normalizeHeaderName(headers, 'Accept');
									normalizeHeaderName(headers, 'Content-Type');
									if (
										utils.isFormData(data) ||
										utils.isArrayBuffer(data) ||
										utils.isBuffer(data) ||
										utils.isStream(data) ||
										utils.isFile(data) ||
										utils.isBlob(data)
									) {
										return data;
									}
									if (utils.isArrayBufferView(data)) {
										return data.buffer;
									}
									if (utils.isURLSearchParams(data)) {
										setContentTypeIfUnset(
											headers,
											'application/x-www-form-urlencoded;charset=utf-8'
										);
										return data.toString();
									}
									if (utils.isObject(data)) {
										setContentTypeIfUnset(
											headers,
											'application/json;charset=utf-8'
										);
										return JSON.stringify(data);
									}
									return data;
								}
							],

							transformResponse: [
								function transformResponse(data) {
									/*eslint no-param-reassign:0*/
									if (typeof data === 'string') {
										try {
											data = JSON.parse(data);
										} catch (e) {
											/* Ignore */
										}
									}
									return data;
								}
							],

							/**
							 * A timeout in milliseconds to abort a request. If set to 0 (default) a
							 * timeout is not created.
							 */
							timeout: 0,

							xsrfCookieName: 'XSRF-TOKEN',
							xsrfHeaderName: 'X-XSRF-TOKEN',

							maxContentLength: -1,

							validateStatus: function validateStatus(status) {
								return status >= 200 && status < 300;
							}
						};

						defaults.headers = {
							common: {
								Accept: 'application/json, text/plain, */*'
							}
						};

						utils.forEach(
							['delete', 'get', 'head'],
							function forEachMethodNoData(method) {
								defaults.headers[method] = {};
							}
						);

						utils.forEach(
							['post', 'put', 'patch'],
							function forEachMethodWithData(method) {
								defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
							}
						);

						module.exports = defaults;
					}.call(this, _dereq_('_process')));
				},
				{
					'./adapters/http': 4,
					'./adapters/xhr': 4,
					'./helpers/normalizeHeaderName': 24,
					'./utils': 27,
					_process: 234
				}
			],
			18: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = function bind(fn, thisArg) {
						return function wrap() {
							var args = new Array(arguments.length);
							for (var i = 0; i < args.length; i++) {
								args[i] = arguments[i];
							}
							return fn.apply(thisArg, args);
						};
					};
				},
				{}
			],
			19: [
				function(_dereq_, module, exports) {
					'use strict';

					var utils = _dereq_('./../utils');

					function encode(val) {
						return encodeURIComponent(val)
							.replace(/%40/gi, '@')
							.replace(/%3A/gi, ':')
							.replace(/%24/g, '$')
							.replace(/%2C/gi, ',')
							.replace(/%20/g, '+')
							.replace(/%5B/gi, '[')
							.replace(/%5D/gi, ']');
					}

					/**
					 * Build a URL by appending params to the end
					 *
					 * @param {string} url The base of the url (e.g., http://www.google.com)
					 * @param {object} [params] The params to be appended
					 * @returns {string} The formatted url
					 */
					module.exports = function buildURL(url, params, paramsSerializer) {
						/*eslint no-param-reassign:0*/
						if (!params) {
							return url;
						}

						var serializedParams;
						if (paramsSerializer) {
							serializedParams = paramsSerializer(params);
						} else if (utils.isURLSearchParams(params)) {
							serializedParams = params.toString();
						} else {
							var parts = [];

							utils.forEach(params, function serialize(val, key) {
								if (val === null || typeof val === 'undefined') {
									return;
								}

								if (utils.isArray(val)) {
									key = key + '[]';
								} else {
									val = [val];
								}

								utils.forEach(val, function parseValue(v) {
									if (utils.isDate(v)) {
										v = v.toISOString();
									} else if (utils.isObject(v)) {
										v = JSON.stringify(v);
									}
									parts.push(encode(key) + '=' + encode(v));
								});
							});

							serializedParams = parts.join('&');
						}

						if (serializedParams) {
							var hashmarkIndex = url.indexOf('#');
							if (hashmarkIndex !== -1) {
								url = url.slice(0, hashmarkIndex);
							}

							url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
						}

						return url;
					};
				},
				{ './../utils': 27 }
			],
			20: [
				function(_dereq_, module, exports) {
					'use strict';

					/**
					 * Creates a new URL by combining the specified URLs
					 *
					 * @param {string} baseURL The base URL
					 * @param {string} relativeURL The relative URL
					 * @returns {string} The combined URL
					 */
					module.exports = function combineURLs(baseURL, relativeURL) {
						return relativeURL
							? baseURL.replace(/\/+$/, '') +
									'/' +
									relativeURL.replace(/^\/+/, '')
							: baseURL;
					};
				},
				{}
			],
			21: [
				function(_dereq_, module, exports) {
					'use strict';

					var utils = _dereq_('./../utils');

					module.exports = utils.isStandardBrowserEnv()
						? // Standard browser envs support document.cookie
						  (function standardBrowserEnv() {
								return {
									write: function write(
										name,
										value,
										expires,
										path,
										domain,
										secure
									) {
										var cookie = [];
										cookie.push(name + '=' + encodeURIComponent(value));

										if (utils.isNumber(expires)) {
											cookie.push('expires=' + new Date(expires).toGMTString());
										}

										if (utils.isString(path)) {
											cookie.push('path=' + path);
										}

										if (utils.isString(domain)) {
											cookie.push('domain=' + domain);
										}

										if (secure === true) {
											cookie.push('secure');
										}

										document.cookie = cookie.join('; ');
									},

									read: function read(name) {
										var match = document.cookie.match(
											new RegExp('(^|;\\s*)(' + name + ')=([^;]*)')
										);
										return match ? decodeURIComponent(match[3]) : null;
									},

									remove: function remove(name) {
										this.write(name, '', Date.now() - 86400000);
									}
								};
						  })()
						: // Non standard browser env (web workers, react-native) lack needed support.
						  (function nonStandardBrowserEnv() {
								return {
									write: function write() {},
									read: function read() {
										return null;
									},
									remove: function remove() {}
								};
						  })();
				},
				{ './../utils': 27 }
			],
			22: [
				function(_dereq_, module, exports) {
					'use strict';

					/**
					 * Determines whether the specified URL is absolute
					 *
					 * @param {string} url The URL to test
					 * @returns {boolean} True if the specified URL is absolute, otherwise false
					 */
					module.exports = function isAbsoluteURL(url) {
						// A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
						// RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
						// by any combination of letters, digits, plus, period, or hyphen.
						return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
					};
				},
				{}
			],
			23: [
				function(_dereq_, module, exports) {
					'use strict';

					var utils = _dereq_('./../utils');

					module.exports = utils.isStandardBrowserEnv()
						? // Standard browser envs have full support of the APIs needed to test
						  // whether the request URL is of the same origin as current location.
						  (function standardBrowserEnv() {
								var msie = /(msie|trident)/i.test(navigator.userAgent);
								var urlParsingNode = document.createElement('a');
								var originURL;

								/**
								 * Parse a URL to discover it's components
								 *
								 * @param {String} url The URL to be parsed
								 * @returns {Object}
								 */
								function resolveURL(url) {
									var href = url;

									if (msie) {
										// IE needs attribute set twice to normalize properties
										urlParsingNode.setAttribute('href', href);
										href = urlParsingNode.href;
									}

									urlParsingNode.setAttribute('href', href);

									// urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
									return {
										href: urlParsingNode.href,
										protocol: urlParsingNode.protocol
											? urlParsingNode.protocol.replace(/:$/, '')
											: '',
										host: urlParsingNode.host,
										search: urlParsingNode.search
											? urlParsingNode.search.replace(/^\?/, '')
											: '',
										hash: urlParsingNode.hash
											? urlParsingNode.hash.replace(/^#/, '')
											: '',
										hostname: urlParsingNode.hostname,
										port: urlParsingNode.port,
										pathname:
											urlParsingNode.pathname.charAt(0) === '/'
												? urlParsingNode.pathname
												: '/' + urlParsingNode.pathname
									};
								}

								originURL = resolveURL(window.location.href);

								/**
								 * Determine if a URL shares the same origin as the current location
								 *
								 * @param {String} requestURL The URL to test
								 * @returns {boolean} True if URL shares the same origin, otherwise false
								 */
								return function isURLSameOrigin(requestURL) {
									var parsed = utils.isString(requestURL)
										? resolveURL(requestURL)
										: requestURL;
									return (
										parsed.protocol === originURL.protocol &&
										parsed.host === originURL.host
									);
								};
						  })()
						: // Non standard browser envs (web workers, react-native) lack needed support.
						  (function nonStandardBrowserEnv() {
								return function isURLSameOrigin() {
									return true;
								};
						  })();
				},
				{ './../utils': 27 }
			],
			24: [
				function(_dereq_, module, exports) {
					'use strict';

					var utils = _dereq_('../utils');

					module.exports = function normalizeHeaderName(
						headers,
						normalizedName
					) {
						utils.forEach(headers, function processHeader(value, name) {
							if (
								name !== normalizedName &&
								name.toUpperCase() === normalizedName.toUpperCase()
							) {
								headers[normalizedName] = value;
								delete headers[name];
							}
						});
					};
				},
				{ '../utils': 27 }
			],
			25: [
				function(_dereq_, module, exports) {
					'use strict';

					var utils = _dereq_('./../utils');

					// Headers whose duplicates are ignored by node
					// c.f. https://nodejs.org/api/http.html#http_message_headers
					var ignoreDuplicateOf = [
						'age',
						'authorization',
						'content-length',
						'content-type',
						'etag',
						'expires',
						'from',
						'host',
						'if-modified-since',
						'if-unmodified-since',
						'last-modified',
						'location',
						'max-forwards',
						'proxy-authorization',
						'referer',
						'retry-after',
						'user-agent'
					];

					/**
					 * Parse headers into an object
					 *
					 * ```
					 * Date: Wed, 27 Aug 2014 08:58:49 GMT
					 * Content-Type: application/json
					 * Connection: keep-alive
					 * Transfer-Encoding: chunked
					 * ```
					 *
					 * @param {String} headers Headers needing to be parsed
					 * @returns {Object} Headers parsed into an object
					 */
					module.exports = function parseHeaders(headers) {
						var parsed = {};
						var key;
						var val;
						var i;

						if (!headers) {
							return parsed;
						}

						utils.forEach(headers.split('\n'), function parser(line) {
							i = line.indexOf(':');
							key = utils.trim(line.substr(0, i)).toLowerCase();
							val = utils.trim(line.substr(i + 1));

							if (key) {
								if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
									return;
								}
								if (key === 'set-cookie') {
									parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
								} else {
									parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
								}
							}
						});

						return parsed;
					};
				},
				{ './../utils': 27 }
			],
			26: [
				function(_dereq_, module, exports) {
					'use strict';

					/**
					 * Syntactic sugar for invoking a function and expanding an array for arguments.
					 *
					 * Common use case would be to use `Function.prototype.apply`.
					 *
					 *  ```js
					 *  function f(x, y, z) {}
					 *  var args = [1, 2, 3];
					 *  f.apply(null, args);
					 *  ```
					 *
					 * With `spread` this example can be re-written.
					 *
					 *  ```js
					 *  spread(function(x, y, z) {})([1, 2, 3]);
					 *  ```
					 *
					 * @param {Function} callback
					 * @returns {Function}
					 */
					module.exports = function spread(callback) {
						return function wrap(arr) {
							return callback.apply(null, arr);
						};
					};
				},
				{}
			],
			27: [
				function(_dereq_, module, exports) {
					'use strict';

					var bind = _dereq_('./helpers/bind');
					var isBuffer = _dereq_('is-buffer');

					/*global toString:true*/

					// utils is a library of generic helper functions non-specific to axios

					var toString = Object.prototype.toString;

					/**
					 * Determine if a value is an Array
					 *
					 * @param {Object} val The value to test
					 * @returns {boolean} True if value is an Array, otherwise false
					 */
					function isArray(val) {
						return toString.call(val) === '[object Array]';
					}

					/**
					 * Determine if a value is an ArrayBuffer
					 *
					 * @param {Object} val The value to test
					 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
					 */
					function isArrayBuffer(val) {
						return toString.call(val) === '[object ArrayBuffer]';
					}

					/**
					 * Determine if a value is a FormData
					 *
					 * @param {Object} val The value to test
					 * @returns {boolean} True if value is an FormData, otherwise false
					 */
					function isFormData(val) {
						return typeof FormData !== 'undefined' && val instanceof FormData;
					}

					/**
					 * Determine if a value is a view on an ArrayBuffer
					 *
					 * @param {Object} val The value to test
					 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
					 */
					function isArrayBufferView(val) {
						var result;
						if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
							result = ArrayBuffer.isView(val);
						} else {
							result = val && val.buffer && val.buffer instanceof ArrayBuffer;
						}
						return result;
					}

					/**
					 * Determine if a value is a String
					 *
					 * @param {Object} val The value to test
					 * @returns {boolean} True if value is a String, otherwise false
					 */
					function isString(val) {
						return typeof val === 'string';
					}

					/**
					 * Determine if a value is a Number
					 *
					 * @param {Object} val The value to test
					 * @returns {boolean} True if value is a Number, otherwise false
					 */
					function isNumber(val) {
						return typeof val === 'number';
					}

					/**
					 * Determine if a value is undefined
					 *
					 * @param {Object} val The value to test
					 * @returns {boolean} True if the value is undefined, otherwise false
					 */
					function isUndefined(val) {
						return typeof val === 'undefined';
					}

					/**
					 * Determine if a value is an Object
					 *
					 * @param {Object} val The value to test
					 * @returns {boolean} True if value is an Object, otherwise false
					 */
					function isObject(val) {
						return val !== null && typeof val === 'object';
					}

					/**
					 * Determine if a value is a Date
					 *
					 * @param {Object} val The value to test
					 * @returns {boolean} True if value is a Date, otherwise false
					 */
					function isDate(val) {
						return toString.call(val) === '[object Date]';
					}

					/**
					 * Determine if a value is a File
					 *
					 * @param {Object} val The value to test
					 * @returns {boolean} True if value is a File, otherwise false
					 */
					function isFile(val) {
						return toString.call(val) === '[object File]';
					}

					/**
					 * Determine if a value is a Blob
					 *
					 * @param {Object} val The value to test
					 * @returns {boolean} True if value is a Blob, otherwise false
					 */
					function isBlob(val) {
						return toString.call(val) === '[object Blob]';
					}

					/**
					 * Determine if a value is a Function
					 *
					 * @param {Object} val The value to test
					 * @returns {boolean} True if value is a Function, otherwise false
					 */
					function isFunction(val) {
						return toString.call(val) === '[object Function]';
					}

					/**
					 * Determine if a value is a Stream
					 *
					 * @param {Object} val The value to test
					 * @returns {boolean} True if value is a Stream, otherwise false
					 */
					function isStream(val) {
						return isObject(val) && isFunction(val.pipe);
					}

					/**
					 * Determine if a value is a URLSearchParams object
					 *
					 * @param {Object} val The value to test
					 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
					 */
					function isURLSearchParams(val) {
						return (
							typeof URLSearchParams !== 'undefined' &&
							val instanceof URLSearchParams
						);
					}

					/**
					 * Trim excess whitespace off the beginning and end of a string
					 *
					 * @param {String} str The String to trim
					 * @returns {String} The String freed of excess whitespace
					 */
					function trim(str) {
						return str.replace(/^\s*/, '').replace(/\s*$/, '');
					}

					/**
					 * Determine if we're running in a standard browser environment
					 *
					 * This allows axios to run in a web worker, and react-native.
					 * Both environments support XMLHttpRequest, but not fully standard globals.
					 *
					 * web workers:
					 *  typeof window -> undefined
					 *  typeof document -> undefined
					 *
					 * react-native:
					 *  navigator.product -> 'ReactNative'
					 * nativescript
					 *  navigator.product -> 'NativeScript' or 'NS'
					 */
					function isStandardBrowserEnv() {
						if (
							typeof navigator !== 'undefined' &&
							(navigator.product === 'ReactNative' ||
								navigator.product === 'NativeScript' ||
								navigator.product === 'NS')
						) {
							return false;
						}
						return (
							typeof window !== 'undefined' && typeof document !== 'undefined'
						);
					}

					/**
					 * Iterate over an Array or an Object invoking a function for each item.
					 *
					 * If `obj` is an Array callback will be called passing
					 * the value, index, and complete array for each item.
					 *
					 * If 'obj' is an Object callback will be called passing
					 * the value, key, and complete object for each property.
					 *
					 * @param {Object|Array} obj The object to iterate
					 * @param {Function} fn The callback to invoke for each item
					 */
					function forEach(obj, fn) {
						// Don't bother if no value provided
						if (obj === null || typeof obj === 'undefined') {
							return;
						}

						// Force an array if not already something iterable
						if (typeof obj !== 'object') {
							/*eslint no-param-reassign:0*/
							obj = [obj];
						}

						if (isArray(obj)) {
							// Iterate over array values
							for (var i = 0, l = obj.length; i < l; i++) {
								fn.call(null, obj[i], i, obj);
							}
						} else {
							// Iterate over object keys
							for (var key in obj) {
								if (Object.prototype.hasOwnProperty.call(obj, key)) {
									fn.call(null, obj[key], key, obj);
								}
							}
						}
					}

					/**
					 * Accepts varargs expecting each argument to be an object, then
					 * immutably merges the properties of each object and returns result.
					 *
					 * When multiple objects contain the same key the later object in
					 * the arguments list will take precedence.
					 *
					 * Example:
					 *
					 * ```js
					 * var result = merge({foo: 123}, {foo: 456});
					 * console.log(result.foo); // outputs 456
					 * ```
					 *
					 * @param {Object} obj1 Object to merge
					 * @returns {Object} Result of all merge properties
					 */
					function merge(/* obj1, obj2, obj3, ... */) {
						var result = {};
						function assignValue(val, key) {
							if (typeof result[key] === 'object' && typeof val === 'object') {
								result[key] = merge(result[key], val);
							} else {
								result[key] = val;
							}
						}

						for (var i = 0, l = arguments.length; i < l; i++) {
							forEach(arguments[i], assignValue);
						}
						return result;
					}

					/**
					 * Function equal to merge with the difference being that no reference
					 * to original objects is kept.
					 *
					 * @see merge
					 * @param {Object} obj1 Object to merge
					 * @returns {Object} Result of all merge properties
					 */
					function deepMerge(/* obj1, obj2, obj3, ... */) {
						var result = {};
						function assignValue(val, key) {
							if (typeof result[key] === 'object' && typeof val === 'object') {
								result[key] = deepMerge(result[key], val);
							} else if (typeof val === 'object') {
								result[key] = deepMerge({}, val);
							} else {
								result[key] = val;
							}
						}

						for (var i = 0, l = arguments.length; i < l; i++) {
							forEach(arguments[i], assignValue);
						}
						return result;
					}

					/**
					 * Extends object a by mutably adding to it the properties of object b.
					 *
					 * @param {Object} a The object to be extended
					 * @param {Object} b The object to copy properties from
					 * @param {Object} thisArg The object to bind function to
					 * @return {Object} The resulting value of object a
					 */
					function extend(a, b, thisArg) {
						forEach(b, function assignValue(val, key) {
							if (thisArg && typeof val === 'function') {
								a[key] = bind(val, thisArg);
							} else {
								a[key] = val;
							}
						});
						return a;
					}

					module.exports = {
						isArray: isArray,
						isArrayBuffer: isArrayBuffer,
						isBuffer: isBuffer,
						isFormData: isFormData,
						isArrayBufferView: isArrayBufferView,
						isString: isString,
						isNumber: isNumber,
						isObject: isObject,
						isUndefined: isUndefined,
						isDate: isDate,
						isFile: isFile,
						isBlob: isBlob,
						isFunction: isFunction,
						isStream: isStream,
						isURLSearchParams: isURLSearchParams,
						isStandardBrowserEnv: isStandardBrowserEnv,
						forEach: forEach,
						merge: merge,
						deepMerge: deepMerge,
						extend: extend,
						trim: trim
					};
				},
				{ './helpers/bind': 18, 'is-buffer': 212 }
			],
			28: [
				function(_dereq_, module, exports) {
					_dereq_('../../modules/es.typed-array.from');
					_dereq_('../../modules/es.typed-array.of');
					_dereq_('../../modules/es.typed-array.copy-within');
					_dereq_('../../modules/es.typed-array.every');
					_dereq_('../../modules/es.typed-array.fill');
					_dereq_('../../modules/es.typed-array.filter');
					_dereq_('../../modules/es.typed-array.find');
					_dereq_('../../modules/es.typed-array.find-index');
					_dereq_('../../modules/es.typed-array.for-each');
					_dereq_('../../modules/es.typed-array.includes');
					_dereq_('../../modules/es.typed-array.index-of');
					_dereq_('../../modules/es.typed-array.join');
					_dereq_('../../modules/es.typed-array.last-index-of');
					_dereq_('../../modules/es.typed-array.map');
					_dereq_('../../modules/es.typed-array.reduce');
					_dereq_('../../modules/es.typed-array.reduce-right');
					_dereq_('../../modules/es.typed-array.reverse');
					_dereq_('../../modules/es.typed-array.set');
					_dereq_('../../modules/es.typed-array.slice');
					_dereq_('../../modules/es.typed-array.some');
					_dereq_('../../modules/es.typed-array.sort');
					_dereq_('../../modules/es.typed-array.subarray');
					_dereq_('../../modules/es.typed-array.to-locale-string');
					_dereq_('../../modules/es.typed-array.to-string');
					_dereq_('../../modules/es.typed-array.iterator');
					_dereq_('../../modules/es.object.to-string');
				},
				{
					'../../modules/es.object.to-string': 125,
					'../../modules/es.typed-array.copy-within': 126,
					'../../modules/es.typed-array.every': 127,
					'../../modules/es.typed-array.fill': 128,
					'../../modules/es.typed-array.filter': 129,
					'../../modules/es.typed-array.find': 131,
					'../../modules/es.typed-array.find-index': 130,
					'../../modules/es.typed-array.for-each': 132,
					'../../modules/es.typed-array.from': 133,
					'../../modules/es.typed-array.includes': 134,
					'../../modules/es.typed-array.index-of': 135,
					'../../modules/es.typed-array.iterator': 136,
					'../../modules/es.typed-array.join': 137,
					'../../modules/es.typed-array.last-index-of': 138,
					'../../modules/es.typed-array.map': 139,
					'../../modules/es.typed-array.of': 140,
					'../../modules/es.typed-array.reduce': 142,
					'../../modules/es.typed-array.reduce-right': 141,
					'../../modules/es.typed-array.reverse': 143,
					'../../modules/es.typed-array.set': 144,
					'../../modules/es.typed-array.slice': 145,
					'../../modules/es.typed-array.some': 146,
					'../../modules/es.typed-array.sort': 147,
					'../../modules/es.typed-array.subarray': 148,
					'../../modules/es.typed-array.to-locale-string': 149,
					'../../modules/es.typed-array.to-string': 150
				}
			],
			29: [
				function(_dereq_, module, exports) {
					_dereq_('../../modules/es.typed-array.uint32-array');
					_dereq_('./methods');
					var global = _dereq_('../../internals/global');

					module.exports = global.Uint32Array;
				},
				{
					'../../internals/global': 65,
					'../../modules/es.typed-array.uint32-array': 151,
					'./methods': 28
				}
			],
			30: [
				function(_dereq_, module, exports) {
					_dereq_('../../modules/es.typed-array.reduce');
				},
				{ '../../modules/es.typed-array.reduce': 142 }
			],
			31: [
				function(_dereq_, module, exports) {
					_dereq_('../../modules/es.typed-array.some');
				},
				{ '../../modules/es.typed-array.some': 146 }
			],
			32: [
				function(_dereq_, module, exports) {
					module.exports = _dereq_('../../es/typed-array/uint32-array');
				},
				{ '../../es/typed-array/uint32-array': 29 }
			],
			33: [
				function(_dereq_, module, exports) {
					module.exports = function(it) {
						if (typeof it != 'function') {
							throw TypeError(String(it) + ' is not a function');
						}
						return it;
					};
				},
				{}
			],
			34: [
				function(_dereq_, module, exports) {
					var isObject = _dereq_('../internals/is-object');

					module.exports = function(it) {
						if (!isObject(it) && it !== null) {
							throw TypeError("Can't set " + String(it) + ' as a prototype');
						}
						return it;
					};
				},
				{ '../internals/is-object': 77 }
			],
			35: [
				function(_dereq_, module, exports) {
					var wellKnownSymbol = _dereq_('../internals/well-known-symbol');
					var create = _dereq_('../internals/object-create');
					var createNonEnumerableProperty = _dereq_(
						'../internals/create-non-enumerable-property'
					);

					var UNSCOPABLES = wellKnownSymbol('unscopables');
					var ArrayPrototype = Array.prototype;

					// Array.prototype[@@unscopables]
					// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
					if (ArrayPrototype[UNSCOPABLES] == undefined) {
						createNonEnumerableProperty(
							ArrayPrototype,
							UNSCOPABLES,
							create(null)
						);
					}

					// add a key to Array.prototype[@@unscopables]
					module.exports = function(key) {
						ArrayPrototype[UNSCOPABLES][key] = true;
					};
				},
				{
					'../internals/create-non-enumerable-property': 54,
					'../internals/object-create': 83,
					'../internals/well-known-symbol': 123
				}
			],
			36: [
				function(_dereq_, module, exports) {
					module.exports = function(it, Constructor, name) {
						if (!(it instanceof Constructor)) {
							throw TypeError(
								'Incorrect ' + (name ? name + ' ' : '') + 'invocation'
							);
						}
						return it;
					};
				},
				{}
			],
			37: [
				function(_dereq_, module, exports) {
					var isObject = _dereq_('../internals/is-object');

					module.exports = function(it) {
						if (!isObject(it)) {
							throw TypeError(String(it) + ' is not an object');
						}
						return it;
					};
				},
				{ '../internals/is-object': 77 }
			],
			38: [
				function(_dereq_, module, exports) {
					'use strict';
					var DESCRIPTORS = _dereq_('../internals/descriptors');
					var global = _dereq_('../internals/global');
					var isObject = _dereq_('../internals/is-object');
					var has = _dereq_('../internals/has');
					var classof = _dereq_('../internals/classof');
					var createNonEnumerableProperty = _dereq_(
						'../internals/create-non-enumerable-property'
					);
					var redefine = _dereq_('../internals/redefine');
					var defineProperty = _dereq_('../internals/object-define-property').f;
					var getPrototypeOf = _dereq_('../internals/object-get-prototype-of');
					var setPrototypeOf = _dereq_('../internals/object-set-prototype-of');
					var wellKnownSymbol = _dereq_('../internals/well-known-symbol');
					var uid = _dereq_('../internals/uid');

					var DataView = global.DataView;
					var DataViewPrototype = DataView && DataView.prototype;
					var Int8Array = global.Int8Array;
					var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
					var Uint8ClampedArray = global.Uint8ClampedArray;
					var Uint8ClampedArrayPrototype =
						Uint8ClampedArray && Uint8ClampedArray.prototype;
					var TypedArray = Int8Array && getPrototypeOf(Int8Array);
					var TypedArrayPrototype =
						Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
					var ObjectPrototype = Object.prototype;
					var isPrototypeOf = ObjectPrototype.isPrototypeOf;

					var TO_STRING_TAG = wellKnownSymbol('toStringTag');
					var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
					var NATIVE_ARRAY_BUFFER = !!(global.ArrayBuffer && DataView);
					// Fixing native typed arrays in Opera Presto crashes the browser, see #595
					var NATIVE_ARRAY_BUFFER_VIEWS =
						NATIVE_ARRAY_BUFFER &&
						!!setPrototypeOf &&
						classof(global.opera) !== 'Opera';
					var TYPED_ARRAY_TAG_REQIRED = false;
					var NAME;

					var TypedArrayConstructorsList = {
						Int8Array: 1,
						Uint8Array: 1,
						Uint8ClampedArray: 1,
						Int16Array: 2,
						Uint16Array: 2,
						Int32Array: 4,
						Uint32Array: 4,
						Float32Array: 4,
						Float64Array: 8
					};

					var isView = function isView(it) {
						var klass = classof(it);
						return (
							klass === 'DataView' || has(TypedArrayConstructorsList, klass)
						);
					};

					var isTypedArray = function(it) {
						return isObject(it) && has(TypedArrayConstructorsList, classof(it));
					};

					var aTypedArray = function(it) {
						if (isTypedArray(it)) return it;
						throw TypeError('Target is not a typed array');
					};

					var aTypedArrayConstructor = function(C) {
						if (setPrototypeOf) {
							if (isPrototypeOf.call(TypedArray, C)) return C;
						} else
							for (var ARRAY in TypedArrayConstructorsList)
								if (has(TypedArrayConstructorsList, NAME)) {
									var TypedArrayConstructor = global[ARRAY];
									if (
										TypedArrayConstructor &&
										(C === TypedArrayConstructor ||
											isPrototypeOf.call(TypedArrayConstructor, C))
									) {
										return C;
									}
								}
						throw TypeError('Target is not a typed array constructor');
					};

					var exportProto = function(KEY, property, forced) {
						if (!DESCRIPTORS) return;
						if (forced)
							for (var ARRAY in TypedArrayConstructorsList) {
								var TypedArrayConstructor = global[ARRAY];
								if (
									TypedArrayConstructor &&
									has(TypedArrayConstructor.prototype, KEY)
								) {
									delete TypedArrayConstructor.prototype[KEY];
								}
							}
						if (!TypedArrayPrototype[KEY] || forced) {
							redefine(
								TypedArrayPrototype,
								KEY,
								forced
									? property
									: (NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY]) ||
											property
							);
						}
					};

					var exportStatic = function(KEY, property, forced) {
						var ARRAY, TypedArrayConstructor;
						if (!DESCRIPTORS) return;
						if (setPrototypeOf) {
							if (forced)
								for (ARRAY in TypedArrayConstructorsList) {
									TypedArrayConstructor = global[ARRAY];
									if (
										TypedArrayConstructor &&
										has(TypedArrayConstructor, KEY)
									) {
										delete TypedArrayConstructor[KEY];
									}
								}
							if (!TypedArray[KEY] || forced) {
								// V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
								try {
									return redefine(
										TypedArray,
										KEY,
										forced
											? property
											: (NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY]) ||
													property
									);
								} catch (error) {
									/* empty */
								}
							} else return;
						}
						for (ARRAY in TypedArrayConstructorsList) {
							TypedArrayConstructor = global[ARRAY];
							if (
								TypedArrayConstructor &&
								(!TypedArrayConstructor[KEY] || forced)
							) {
								redefine(TypedArrayConstructor, KEY, property);
							}
						}
					};

					for (NAME in TypedArrayConstructorsList) {
						if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
					}

					// WebKit bug - typed arrays constructors prototype is Object.prototype
					if (
						!NATIVE_ARRAY_BUFFER_VIEWS ||
						typeof TypedArray != 'function' ||
						TypedArray === Function.prototype
					) {
						// eslint-disable-next-line no-shadow
						TypedArray = function TypedArray() {
							throw TypeError('Incorrect invocation');
						};
						if (NATIVE_ARRAY_BUFFER_VIEWS)
							for (NAME in TypedArrayConstructorsList) {
								if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
							}
					}

					if (
						!NATIVE_ARRAY_BUFFER_VIEWS ||
						!TypedArrayPrototype ||
						TypedArrayPrototype === ObjectPrototype
					) {
						TypedArrayPrototype = TypedArray.prototype;
						if (NATIVE_ARRAY_BUFFER_VIEWS)
							for (NAME in TypedArrayConstructorsList) {
								if (global[NAME])
									setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
							}
					}

					// WebKit bug - one more object in Uint8ClampedArray prototype chain
					if (
						NATIVE_ARRAY_BUFFER_VIEWS &&
						getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype
					) {
						setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
					}

					if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
						TYPED_ARRAY_TAG_REQIRED = true;
						defineProperty(TypedArrayPrototype, TO_STRING_TAG, {
							get: function() {
								return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
							}
						});
						for (NAME in TypedArrayConstructorsList)
							if (global[NAME]) {
								createNonEnumerableProperty(
									global[NAME],
									TYPED_ARRAY_TAG,
									NAME
								);
							}
					}

					// WebKit bug - the same parent prototype for typed arrays and data view
					if (
						NATIVE_ARRAY_BUFFER &&
						setPrototypeOf &&
						getPrototypeOf(DataViewPrototype) !== ObjectPrototype
					) {
						setPrototypeOf(DataViewPrototype, ObjectPrototype);
					}

					module.exports = {
						NATIVE_ARRAY_BUFFER: NATIVE_ARRAY_BUFFER,
						NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
						TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
						aTypedArray: aTypedArray,
						aTypedArrayConstructor: aTypedArrayConstructor,
						exportProto: exportProto,
						exportStatic: exportStatic,
						isView: isView,
						isTypedArray: isTypedArray,
						TypedArray: TypedArray,
						TypedArrayPrototype: TypedArrayPrototype
					};
				},
				{
					'../internals/classof': 50,
					'../internals/create-non-enumerable-property': 54,
					'../internals/descriptors': 57,
					'../internals/global': 65,
					'../internals/has': 66,
					'../internals/is-object': 77,
					'../internals/object-define-property': 85,
					'../internals/object-get-prototype-of': 89,
					'../internals/object-set-prototype-of': 93,
					'../internals/redefine': 98,
					'../internals/uid': 121,
					'../internals/well-known-symbol': 123
				}
			],
			39: [
				function(_dereq_, module, exports) {
					'use strict';
					var global = _dereq_('../internals/global');
					var DESCRIPTORS = _dereq_('../internals/descriptors');
					var NATIVE_ARRAY_BUFFER = _dereq_(
						'../internals/array-buffer-view-core'
					).NATIVE_ARRAY_BUFFER;
					var createNonEnumerableProperty = _dereq_(
						'../internals/create-non-enumerable-property'
					);
					var redefineAll = _dereq_('../internals/redefine-all');
					var fails = _dereq_('../internals/fails');
					var anInstance = _dereq_('../internals/an-instance');
					var toInteger = _dereq_('../internals/to-integer');
					var toLength = _dereq_('../internals/to-length');
					var toIndex = _dereq_('../internals/to-index');
					var IEEE754 = _dereq_('../internals/ieee754');
					var getOwnPropertyNames = _dereq_(
						'../internals/object-get-own-property-names'
					).f;
					var defineProperty = _dereq_('../internals/object-define-property').f;
					var arrayFill = _dereq_('../internals/array-fill');
					var setToStringTag = _dereq_('../internals/set-to-string-tag');
					var InternalStateModule = _dereq_('../internals/internal-state');

					var getInternalState = InternalStateModule.get;
					var setInternalState = InternalStateModule.set;
					var ARRAY_BUFFER = 'ArrayBuffer';
					var DATA_VIEW = 'DataView';
					var PROTOTYPE = 'prototype';
					var WRONG_LENGTH = 'Wrong length';
					var WRONG_INDEX = 'Wrong index';
					var NativeArrayBuffer = global[ARRAY_BUFFER];
					var $ArrayBuffer = NativeArrayBuffer;
					var $DataView = global[DATA_VIEW];
					var RangeError = global.RangeError;

					var packIEEE754 = IEEE754.pack;
					var unpackIEEE754 = IEEE754.unpack;

					var packInt8 = function(number) {
						return [number & 0xff];
					};

					var packInt16 = function(number) {
						return [number & 0xff, (number >> 8) & 0xff];
					};

					var packInt32 = function(number) {
						return [
							number & 0xff,
							(number >> 8) & 0xff,
							(number >> 16) & 0xff,
							(number >> 24) & 0xff
						];
					};

					var unpackInt32 = function(buffer) {
						return (
							(buffer[3] << 24) |
							(buffer[2] << 16) |
							(buffer[1] << 8) |
							buffer[0]
						);
					};

					var packFloat32 = function(number) {
						return packIEEE754(number, 23, 4);
					};

					var packFloat64 = function(number) {
						return packIEEE754(number, 52, 8);
					};

					var addGetter = function(Constructor, key) {
						defineProperty(Constructor[PROTOTYPE], key, {
							get: function() {
								return getInternalState(this)[key];
							}
						});
					};

					var get = function(view, count, index, isLittleEndian) {
						var intIndex = toIndex(index);
						var store = getInternalState(view);
						if (intIndex + count > store.byteLength)
							throw RangeError(WRONG_INDEX);
						var bytes = getInternalState(store.buffer).bytes;
						var start = intIndex + store.byteOffset;
						var pack = bytes.slice(start, start + count);
						return isLittleEndian ? pack : pack.reverse();
					};

					var set = function(
						view,
						count,
						index,
						conversion,
						value,
						isLittleEndian
					) {
						var intIndex = toIndex(index);
						var store = getInternalState(view);
						if (intIndex + count > store.byteLength)
							throw RangeError(WRONG_INDEX);
						var bytes = getInternalState(store.buffer).bytes;
						var start = intIndex + store.byteOffset;
						var pack = conversion(+value);
						for (var i = 0; i < count; i++)
							bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
					};

					if (!NATIVE_ARRAY_BUFFER) {
						$ArrayBuffer = function ArrayBuffer(length) {
							anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
							var byteLength = toIndex(length);
							setInternalState(this, {
								bytes: arrayFill.call(new Array(byteLength), 0),
								byteLength: byteLength
							});
							if (!DESCRIPTORS) this.byteLength = byteLength;
						};

						$DataView = function DataView(buffer, byteOffset, byteLength) {
							anInstance(this, $DataView, DATA_VIEW);
							anInstance(buffer, $ArrayBuffer, DATA_VIEW);
							var bufferLength = getInternalState(buffer).byteLength;
							var offset = toInteger(byteOffset);
							if (offset < 0 || offset > bufferLength)
								throw RangeError('Wrong offset');
							byteLength =
								byteLength === undefined
									? bufferLength - offset
									: toLength(byteLength);
							if (offset + byteLength > bufferLength)
								throw RangeError(WRONG_LENGTH);
							setInternalState(this, {
								buffer: buffer,
								byteLength: byteLength,
								byteOffset: offset
							});
							if (!DESCRIPTORS) {
								this.buffer = buffer;
								this.byteLength = byteLength;
								this.byteOffset = offset;
							}
						};

						if (DESCRIPTORS) {
							addGetter($ArrayBuffer, 'byteLength');
							addGetter($DataView, 'buffer');
							addGetter($DataView, 'byteLength');
							addGetter($DataView, 'byteOffset');
						}

						redefineAll($DataView[PROTOTYPE], {
							getInt8: function getInt8(byteOffset) {
								return (get(this, 1, byteOffset)[0] << 24) >> 24;
							},
							getUint8: function getUint8(byteOffset) {
								return get(this, 1, byteOffset)[0];
							},
							getInt16: function getInt16(byteOffset /* , littleEndian */) {
								var bytes = get(
									this,
									2,
									byteOffset,
									arguments.length > 1 ? arguments[1] : undefined
								);
								return (((bytes[1] << 8) | bytes[0]) << 16) >> 16;
							},
							getUint16: function getUint16(byteOffset /* , littleEndian */) {
								var bytes = get(
									this,
									2,
									byteOffset,
									arguments.length > 1 ? arguments[1] : undefined
								);
								return (bytes[1] << 8) | bytes[0];
							},
							getInt32: function getInt32(byteOffset /* , littleEndian */) {
								return unpackInt32(
									get(
										this,
										4,
										byteOffset,
										arguments.length > 1 ? arguments[1] : undefined
									)
								);
							},
							getUint32: function getUint32(byteOffset /* , littleEndian */) {
								return (
									unpackInt32(
										get(
											this,
											4,
											byteOffset,
											arguments.length > 1 ? arguments[1] : undefined
										)
									) >>> 0
								);
							},
							getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
								return unpackIEEE754(
									get(
										this,
										4,
										byteOffset,
										arguments.length > 1 ? arguments[1] : undefined
									),
									23
								);
							},
							getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
								return unpackIEEE754(
									get(
										this,
										8,
										byteOffset,
										arguments.length > 1 ? arguments[1] : undefined
									),
									52
								);
							},
							setInt8: function setInt8(byteOffset, value) {
								set(this, 1, byteOffset, packInt8, value);
							},
							setUint8: function setUint8(byteOffset, value) {
								set(this, 1, byteOffset, packInt8, value);
							},
							setInt16: function setInt16(
								byteOffset,
								value /* , littleEndian */
							) {
								set(
									this,
									2,
									byteOffset,
									packInt16,
									value,
									arguments.length > 2 ? arguments[2] : undefined
								);
							},
							setUint16: function setUint16(
								byteOffset,
								value /* , littleEndian */
							) {
								set(
									this,
									2,
									byteOffset,
									packInt16,
									value,
									arguments.length > 2 ? arguments[2] : undefined
								);
							},
							setInt32: function setInt32(
								byteOffset,
								value /* , littleEndian */
							) {
								set(
									this,
									4,
									byteOffset,
									packInt32,
									value,
									arguments.length > 2 ? arguments[2] : undefined
								);
							},
							setUint32: function setUint32(
								byteOffset,
								value /* , littleEndian */
							) {
								set(
									this,
									4,
									byteOffset,
									packInt32,
									value,
									arguments.length > 2 ? arguments[2] : undefined
								);
							},
							setFloat32: function setFloat32(
								byteOffset,
								value /* , littleEndian */
							) {
								set(
									this,
									4,
									byteOffset,
									packFloat32,
									value,
									arguments.length > 2 ? arguments[2] : undefined
								);
							},
							setFloat64: function setFloat64(
								byteOffset,
								value /* , littleEndian */
							) {
								set(
									this,
									8,
									byteOffset,
									packFloat64,
									value,
									arguments.length > 2 ? arguments[2] : undefined
								);
							}
						});
					} else {
						if (
							!fails(function() {
								NativeArrayBuffer(1);
							}) ||
							!fails(function() {
								new NativeArrayBuffer(-1); // eslint-disable-line no-new
							}) ||
							fails(function() {
								new NativeArrayBuffer(); // eslint-disable-line no-new
								new NativeArrayBuffer(1.5); // eslint-disable-line no-new
								new NativeArrayBuffer(NaN); // eslint-disable-line no-new
								return NativeArrayBuffer.name != ARRAY_BUFFER;
							})
						) {
							$ArrayBuffer = function ArrayBuffer(length) {
								anInstance(this, $ArrayBuffer);
								return new NativeArrayBuffer(toIndex(length));
							};
							var ArrayBufferPrototype = ($ArrayBuffer[PROTOTYPE] =
								NativeArrayBuffer[PROTOTYPE]);
							for (
								var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key;
								keys.length > j;

							) {
								if (!((key = keys[j++]) in $ArrayBuffer)) {
									createNonEnumerableProperty(
										$ArrayBuffer,
										key,
										NativeArrayBuffer[key]
									);
								}
							}
							ArrayBufferPrototype.constructor = $ArrayBuffer;
						}
						// iOS Safari 7.x bug
						var testView = new $DataView(new $ArrayBuffer(2));
						var nativeSetInt8 = $DataView[PROTOTYPE].setInt8;
						testView.setInt8(0, 2147483648);
						testView.setInt8(1, 2147483649);
						if (testView.getInt8(0) || !testView.getInt8(1))
							redefineAll(
								$DataView[PROTOTYPE],
								{
									setInt8: function setInt8(byteOffset, value) {
										nativeSetInt8.call(this, byteOffset, (value << 24) >> 24);
									},
									setUint8: function setUint8(byteOffset, value) {
										nativeSetInt8.call(this, byteOffset, (value << 24) >> 24);
									}
								},
								{ unsafe: true }
							);
					}

					setToStringTag($ArrayBuffer, ARRAY_BUFFER);
					setToStringTag($DataView, DATA_VIEW);

					module.exports = {
						ArrayBuffer: $ArrayBuffer,
						DataView: $DataView
					};
				},
				{
					'../internals/an-instance': 36,
					'../internals/array-buffer-view-core': 38,
					'../internals/array-fill': 41,
					'../internals/create-non-enumerable-property': 54,
					'../internals/descriptors': 57,
					'../internals/fails': 61,
					'../internals/global': 65,
					'../internals/ieee754': 70,
					'../internals/internal-state': 73,
					'../internals/object-define-property': 85,
					'../internals/object-get-own-property-names': 87,
					'../internals/redefine-all': 97,
					'../internals/set-to-string-tag': 102,
					'../internals/to-index': 109,
					'../internals/to-integer': 111,
					'../internals/to-length': 112
				}
			],
			40: [
				function(_dereq_, module, exports) {
					'use strict';
					var toObject = _dereq_('../internals/to-object');
					var toAbsoluteIndex = _dereq_('../internals/to-absolute-index');
					var toLength = _dereq_('../internals/to-length');

					var min = Math.min;

					// `Array.prototype.copyWithin` method implementation
					// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
					module.exports =
						[].copyWithin ||
						function copyWithin(
							target /* = 0 */,
							start /* = 0, end = @length */
						) {
							var O = toObject(this);
							var len = toLength(O.length);
							var to = toAbsoluteIndex(target, len);
							var from = toAbsoluteIndex(start, len);
							var end = arguments.length > 2 ? arguments[2] : undefined;
							var count = min(
								(end === undefined ? len : toAbsoluteIndex(end, len)) - from,
								len - to
							);
							var inc = 1;
							if (from < to && to < from + count) {
								inc = -1;
								from += count - 1;
								to += count - 1;
							}
							while (count-- > 0) {
								if (from in O) O[to] = O[from];
								else delete O[to];
								to += inc;
								from += inc;
							}
							return O;
						};
				},
				{
					'../internals/to-absolute-index': 108,
					'../internals/to-length': 112,
					'../internals/to-object': 113
				}
			],
			41: [
				function(_dereq_, module, exports) {
					'use strict';
					var toObject = _dereq_('../internals/to-object');
					var toAbsoluteIndex = _dereq_('../internals/to-absolute-index');
					var toLength = _dereq_('../internals/to-length');

					// `Array.prototype.fill` method implementation
					// https://tc39.github.io/ecma262/#sec-array.prototype.fill
					module.exports = function fill(
						value /* , start = 0, end = @length */
					) {
						var O = toObject(this);
						var length = toLength(O.length);
						var argumentsLength = arguments.length;
						var index = toAbsoluteIndex(
							argumentsLength > 1 ? arguments[1] : undefined,
							length
						);
						var end = argumentsLength > 2 ? arguments[2] : undefined;
						var endPos =
							end === undefined ? length : toAbsoluteIndex(end, length);
						while (endPos > index) O[index++] = value;
						return O;
					};
				},
				{
					'../internals/to-absolute-index': 108,
					'../internals/to-length': 112,
					'../internals/to-object': 113
				}
			],
			42: [
				function(_dereq_, module, exports) {
					var toIndexedObject = _dereq_('../internals/to-indexed-object');
					var toLength = _dereq_('../internals/to-length');
					var toAbsoluteIndex = _dereq_('../internals/to-absolute-index');

					// `Array.prototype.{ indexOf, includes }` methods implementation
					var createMethod = function(IS_INCLUDES) {
						return function($this, el, fromIndex) {
							var O = toIndexedObject($this);
							var length = toLength(O.length);
							var index = toAbsoluteIndex(fromIndex, length);
							var value;
							// Array#includes uses SameValueZero equality algorithm
							// eslint-disable-next-line no-self-compare
							if (IS_INCLUDES && el != el)
								while (length > index) {
									value = O[index++];
									// eslint-disable-next-line no-self-compare
									if (value != value) return true;
									// Array#indexOf ignores holes, Array#includes - not
								}
							else
								for (; length > index; index++) {
									if ((IS_INCLUDES || index in O) && O[index] === el)
										return IS_INCLUDES || index || 0;
								}
							return !IS_INCLUDES && -1;
						};
					};

					module.exports = {
						// `Array.prototype.includes` method
						// https://tc39.github.io/ecma262/#sec-array.prototype.includes
						includes: createMethod(true),
						// `Array.prototype.indexOf` method
						// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
						indexOf: createMethod(false)
					};
				},
				{
					'../internals/to-absolute-index': 108,
					'../internals/to-indexed-object': 110,
					'../internals/to-length': 112
				}
			],
			43: [
				function(_dereq_, module, exports) {
					var bind = _dereq_('../internals/bind-context');
					var IndexedObject = _dereq_('../internals/indexed-object');
					var toObject = _dereq_('../internals/to-object');
					var toLength = _dereq_('../internals/to-length');
					var arraySpeciesCreate = _dereq_('../internals/array-species-create');

					var push = [].push;

					// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
					var createMethod = function(TYPE) {
						var IS_MAP = TYPE == 1;
						var IS_FILTER = TYPE == 2;
						var IS_SOME = TYPE == 3;
						var IS_EVERY = TYPE == 4;
						var IS_FIND_INDEX = TYPE == 6;
						var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
						return function($this, callbackfn, that, specificCreate) {
							var O = toObject($this);
							var self = IndexedObject(O);
							var boundFunction = bind(callbackfn, that, 3);
							var length = toLength(self.length);
							var index = 0;
							var create = specificCreate || arraySpeciesCreate;
							var target = IS_MAP
								? create($this, length)
								: IS_FILTER
								? create($this, 0)
								: undefined;
							var value, result;
							for (; length > index; index++)
								if (NO_HOLES || index in self) {
									value = self[index];
									result = boundFunction(value, index, O);
									if (TYPE) {
										if (IS_MAP) target[index] = result;
										// map
										else if (result)
											switch (TYPE) {
												case 3:
													return true; // some
												case 5:
													return value; // find
												case 6:
													return index; // findIndex
												case 2:
													push.call(target, value); // filter
											}
										else if (IS_EVERY) return false; // every
									}
								}
							return IS_FIND_INDEX
								? -1
								: IS_SOME || IS_EVERY
								? IS_EVERY
								: target;
						};
					};

					module.exports = {
						// `Array.prototype.forEach` method
						// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
						forEach: createMethod(0),
						// `Array.prototype.map` method
						// https://tc39.github.io/ecma262/#sec-array.prototype.map
						map: createMethod(1),
						// `Array.prototype.filter` method
						// https://tc39.github.io/ecma262/#sec-array.prototype.filter
						filter: createMethod(2),
						// `Array.prototype.some` method
						// https://tc39.github.io/ecma262/#sec-array.prototype.some
						some: createMethod(3),
						// `Array.prototype.every` method
						// https://tc39.github.io/ecma262/#sec-array.prototype.every
						every: createMethod(4),
						// `Array.prototype.find` method
						// https://tc39.github.io/ecma262/#sec-array.prototype.find
						find: createMethod(5),
						// `Array.prototype.findIndex` method
						// https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
						findIndex: createMethod(6)
					};
				},
				{
					'../internals/array-species-create': 46,
					'../internals/bind-context': 47,
					'../internals/indexed-object': 71,
					'../internals/to-length': 112,
					'../internals/to-object': 113
				}
			],
			44: [
				function(_dereq_, module, exports) {
					'use strict';
					var toIndexedObject = _dereq_('../internals/to-indexed-object');
					var toInteger = _dereq_('../internals/to-integer');
					var toLength = _dereq_('../internals/to-length');
					var sloppyArrayMethod = _dereq_('../internals/sloppy-array-method');

					var min = Math.min;
					var nativeLastIndexOf = [].lastIndexOf;
					var NEGATIVE_ZERO =
						!!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
					var SLOPPY_METHOD = sloppyArrayMethod('lastIndexOf');

					// `Array.prototype.lastIndexOf` method implementation
					// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
					module.exports =
						NEGATIVE_ZERO || SLOPPY_METHOD
							? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
									// convert -0 to +0
									if (NEGATIVE_ZERO)
										return nativeLastIndexOf.apply(this, arguments) || 0;
									var O = toIndexedObject(this);
									var length = toLength(O.length);
									var index = length - 1;
									if (arguments.length > 1)
										index = min(index, toInteger(arguments[1]));
									if (index < 0) index = length + index;
									for (; index >= 0; index--)
										if (index in O && O[index] === searchElement)
											return index || 0;
									return -1;
							  }
							: nativeLastIndexOf;
				},
				{
					'../internals/sloppy-array-method': 106,
					'../internals/to-indexed-object': 110,
					'../internals/to-integer': 111,
					'../internals/to-length': 112
				}
			],
			45: [
				function(_dereq_, module, exports) {
					var aFunction = _dereq_('../internals/a-function');
					var toObject = _dereq_('../internals/to-object');
					var IndexedObject = _dereq_('../internals/indexed-object');
					var toLength = _dereq_('../internals/to-length');

					// `Array.prototype.{ reduce, reduceRight }` methods implementation
					var createMethod = function(IS_RIGHT) {
						return function(that, callbackfn, argumentsLength, memo) {
							aFunction(callbackfn);
							var O = toObject(that);
							var self = IndexedObject(O);
							var length = toLength(O.length);
							var index = IS_RIGHT ? length - 1 : 0;
							var i = IS_RIGHT ? -1 : 1;
							if (argumentsLength < 2)
								while (true) {
									if (index in self) {
										memo = self[index];
										index += i;
										break;
									}
									index += i;
									if (IS_RIGHT ? index < 0 : length <= index) {
										throw TypeError(
											'Reduce of empty array with no initial value'
										);
									}
								}
							for (; IS_RIGHT ? index >= 0 : length > index; index += i)
								if (index in self) {
									memo = callbackfn(memo, self[index], index, O);
								}
							return memo;
						};
					};

					module.exports = {
						// `Array.prototype.reduce` method
						// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
						left: createMethod(false),
						// `Array.prototype.reduceRight` method
						// https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
						right: createMethod(true)
					};
				},
				{
					'../internals/a-function': 33,
					'../internals/indexed-object': 71,
					'../internals/to-length': 112,
					'../internals/to-object': 113
				}
			],
			46: [
				function(_dereq_, module, exports) {
					var isObject = _dereq_('../internals/is-object');
					var isArray = _dereq_('../internals/is-array');
					var wellKnownSymbol = _dereq_('../internals/well-known-symbol');

					var SPECIES = wellKnownSymbol('species');

					// `ArraySpeciesCreate` abstract operation
					// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
					module.exports = function(originalArray, length) {
						var C;
						if (isArray(originalArray)) {
							C = originalArray.constructor;
							// cross-realm fallback
							if (
								typeof C == 'function' &&
								(C === Array || isArray(C.prototype))
							)
								C = undefined;
							else if (isObject(C)) {
								C = C[SPECIES];
								if (C === null) C = undefined;
							}
						}
						return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
					};
				},
				{
					'../internals/is-array': 75,
					'../internals/is-object': 77,
					'../internals/well-known-symbol': 123
				}
			],
			47: [
				function(_dereq_, module, exports) {
					var aFunction = _dereq_('../internals/a-function');

					// optional / simple context binding
					module.exports = function(fn, that, length) {
						aFunction(fn);
						if (that === undefined) return fn;
						switch (length) {
							case 0:
								return function() {
									return fn.call(that);
								};
							case 1:
								return function(a) {
									return fn.call(that, a);
								};
							case 2:
								return function(a, b) {
									return fn.call(that, a, b);
								};
							case 3:
								return function(a, b, c) {
									return fn.call(that, a, b, c);
								};
						}
						return function(/* ...args */) {
							return fn.apply(that, arguments);
						};
					};
				},
				{ '../internals/a-function': 33 }
			],
			48: [
				function(_dereq_, module, exports) {
					var wellKnownSymbol = _dereq_('../internals/well-known-symbol');

					var ITERATOR = wellKnownSymbol('iterator');
					var SAFE_CLOSING = false;

					try {
						var called = 0;
						var iteratorWithReturn = {
							next: function() {
								return { done: !!called++ };
							},
							return: function() {
								SAFE_CLOSING = true;
							}
						};
						iteratorWithReturn[ITERATOR] = function() {
							return this;
						};
						// eslint-disable-next-line no-throw-literal
						Array.from(iteratorWithReturn, function() {
							throw 2;
						});
					} catch (error) {
						/* empty */
					}

					module.exports = function(exec, SKIP_CLOSING) {
						if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
						var ITERATION_SUPPORT = false;
						try {
							var object = {};
							object[ITERATOR] = function() {
								return {
									next: function() {
										return { done: (ITERATION_SUPPORT = true) };
									}
								};
							};
							exec(object);
						} catch (error) {
							/* empty */
						}
						return ITERATION_SUPPORT;
					};
				},
				{ '../internals/well-known-symbol': 123 }
			],
			49: [
				function(_dereq_, module, exports) {
					var toString = {}.toString;

					module.exports = function(it) {
						return toString.call(it).slice(8, -1);
					};
				},
				{}
			],
			50: [
				function(_dereq_, module, exports) {
					var TO_STRING_TAG_SUPPORT = _dereq_(
						'../internals/to-string-tag-support'
					);
					var classofRaw = _dereq_('../internals/classof-raw');
					var wellKnownSymbol = _dereq_('../internals/well-known-symbol');

					var TO_STRING_TAG = wellKnownSymbol('toStringTag');
					// ES3 wrong here
					var CORRECT_ARGUMENTS =
						classofRaw(
							(function() {
								return arguments;
							})()
						) == 'Arguments';

					// fallback for IE11 Script Access Denied error
					var tryGet = function(it, key) {
						try {
							return it[key];
						} catch (error) {
							/* empty */
						}
					};

					// getting tag from ES6+ `Object.prototype.toString`
					module.exports = TO_STRING_TAG_SUPPORT
						? classofRaw
						: function(it) {
								var O, tag, result;
								return it === undefined
									? 'Undefined'
									: it === null
									? 'Null'
									: // @@toStringTag case
									typeof (tag = tryGet((O = Object(it)), TO_STRING_TAG)) ==
									  'string'
									? tag
									: // builtinTag case
									CORRECT_ARGUMENTS
									? classofRaw(O)
									: // ES3 arguments fallback
									(result = classofRaw(O)) == 'Object' &&
									  typeof O.callee == 'function'
									? 'Arguments'
									: result;
						  };
				},
				{
					'../internals/classof-raw': 49,
					'../internals/to-string-tag-support': 117,
					'../internals/well-known-symbol': 123
				}
			],
			51: [
				function(_dereq_, module, exports) {
					var has = _dereq_('../internals/has');
					var ownKeys = _dereq_('../internals/own-keys');
					var getOwnPropertyDescriptorModule = _dereq_(
						'../internals/object-get-own-property-descriptor'
					);
					var definePropertyModule = _dereq_(
						'../internals/object-define-property'
					);

					module.exports = function(target, source) {
						var keys = ownKeys(source);
						var defineProperty = definePropertyModule.f;
						var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
						for (var i = 0; i < keys.length; i++) {
							var key = keys[i];
							if (!has(target, key))
								defineProperty(
									target,
									key,
									getOwnPropertyDescriptor(source, key)
								);
						}
					};
				},
				{
					'../internals/has': 66,
					'../internals/object-define-property': 85,
					'../internals/object-get-own-property-descriptor': 86,
					'../internals/own-keys': 95
				}
			],
			52: [
				function(_dereq_, module, exports) {
					var fails = _dereq_('../internals/fails');

					module.exports = !fails(function() {
						function F() {
							/* empty */
						}
						F.prototype.constructor = null;
						return Object.getPrototypeOf(new F()) !== F.prototype;
					});
				},
				{ '../internals/fails': 61 }
			],
			53: [
				function(_dereq_, module, exports) {
					'use strict';
					var IteratorPrototype = _dereq_('../internals/iterators-core')
						.IteratorPrototype;
					var create = _dereq_('../internals/object-create');
					var createPropertyDescriptor = _dereq_(
						'../internals/create-property-descriptor'
					);
					var setToStringTag = _dereq_('../internals/set-to-string-tag');
					var Iterators = _dereq_('../internals/iterators');

					var returnThis = function() {
						return this;
					};

					module.exports = function(IteratorConstructor, NAME, next) {
						var TO_STRING_TAG = NAME + ' Iterator';
						IteratorConstructor.prototype = create(IteratorPrototype, {
							next: createPropertyDescriptor(1, next)
						});
						setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
						Iterators[TO_STRING_TAG] = returnThis;
						return IteratorConstructor;
					};
				},
				{
					'../internals/create-property-descriptor': 55,
					'../internals/iterators': 80,
					'../internals/iterators-core': 79,
					'../internals/object-create': 83,
					'../internals/set-to-string-tag': 102
				}
			],
			54: [
				function(_dereq_, module, exports) {
					var DESCRIPTORS = _dereq_('../internals/descriptors');
					var definePropertyModule = _dereq_(
						'../internals/object-define-property'
					);
					var createPropertyDescriptor = _dereq_(
						'../internals/create-property-descriptor'
					);

					module.exports = DESCRIPTORS
						? function(object, key, value) {
								return definePropertyModule.f(
									object,
									key,
									createPropertyDescriptor(1, value)
								);
						  }
						: function(object, key, value) {
								object[key] = value;
								return object;
						  };
				},
				{
					'../internals/create-property-descriptor': 55,
					'../internals/descriptors': 57,
					'../internals/object-define-property': 85
				}
			],
			55: [
				function(_dereq_, module, exports) {
					module.exports = function(bitmap, value) {
						return {
							enumerable: !(bitmap & 1),
							configurable: !(bitmap & 2),
							writable: !(bitmap & 4),
							value: value
						};
					};
				},
				{}
			],
			56: [
				function(_dereq_, module, exports) {
					'use strict';
					var $ = _dereq_('../internals/export');
					var createIteratorConstructor = _dereq_(
						'../internals/create-iterator-constructor'
					);
					var getPrototypeOf = _dereq_('../internals/object-get-prototype-of');
					var setPrototypeOf = _dereq_('../internals/object-set-prototype-of');
					var setToStringTag = _dereq_('../internals/set-to-string-tag');
					var createNonEnumerableProperty = _dereq_(
						'../internals/create-non-enumerable-property'
					);
					var redefine = _dereq_('../internals/redefine');
					var wellKnownSymbol = _dereq_('../internals/well-known-symbol');
					var IS_PURE = _dereq_('../internals/is-pure');
					var Iterators = _dereq_('../internals/iterators');
					var IteratorsCore = _dereq_('../internals/iterators-core');

					var IteratorPrototype = IteratorsCore.IteratorPrototype;
					var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
					var ITERATOR = wellKnownSymbol('iterator');
					var KEYS = 'keys';
					var VALUES = 'values';
					var ENTRIES = 'entries';

					var returnThis = function() {
						return this;
					};

					module.exports = function(
						Iterable,
						NAME,
						IteratorConstructor,
						next,
						DEFAULT,
						IS_SET,
						FORCED
					) {
						createIteratorConstructor(IteratorConstructor, NAME, next);

						var getIterationMethod = function(KIND) {
							if (KIND === DEFAULT && defaultIterator) return defaultIterator;
							if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
								return IterablePrototype[KIND];
							switch (KIND) {
								case KEYS:
									return function keys() {
										return new IteratorConstructor(this, KIND);
									};
								case VALUES:
									return function values() {
										return new IteratorConstructor(this, KIND);
									};
								case ENTRIES:
									return function entries() {
										return new IteratorConstructor(this, KIND);
									};
							}
							return function() {
								return new IteratorConstructor(this);
							};
						};

						var TO_STRING_TAG = NAME + ' Iterator';
						var INCORRECT_VALUES_NAME = false;
						var IterablePrototype = Iterable.prototype;
						var nativeIterator =
							IterablePrototype[ITERATOR] ||
							IterablePrototype['@@iterator'] ||
							(DEFAULT && IterablePrototype[DEFAULT]);
						var defaultIterator =
							(!BUGGY_SAFARI_ITERATORS && nativeIterator) ||
							getIterationMethod(DEFAULT);
						var anyNativeIterator =
							NAME == 'Array'
								? IterablePrototype.entries || nativeIterator
								: nativeIterator;
						var CurrentIteratorPrototype, methods, KEY;

						// fix native
						if (anyNativeIterator) {
							CurrentIteratorPrototype = getPrototypeOf(
								anyNativeIterator.call(new Iterable())
							);
							if (
								IteratorPrototype !== Object.prototype &&
								CurrentIteratorPrototype.next
							) {
								if (
									!IS_PURE &&
									getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype
								) {
									if (setPrototypeOf) {
										setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
									} else if (
										typeof CurrentIteratorPrototype[ITERATOR] != 'function'
									) {
										createNonEnumerableProperty(
											CurrentIteratorPrototype,
											ITERATOR,
											returnThis
										);
									}
								}
								// Set @@toStringTag to native iterators
								setToStringTag(
									CurrentIteratorPrototype,
									TO_STRING_TAG,
									true,
									true
								);
								if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
							}
						}

						// fix Array#{values, @@iterator}.name in V8 / FF
						if (
							DEFAULT == VALUES &&
							nativeIterator &&
							nativeIterator.name !== VALUES
						) {
							INCORRECT_VALUES_NAME = true;
							defaultIterator = function values() {
								return nativeIterator.call(this);
							};
						}

						// define iterator
						if (
							(!IS_PURE || FORCED) &&
							IterablePrototype[ITERATOR] !== defaultIterator
						) {
							createNonEnumerableProperty(
								IterablePrototype,
								ITERATOR,
								defaultIterator
							);
						}
						Iterators[NAME] = defaultIterator;

						// export additional methods
						if (DEFAULT) {
							methods = {
								values: getIterationMethod(VALUES),
								keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
								entries: getIterationMethod(ENTRIES)
							};
							if (FORCED)
								for (KEY in methods) {
									if (
										BUGGY_SAFARI_ITERATORS ||
										INCORRECT_VALUES_NAME ||
										!(KEY in IterablePrototype)
									) {
										redefine(IterablePrototype, KEY, methods[KEY]);
									}
								}
							else
								$(
									{
										target: NAME,
										proto: true,
										forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
									},
									methods
								);
						}

						return methods;
					};
				},
				{
					'../internals/create-iterator-constructor': 53,
					'../internals/create-non-enumerable-property': 54,
					'../internals/export': 60,
					'../internals/is-pure': 78,
					'../internals/iterators': 80,
					'../internals/iterators-core': 79,
					'../internals/object-get-prototype-of': 89,
					'../internals/object-set-prototype-of': 93,
					'../internals/redefine': 98,
					'../internals/set-to-string-tag': 102,
					'../internals/well-known-symbol': 123
				}
			],
			57: [
				function(_dereq_, module, exports) {
					var fails = _dereq_('../internals/fails');

					// Thank's IE8 for his funny defineProperty
					module.exports = !fails(function() {
						return (
							Object.defineProperty({}, 'a', {
								get: function() {
									return 7;
								}
							}).a != 7
						);
					});
				},
				{ '../internals/fails': 61 }
			],
			58: [
				function(_dereq_, module, exports) {
					var global = _dereq_('../internals/global');
					var isObject = _dereq_('../internals/is-object');

					var document = global.document;
					// typeof document.createElement is 'object' in old IE
					var EXISTS = isObject(document) && isObject(document.createElement);

					module.exports = function(it) {
						return EXISTS ? document.createElement(it) : {};
					};
				},
				{ '../internals/global': 65, '../internals/is-object': 77 }
			],
			59: [
				function(_dereq_, module, exports) {
					// IE8- don't enum bug keys
					module.exports = [
						'constructor',
						'hasOwnProperty',
						'isPrototypeOf',
						'propertyIsEnumerable',
						'toLocaleString',
						'toString',
						'valueOf'
					];
				},
				{}
			],
			60: [
				function(_dereq_, module, exports) {
					var global = _dereq_('../internals/global');
					var getOwnPropertyDescriptor = _dereq_(
						'../internals/object-get-own-property-descriptor'
					).f;
					var createNonEnumerableProperty = _dereq_(
						'../internals/create-non-enumerable-property'
					);
					var redefine = _dereq_('../internals/redefine');
					var setGlobal = _dereq_('../internals/set-global');
					var copyConstructorProperties = _dereq_(
						'../internals/copy-constructor-properties'
					);
					var isForced = _dereq_('../internals/is-forced');

					/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
					module.exports = function(options, source) {
						var TARGET = options.target;
						var GLOBAL = options.global;
						var STATIC = options.stat;
						var FORCED, target, key, targetProperty, sourceProperty, descriptor;
						if (GLOBAL) {
							target = global;
						} else if (STATIC) {
							target = global[TARGET] || setGlobal(TARGET, {});
						} else {
							target = (global[TARGET] || {}).prototype;
						}
						if (target)
							for (key in source) {
								sourceProperty = source[key];
								if (options.noTargetGet) {
									descriptor = getOwnPropertyDescriptor(target, key);
									targetProperty = descriptor && descriptor.value;
								} else targetProperty = target[key];
								FORCED = isForced(
									GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key,
									options.forced
								);
								// contained in target
								if (!FORCED && targetProperty !== undefined) {
									if (typeof sourceProperty === typeof targetProperty) continue;
									copyConstructorProperties(sourceProperty, targetProperty);
								}
								// add a flag to not completely full polyfills
								if (options.sham || (targetProperty && targetProperty.sham)) {
									createNonEnumerableProperty(sourceProperty, 'sham', true);
								}
								// extend global
								redefine(target, key, sourceProperty, options);
							}
					};
				},
				{
					'../internals/copy-constructor-properties': 51,
					'../internals/create-non-enumerable-property': 54,
					'../internals/global': 65,
					'../internals/is-forced': 76,
					'../internals/object-get-own-property-descriptor': 86,
					'../internals/redefine': 98,
					'../internals/set-global': 100
				}
			],
			61: [
				function(_dereq_, module, exports) {
					module.exports = function(exec) {
						try {
							return !!exec();
						} catch (error) {
							return true;
						}
					};
				},
				{}
			],
			62: [
				function(_dereq_, module, exports) {
					var shared = _dereq_('../internals/shared');

					module.exports = shared(
						'native-function-to-string',
						Function.toString
					);
				},
				{ '../internals/shared': 105 }
			],
			63: [
				function(_dereq_, module, exports) {
					var path = _dereq_('../internals/path');
					var global = _dereq_('../internals/global');

					var aFunction = function(variable) {
						return typeof variable == 'function' ? variable : undefined;
					};

					module.exports = function(namespace, method) {
						return arguments.length < 2
							? aFunction(path[namespace]) || aFunction(global[namespace])
							: (path[namespace] && path[namespace][method]) ||
									(global[namespace] && global[namespace][method]);
					};
				},
				{ '../internals/global': 65, '../internals/path': 96 }
			],
			64: [
				function(_dereq_, module, exports) {
					var classof = _dereq_('../internals/classof');
					var Iterators = _dereq_('../internals/iterators');
					var wellKnownSymbol = _dereq_('../internals/well-known-symbol');

					var ITERATOR = wellKnownSymbol('iterator');

					module.exports = function(it) {
						if (it != undefined)
							return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
					};
				},
				{
					'../internals/classof': 50,
					'../internals/iterators': 80,
					'../internals/well-known-symbol': 123
				}
			],
			65: [
				function(_dereq_, module, exports) {
					(function(global) {
						var check = function(it) {
							return it && it.Math == Math && it;
						};

						// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
						module.exports =
							// eslint-disable-next-line no-undef
							check(typeof globalThis == 'object' && globalThis) ||
							check(typeof window == 'object' && window) ||
							check(typeof self == 'object' && self) ||
							check(typeof global == 'object' && global) ||
							// eslint-disable-next-line no-new-func
							Function('return this')();
					}.call(
						this,
						typeof global !== 'undefined'
							? global
							: typeof self !== 'undefined'
							? self
							: typeof window !== 'undefined'
							? window
							: {}
					));
				},
				{}
			],
			66: [
				function(_dereq_, module, exports) {
					var hasOwnProperty = {}.hasOwnProperty;

					module.exports = function(it, key) {
						return hasOwnProperty.call(it, key);
					};
				},
				{}
			],
			67: [
				function(_dereq_, module, exports) {
					module.exports = {};
				},
				{}
			],
			68: [
				function(_dereq_, module, exports) {
					var getBuiltIn = _dereq_('../internals/get-built-in');

					module.exports = getBuiltIn('document', 'documentElement');
				},
				{ '../internals/get-built-in': 63 }
			],
			69: [
				function(_dereq_, module, exports) {
					var DESCRIPTORS = _dereq_('../internals/descriptors');
					var fails = _dereq_('../internals/fails');
					var createElement = _dereq_('../internals/document-create-element');

					// Thank's IE8 for his funny defineProperty
					module.exports =
						!DESCRIPTORS &&
						!fails(function() {
							return (
								Object.defineProperty(createElement('div'), 'a', {
									get: function() {
										return 7;
									}
								}).a != 7
							);
						});
				},
				{
					'../internals/descriptors': 57,
					'../internals/document-create-element': 58,
					'../internals/fails': 61
				}
			],
			70: [
				function(_dereq_, module, exports) {
					// IEEE754 conversions based on https://github.com/feross/ieee754
					// eslint-disable-next-line no-shadow-restricted-names
					var Infinity = 1 / 0;
					var abs = Math.abs;
					var pow = Math.pow;
					var floor = Math.floor;
					var log = Math.log;
					var LN2 = Math.LN2;

					var pack = function(number, mantissaLength, bytes) {
						var buffer = new Array(bytes);
						var exponentLength = bytes * 8 - mantissaLength - 1;
						var eMax = (1 << exponentLength) - 1;
						var eBias = eMax >> 1;
						var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
						var sign = number < 0 || (number === 0 && 1 / number < 0) ? 1 : 0;
						var index = 0;
						var exponent, mantissa, c;
						number = abs(number);
						// eslint-disable-next-line no-self-compare
						if (number != number || number === Infinity) {
							// eslint-disable-next-line no-self-compare
							mantissa = number != number ? 1 : 0;
							exponent = eMax;
						} else {
							exponent = floor(log(number) / LN2);
							if (number * (c = pow(2, -exponent)) < 1) {
								exponent--;
								c *= 2;
							}
							if (exponent + eBias >= 1) {
								number += rt / c;
							} else {
								number += rt * pow(2, 1 - eBias);
							}
							if (number * c >= 2) {
								exponent++;
								c /= 2;
							}
							if (exponent + eBias >= eMax) {
								mantissa = 0;
								exponent = eMax;
							} else if (exponent + eBias >= 1) {
								mantissa = (number * c - 1) * pow(2, mantissaLength);
								exponent = exponent + eBias;
							} else {
								mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
								exponent = 0;
							}
						}
						for (
							;
							mantissaLength >= 8;
							buffer[index++] = mantissa & 255,
								mantissa /= 256,
								mantissaLength -= 8
						);
						exponent = (exponent << mantissaLength) | mantissa;
						exponentLength += mantissaLength;
						for (
							;
							exponentLength > 0;
							buffer[index++] = exponent & 255,
								exponent /= 256,
								exponentLength -= 8
						);
						buffer[--index] |= sign * 128;
						return buffer;
					};

					var unpack = function(buffer, mantissaLength) {
						var bytes = buffer.length;
						var exponentLength = bytes * 8 - mantissaLength - 1;
						var eMax = (1 << exponentLength) - 1;
						var eBias = eMax >> 1;
						var nBits = exponentLength - 7;
						var index = bytes - 1;
						var sign = buffer[index--];
						var exponent = sign & 127;
						var mantissa;
						sign >>= 7;
						for (
							;
							nBits > 0;
							exponent = exponent * 256 + buffer[index], index--, nBits -= 8
						);
						mantissa = exponent & ((1 << -nBits) - 1);
						exponent >>= -nBits;
						nBits += mantissaLength;
						for (
							;
							nBits > 0;
							mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8
						);
						if (exponent === 0) {
							exponent = 1 - eBias;
						} else if (exponent === eMax) {
							return mantissa ? NaN : sign ? -Infinity : Infinity;
						} else {
							mantissa = mantissa + pow(2, mantissaLength);
							exponent = exponent - eBias;
						}
						return (
							(sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength)
						);
					};

					module.exports = {
						pack: pack,
						unpack: unpack
					};
				},
				{}
			],
			71: [
				function(_dereq_, module, exports) {
					var fails = _dereq_('../internals/fails');
					var classof = _dereq_('../internals/classof-raw');

					var split = ''.split;

					// fallback for non-array-like ES3 and non-enumerable old V8 strings
					module.exports = fails(function() {
						// throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
						// eslint-disable-next-line no-prototype-builtins
						return !Object('z').propertyIsEnumerable(0);
					})
						? function(it) {
								return classof(it) == 'String'
									? split.call(it, '')
									: Object(it);
						  }
						: Object;
				},
				{ '../internals/classof-raw': 49, '../internals/fails': 61 }
			],
			72: [
				function(_dereq_, module, exports) {
					var isObject = _dereq_('../internals/is-object');
					var setPrototypeOf = _dereq_('../internals/object-set-prototype-of');

					// makes subclassing work correct for wrapped built-ins
					module.exports = function($this, dummy, Wrapper) {
						var NewTarget, NewTargetPrototype;
						if (
							// it can work only with native `setPrototypeOf`
							setPrototypeOf &&
							// we haven't completely correct pre-ES6 way for getting `new.target`, so use this
							typeof (NewTarget = dummy.constructor) == 'function' &&
							NewTarget !== Wrapper &&
							isObject((NewTargetPrototype = NewTarget.prototype)) &&
							NewTargetPrototype !== Wrapper.prototype
						)
							setPrototypeOf($this, NewTargetPrototype);
						return $this;
					};
				},
				{
					'../internals/is-object': 77,
					'../internals/object-set-prototype-of': 93
				}
			],
			73: [
				function(_dereq_, module, exports) {
					var NATIVE_WEAK_MAP = _dereq_('../internals/native-weak-map');
					var global = _dereq_('../internals/global');
					var isObject = _dereq_('../internals/is-object');
					var createNonEnumerableProperty = _dereq_(
						'../internals/create-non-enumerable-property'
					);
					var objectHas = _dereq_('../internals/has');
					var sharedKey = _dereq_('../internals/shared-key');
					var hiddenKeys = _dereq_('../internals/hidden-keys');

					var WeakMap = global.WeakMap;
					var set, get, has;

					var enforce = function(it) {
						return has(it) ? get(it) : set(it, {});
					};

					var getterFor = function(TYPE) {
						return function(it) {
							var state;
							if (!isObject(it) || (state = get(it)).type !== TYPE) {
								throw TypeError('Incompatible receiver, ' + TYPE + ' required');
							}
							return state;
						};
					};

					if (NATIVE_WEAK_MAP) {
						var store = new WeakMap();
						var wmget = store.get;
						var wmhas = store.has;
						var wmset = store.set;
						set = function(it, metadata) {
							wmset.call(store, it, metadata);
							return metadata;
						};
						get = function(it) {
							return wmget.call(store, it) || {};
						};
						has = function(it) {
							return wmhas.call(store, it);
						};
					} else {
						var STATE = sharedKey('state');
						hiddenKeys[STATE] = true;
						set = function(it, metadata) {
							createNonEnumerableProperty(it, STATE, metadata);
							return metadata;
						};
						get = function(it) {
							return objectHas(it, STATE) ? it[STATE] : {};
						};
						has = function(it) {
							return objectHas(it, STATE);
						};
					}

					module.exports = {
						set: set,
						get: get,
						has: has,
						enforce: enforce,
						getterFor: getterFor
					};
				},
				{
					'../internals/create-non-enumerable-property': 54,
					'../internals/global': 65,
					'../internals/has': 66,
					'../internals/hidden-keys': 67,
					'../internals/is-object': 77,
					'../internals/native-weak-map': 82,
					'../internals/shared-key': 103
				}
			],
			74: [
				function(_dereq_, module, exports) {
					var wellKnownSymbol = _dereq_('../internals/well-known-symbol');
					var Iterators = _dereq_('../internals/iterators');

					var ITERATOR = wellKnownSymbol('iterator');
					var ArrayPrototype = Array.prototype;

					// check on default Array iterator
					module.exports = function(it) {
						return (
							it !== undefined &&
							(Iterators.Array === it || ArrayPrototype[ITERATOR] === it)
						);
					};
				},
				{ '../internals/iterators': 80, '../internals/well-known-symbol': 123 }
			],
			75: [
				function(_dereq_, module, exports) {
					var classof = _dereq_('../internals/classof-raw');

					// `IsArray` abstract operation
					// https://tc39.github.io/ecma262/#sec-isarray
					module.exports =
						Array.isArray ||
						function isArray(arg) {
							return classof(arg) == 'Array';
						};
				},
				{ '../internals/classof-raw': 49 }
			],
			76: [
				function(_dereq_, module, exports) {
					var fails = _dereq_('../internals/fails');

					var replacement = /#|\.prototype\./;

					var isForced = function(feature, detection) {
						var value = data[normalize(feature)];
						return value == POLYFILL
							? true
							: value == NATIVE
							? false
							: typeof detection == 'function'
							? fails(detection)
							: !!detection;
					};

					var normalize = (isForced.normalize = function(string) {
						return String(string)
							.replace(replacement, '.')
							.toLowerCase();
					});

					var data = (isForced.data = {});
					var NATIVE = (isForced.NATIVE = 'N');
					var POLYFILL = (isForced.POLYFILL = 'P');

					module.exports = isForced;
				},
				{ '../internals/fails': 61 }
			],
			77: [
				function(_dereq_, module, exports) {
					module.exports = function(it) {
						return typeof it === 'object'
							? it !== null
							: typeof it === 'function';
					};
				},
				{}
			],
			78: [
				function(_dereq_, module, exports) {
					module.exports = false;
				},
				{}
			],
			79: [
				function(_dereq_, module, exports) {
					'use strict';
					var getPrototypeOf = _dereq_('../internals/object-get-prototype-of');
					var createNonEnumerableProperty = _dereq_(
						'../internals/create-non-enumerable-property'
					);
					var has = _dereq_('../internals/has');
					var wellKnownSymbol = _dereq_('../internals/well-known-symbol');
					var IS_PURE = _dereq_('../internals/is-pure');

					var ITERATOR = wellKnownSymbol('iterator');
					var BUGGY_SAFARI_ITERATORS = false;

					var returnThis = function() {
						return this;
					};

					// `%IteratorPrototype%` object
					// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
					var IteratorPrototype,
						PrototypeOfArrayIteratorPrototype,
						arrayIterator;

					if ([].keys) {
						arrayIterator = [].keys();
						// Safari 8 has buggy iterators w/o `next`
						if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
						else {
							PrototypeOfArrayIteratorPrototype = getPrototypeOf(
								getPrototypeOf(arrayIterator)
							);
							if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
								IteratorPrototype = PrototypeOfArrayIteratorPrototype;
						}
					}

					if (IteratorPrototype == undefined) IteratorPrototype = {};

					// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
					if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) {
						createNonEnumerableProperty(
							IteratorPrototype,
							ITERATOR,
							returnThis
						);
					}

					module.exports = {
						IteratorPrototype: IteratorPrototype,
						BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
					};
				},
				{
					'../internals/create-non-enumerable-property': 54,
					'../internals/has': 66,
					'../internals/is-pure': 78,
					'../internals/object-get-prototype-of': 89,
					'../internals/well-known-symbol': 123
				}
			],
			80: [
				function(_dereq_, module, exports) {
					arguments[4][67][0].apply(exports, arguments);
				},
				{ dup: 67 }
			],
			81: [
				function(_dereq_, module, exports) {
					var fails = _dereq_('../internals/fails');

					module.exports =
						!!Object.getOwnPropertySymbols &&
						!fails(function() {
							// Chrome 38 Symbol has incorrect toString conversion
							// eslint-disable-next-line no-undef
							return !String(Symbol());
						});
				},
				{ '../internals/fails': 61 }
			],
			82: [
				function(_dereq_, module, exports) {
					var global = _dereq_('../internals/global');
					var nativeFunctionToString = _dereq_(
						'../internals/function-to-string'
					);

					var WeakMap = global.WeakMap;

					module.exports =
						typeof WeakMap === 'function' &&
						/native code/.test(nativeFunctionToString.call(WeakMap));
				},
				{ '../internals/function-to-string': 62, '../internals/global': 65 }
			],
			83: [
				function(_dereq_, module, exports) {
					var anObject = _dereq_('../internals/an-object');
					var defineProperties = _dereq_(
						'../internals/object-define-properties'
					);
					var enumBugKeys = _dereq_('../internals/enum-bug-keys');
					var hiddenKeys = _dereq_('../internals/hidden-keys');
					var html = _dereq_('../internals/html');
					var documentCreateElement = _dereq_(
						'../internals/document-create-element'
					);
					var sharedKey = _dereq_('../internals/shared-key');
					var IE_PROTO = sharedKey('IE_PROTO');

					var PROTOTYPE = 'prototype';
					var Empty = function() {
						/* empty */
					};

					// Create object with fake `null` prototype: use iframe Object with cleared prototype
					var createDict = function() {
						// Thrash, waste and sodomy: IE GC bug
						var iframe = documentCreateElement('iframe');
						var length = enumBugKeys.length;
						var lt = '<';
						var script = 'script';
						var gt = '>';
						var js = 'java' + script + ':';
						var iframeDocument;
						iframe.style.display = 'none';
						html.appendChild(iframe);
						iframe.src = String(js);
						iframeDocument = iframe.contentWindow.document;
						iframeDocument.open();
						iframeDocument.write(
							lt + script + gt + 'document.F=Object' + lt + '/' + script + gt
						);
						iframeDocument.close();
						createDict = iframeDocument.F;
						while (length--) delete createDict[PROTOTYPE][enumBugKeys[length]];
						return createDict();
					};

					// `Object.create` method
					// https://tc39.github.io/ecma262/#sec-object.create
					module.exports =
						Object.create ||
						function create(O, Properties) {
							var result;
							if (O !== null) {
								Empty[PROTOTYPE] = anObject(O);
								result = new Empty();
								Empty[PROTOTYPE] = null;
								// add "__proto__" for Object.getPrototypeOf polyfill
								result[IE_PROTO] = O;
							} else result = createDict();
							return Properties === undefined
								? result
								: defineProperties(result, Properties);
						};

					hiddenKeys[IE_PROTO] = true;
				},
				{
					'../internals/an-object': 37,
					'../internals/document-create-element': 58,
					'../internals/enum-bug-keys': 59,
					'../internals/hidden-keys': 67,
					'../internals/html': 68,
					'../internals/object-define-properties': 84,
					'../internals/shared-key': 103
				}
			],
			84: [
				function(_dereq_, module, exports) {
					var DESCRIPTORS = _dereq_('../internals/descriptors');
					var definePropertyModule = _dereq_(
						'../internals/object-define-property'
					);
					var anObject = _dereq_('../internals/an-object');
					var objectKeys = _dereq_('../internals/object-keys');

					// `Object.defineProperties` method
					// https://tc39.github.io/ecma262/#sec-object.defineproperties
					module.exports = DESCRIPTORS
						? Object.defineProperties
						: function defineProperties(O, Properties) {
								anObject(O);
								var keys = objectKeys(Properties);
								var length = keys.length;
								var index = 0;
								var key;
								while (length > index)
									definePropertyModule.f(
										O,
										(key = keys[index++]),
										Properties[key]
									);
								return O;
						  };
				},
				{
					'../internals/an-object': 37,
					'../internals/descriptors': 57,
					'../internals/object-define-property': 85,
					'../internals/object-keys': 91
				}
			],
			85: [
				function(_dereq_, module, exports) {
					var DESCRIPTORS = _dereq_('../internals/descriptors');
					var IE8_DOM_DEFINE = _dereq_('../internals/ie8-dom-define');
					var anObject = _dereq_('../internals/an-object');
					var toPrimitive = _dereq_('../internals/to-primitive');

					var nativeDefineProperty = Object.defineProperty;

					// `Object.defineProperty` method
					// https://tc39.github.io/ecma262/#sec-object.defineproperty
					exports.f = DESCRIPTORS
						? nativeDefineProperty
						: function defineProperty(O, P, Attributes) {
								anObject(O);
								P = toPrimitive(P, true);
								anObject(Attributes);
								if (IE8_DOM_DEFINE)
									try {
										return nativeDefineProperty(O, P, Attributes);
									} catch (error) {
										/* empty */
									}
								if ('get' in Attributes || 'set' in Attributes)
									throw TypeError('Accessors not supported');
								if ('value' in Attributes) O[P] = Attributes.value;
								return O;
						  };
				},
				{
					'../internals/an-object': 37,
					'../internals/descriptors': 57,
					'../internals/ie8-dom-define': 69,
					'../internals/to-primitive': 116
				}
			],
			86: [
				function(_dereq_, module, exports) {
					var DESCRIPTORS = _dereq_('../internals/descriptors');
					var propertyIsEnumerableModule = _dereq_(
						'../internals/object-property-is-enumerable'
					);
					var createPropertyDescriptor = _dereq_(
						'../internals/create-property-descriptor'
					);
					var toIndexedObject = _dereq_('../internals/to-indexed-object');
					var toPrimitive = _dereq_('../internals/to-primitive');
					var has = _dereq_('../internals/has');
					var IE8_DOM_DEFINE = _dereq_('../internals/ie8-dom-define');

					var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

					// `Object.getOwnPropertyDescriptor` method
					// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
					exports.f = DESCRIPTORS
						? nativeGetOwnPropertyDescriptor
						: function getOwnPropertyDescriptor(O, P) {
								O = toIndexedObject(O);
								P = toPrimitive(P, true);
								if (IE8_DOM_DEFINE)
									try {
										return nativeGetOwnPropertyDescriptor(O, P);
									} catch (error) {
										/* empty */
									}
								if (has(O, P))
									return createPropertyDescriptor(
										!propertyIsEnumerableModule.f.call(O, P),
										O[P]
									);
						  };
				},
				{
					'../internals/create-property-descriptor': 55,
					'../internals/descriptors': 57,
					'../internals/has': 66,
					'../internals/ie8-dom-define': 69,
					'../internals/object-property-is-enumerable': 92,
					'../internals/to-indexed-object': 110,
					'../internals/to-primitive': 116
				}
			],
			87: [
				function(_dereq_, module, exports) {
					var internalObjectKeys = _dereq_('../internals/object-keys-internal');
					var enumBugKeys = _dereq_('../internals/enum-bug-keys');

					var hiddenKeys = enumBugKeys.concat('length', 'prototype');

					// `Object.getOwnPropertyNames` method
					// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
					exports.f =
						Object.getOwnPropertyNames ||
						function getOwnPropertyNames(O) {
							return internalObjectKeys(O, hiddenKeys);
						};
				},
				{
					'../internals/enum-bug-keys': 59,
					'../internals/object-keys-internal': 90
				}
			],
			88: [
				function(_dereq_, module, exports) {
					exports.f = Object.getOwnPropertySymbols;
				},
				{}
			],
			89: [
				function(_dereq_, module, exports) {
					var has = _dereq_('../internals/has');
					var toObject = _dereq_('../internals/to-object');
					var sharedKey = _dereq_('../internals/shared-key');
					var CORRECT_PROTOTYPE_GETTER = _dereq_(
						'../internals/correct-prototype-getter'
					);

					var IE_PROTO = sharedKey('IE_PROTO');
					var ObjectPrototype = Object.prototype;

					// `Object.getPrototypeOf` method
					// https://tc39.github.io/ecma262/#sec-object.getprototypeof
					module.exports = CORRECT_PROTOTYPE_GETTER
						? Object.getPrototypeOf
						: function(O) {
								O = toObject(O);
								if (has(O, IE_PROTO)) return O[IE_PROTO];
								if (
									typeof O.constructor == 'function' &&
									O instanceof O.constructor
								) {
									return O.constructor.prototype;
								}
								return O instanceof Object ? ObjectPrototype : null;
						  };
				},
				{
					'../internals/correct-prototype-getter': 52,
					'../internals/has': 66,
					'../internals/shared-key': 103,
					'../internals/to-object': 113
				}
			],
			90: [
				function(_dereq_, module, exports) {
					var has = _dereq_('../internals/has');
					var toIndexedObject = _dereq_('../internals/to-indexed-object');
					var indexOf = _dereq_('../internals/array-includes').indexOf;
					var hiddenKeys = _dereq_('../internals/hidden-keys');

					module.exports = function(object, names) {
						var O = toIndexedObject(object);
						var i = 0;
						var result = [];
						var key;
						for (key in O)
							!has(hiddenKeys, key) && has(O, key) && result.push(key);
						// Don't enum bug & hidden keys
						while (names.length > i)
							if (has(O, (key = names[i++]))) {
								~indexOf(result, key) || result.push(key);
							}
						return result;
					};
				},
				{
					'../internals/array-includes': 42,
					'../internals/has': 66,
					'../internals/hidden-keys': 67,
					'../internals/to-indexed-object': 110
				}
			],
			91: [
				function(_dereq_, module, exports) {
					var internalObjectKeys = _dereq_('../internals/object-keys-internal');
					var enumBugKeys = _dereq_('../internals/enum-bug-keys');

					// `Object.keys` method
					// https://tc39.github.io/ecma262/#sec-object.keys
					module.exports =
						Object.keys ||
						function keys(O) {
							return internalObjectKeys(O, enumBugKeys);
						};
				},
				{
					'../internals/enum-bug-keys': 59,
					'../internals/object-keys-internal': 90
				}
			],
			92: [
				function(_dereq_, module, exports) {
					'use strict';
					var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
					var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

					// Nashorn ~ JDK8 bug
					var NASHORN_BUG =
						getOwnPropertyDescriptor &&
						!nativePropertyIsEnumerable.call({ 1: 2 }, 1);

					// `Object.prototype.propertyIsEnumerable` method implementation
					// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
					exports.f = NASHORN_BUG
						? function propertyIsEnumerable(V) {
								var descriptor = getOwnPropertyDescriptor(this, V);
								return !!descriptor && descriptor.enumerable;
						  }
						: nativePropertyIsEnumerable;
				},
				{}
			],
			93: [
				function(_dereq_, module, exports) {
					var anObject = _dereq_('../internals/an-object');
					var aPossiblePrototype = _dereq_('../internals/a-possible-prototype');

					// `Object.setPrototypeOf` method
					// https://tc39.github.io/ecma262/#sec-object.setprototypeof
					// Works with __proto__ only. Old v8 can't work with null proto objects.
					/* eslint-disable no-proto */
					module.exports =
						Object.setPrototypeOf ||
						('__proto__' in {}
							? (function() {
									var CORRECT_SETTER = false;
									var test = {};
									var setter;
									try {
										setter = Object.getOwnPropertyDescriptor(
											Object.prototype,
											'__proto__'
										).set;
										setter.call(test, []);
										CORRECT_SETTER = test instanceof Array;
									} catch (error) {
										/* empty */
									}
									return function setPrototypeOf(O, proto) {
										anObject(O);
										aPossiblePrototype(proto);
										if (CORRECT_SETTER) setter.call(O, proto);
										else O.__proto__ = proto;
										return O;
									};
							  })()
							: undefined);
				},
				{
					'../internals/a-possible-prototype': 34,
					'../internals/an-object': 37
				}
			],
			94: [
				function(_dereq_, module, exports) {
					'use strict';
					var TO_STRING_TAG_SUPPORT = _dereq_(
						'../internals/to-string-tag-support'
					);
					var classof = _dereq_('../internals/classof');

					// `Object.prototype.toString` method implementation
					// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
					module.exports = TO_STRING_TAG_SUPPORT
						? {}.toString
						: function toString() {
								return '[object ' + classof(this) + ']';
						  };
				},
				{
					'../internals/classof': 50,
					'../internals/to-string-tag-support': 117
				}
			],
			95: [
				function(_dereq_, module, exports) {
					var getBuiltIn = _dereq_('../internals/get-built-in');
					var getOwnPropertyNamesModule = _dereq_(
						'../internals/object-get-own-property-names'
					);
					var getOwnPropertySymbolsModule = _dereq_(
						'../internals/object-get-own-property-symbols'
					);
					var anObject = _dereq_('../internals/an-object');

					// all object keys, includes non-enumerable and symbols
					module.exports =
						getBuiltIn('Reflect', 'ownKeys') ||
						function ownKeys(it) {
							var keys = getOwnPropertyNamesModule.f(anObject(it));
							var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
							return getOwnPropertySymbols
								? keys.concat(getOwnPropertySymbols(it))
								: keys;
						};
				},
				{
					'../internals/an-object': 37,
					'../internals/get-built-in': 63,
					'../internals/object-get-own-property-names': 87,
					'../internals/object-get-own-property-symbols': 88
				}
			],
			96: [
				function(_dereq_, module, exports) {
					module.exports = _dereq_('../internals/global');
				},
				{ '../internals/global': 65 }
			],
			97: [
				function(_dereq_, module, exports) {
					var redefine = _dereq_('../internals/redefine');

					module.exports = function(target, src, options) {
						for (var key in src) redefine(target, key, src[key], options);
						return target;
					};
				},
				{ '../internals/redefine': 98 }
			],
			98: [
				function(_dereq_, module, exports) {
					var global = _dereq_('../internals/global');
					var shared = _dereq_('../internals/shared');
					var createNonEnumerableProperty = _dereq_(
						'../internals/create-non-enumerable-property'
					);
					var has = _dereq_('../internals/has');
					var setGlobal = _dereq_('../internals/set-global');
					var nativeFunctionToString = _dereq_(
						'../internals/function-to-string'
					);
					var InternalStateModule = _dereq_('../internals/internal-state');

					var getInternalState = InternalStateModule.get;
					var enforceInternalState = InternalStateModule.enforce;
					var TEMPLATE = String(nativeFunctionToString).split('toString');

					shared('inspectSource', function(it) {
						return nativeFunctionToString.call(it);
					});

					(module.exports = function(O, key, value, options) {
						var unsafe = options ? !!options.unsafe : false;
						var simple = options ? !!options.enumerable : false;
						var noTargetGet = options ? !!options.noTargetGet : false;
						if (typeof value == 'function') {
							if (typeof key == 'string' && !has(value, 'name'))
								createNonEnumerableProperty(value, 'name', key);
							enforceInternalState(value).source = TEMPLATE.join(
								typeof key == 'string' ? key : ''
							);
						}
						if (O === global) {
							if (simple) O[key] = value;
							else setGlobal(key, value);
							return;
						} else if (!unsafe) {
							delete O[key];
						} else if (!noTargetGet && O[key]) {
							simple = true;
						}
						if (simple) O[key] = value;
						else createNonEnumerableProperty(O, key, value);
						// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
					})(Function.prototype, 'toString', function toString() {
						return (
							(typeof this == 'function' && getInternalState(this).source) ||
							nativeFunctionToString.call(this)
						);
					});
				},
				{
					'../internals/create-non-enumerable-property': 54,
					'../internals/function-to-string': 62,
					'../internals/global': 65,
					'../internals/has': 66,
					'../internals/internal-state': 73,
					'../internals/set-global': 100,
					'../internals/shared': 105
				}
			],
			99: [
				function(_dereq_, module, exports) {
					// `RequireObjectCoercible` abstract operation
					// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
					module.exports = function(it) {
						if (it == undefined) throw TypeError("Can't call method on " + it);
						return it;
					};
				},
				{}
			],
			100: [
				function(_dereq_, module, exports) {
					var global = _dereq_('../internals/global');
					var createNonEnumerableProperty = _dereq_(
						'../internals/create-non-enumerable-property'
					);

					module.exports = function(key, value) {
						try {
							createNonEnumerableProperty(global, key, value);
						} catch (error) {
							global[key] = value;
						}
						return value;
					};
				},
				{
					'../internals/create-non-enumerable-property': 54,
					'../internals/global': 65
				}
			],
			101: [
				function(_dereq_, module, exports) {
					'use strict';
					var getBuiltIn = _dereq_('../internals/get-built-in');
					var definePropertyModule = _dereq_(
						'../internals/object-define-property'
					);
					var wellKnownSymbol = _dereq_('../internals/well-known-symbol');
					var DESCRIPTORS = _dereq_('../internals/descriptors');

					var SPECIES = wellKnownSymbol('species');

					module.exports = function(CONSTRUCTOR_NAME) {
						var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
						var defineProperty = definePropertyModule.f;

						if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
							defineProperty(Constructor, SPECIES, {
								configurable: true,
								get: function() {
									return this;
								}
							});
						}
					};
				},
				{
					'../internals/descriptors': 57,
					'../internals/get-built-in': 63,
					'../internals/object-define-property': 85,
					'../internals/well-known-symbol': 123
				}
			],
			102: [
				function(_dereq_, module, exports) {
					var defineProperty = _dereq_('../internals/object-define-property').f;
					var has = _dereq_('../internals/has');
					var wellKnownSymbol = _dereq_('../internals/well-known-symbol');

					var TO_STRING_TAG = wellKnownSymbol('toStringTag');

					module.exports = function(it, TAG, STATIC) {
						if (it && !has((it = STATIC ? it : it.prototype), TO_STRING_TAG)) {
							defineProperty(it, TO_STRING_TAG, {
								configurable: true,
								value: TAG
							});
						}
					};
				},
				{
					'../internals/has': 66,
					'../internals/object-define-property': 85,
					'../internals/well-known-symbol': 123
				}
			],
			103: [
				function(_dereq_, module, exports) {
					var shared = _dereq_('../internals/shared');
					var uid = _dereq_('../internals/uid');

					var keys = shared('keys');

					module.exports = function(key) {
						return keys[key] || (keys[key] = uid(key));
					};
				},
				{ '../internals/shared': 105, '../internals/uid': 121 }
			],
			104: [
				function(_dereq_, module, exports) {
					var global = _dereq_('../internals/global');
					var setGlobal = _dereq_('../internals/set-global');

					var SHARED = '__core-js_shared__';
					var store = global[SHARED] || setGlobal(SHARED, {});

					module.exports = store;
				},
				{ '../internals/global': 65, '../internals/set-global': 100 }
			],
			105: [
				function(_dereq_, module, exports) {
					var IS_PURE = _dereq_('../internals/is-pure');
					var store = _dereq_('../internals/shared-store');

					(module.exports = function(key, value) {
						return (
							store[key] || (store[key] = value !== undefined ? value : {})
						);
					})('versions', []).push({
						version: '3.4.2',
						mode: IS_PURE ? 'pure' : 'global',
						copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
					});
				},
				{ '../internals/is-pure': 78, '../internals/shared-store': 104 }
			],
			106: [
				function(_dereq_, module, exports) {
					'use strict';
					var fails = _dereq_('../internals/fails');

					module.exports = function(METHOD_NAME, argument) {
						var method = [][METHOD_NAME];
						return (
							!method ||
							!fails(function() {
								// eslint-disable-next-line no-useless-call,no-throw-literal
								method.call(
									null,
									argument ||
										function() {
											throw 1;
										},
									1
								);
							})
						);
					};
				},
				{ '../internals/fails': 61 }
			],
			107: [
				function(_dereq_, module, exports) {
					var anObject = _dereq_('../internals/an-object');
					var aFunction = _dereq_('../internals/a-function');
					var wellKnownSymbol = _dereq_('../internals/well-known-symbol');

					var SPECIES = wellKnownSymbol('species');

					// `SpeciesConstructor` abstract operation
					// https://tc39.github.io/ecma262/#sec-speciesconstructor
					module.exports = function(O, defaultConstructor) {
						var C = anObject(O).constructor;
						var S;
						return C === undefined || (S = anObject(C)[SPECIES]) == undefined
							? defaultConstructor
							: aFunction(S);
					};
				},
				{
					'../internals/a-function': 33,
					'../internals/an-object': 37,
					'../internals/well-known-symbol': 123
				}
			],
			108: [
				function(_dereq_, module, exports) {
					var toInteger = _dereq_('../internals/to-integer');

					var max = Math.max;
					var min = Math.min;

					// Helper for a popular repeating case of the spec:
					// Let integer be ? ToInteger(index).
					// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
					module.exports = function(index, length) {
						var integer = toInteger(index);
						return integer < 0
							? max(integer + length, 0)
							: min(integer, length);
					};
				},
				{ '../internals/to-integer': 111 }
			],
			109: [
				function(_dereq_, module, exports) {
					var toInteger = _dereq_('../internals/to-integer');
					var toLength = _dereq_('../internals/to-length');

					// `ToIndex` abstract operation
					// https://tc39.github.io/ecma262/#sec-toindex
					module.exports = function(it) {
						if (it === undefined) return 0;
						var number = toInteger(it);
						var length = toLength(number);
						if (number !== length) throw RangeError('Wrong length or index');
						return length;
					};
				},
				{ '../internals/to-integer': 111, '../internals/to-length': 112 }
			],
			110: [
				function(_dereq_, module, exports) {
					// toObject with fallback for non-array-like ES3 strings
					var IndexedObject = _dereq_('../internals/indexed-object');
					var requireObjectCoercible = _dereq_(
						'../internals/require-object-coercible'
					);

					module.exports = function(it) {
						return IndexedObject(requireObjectCoercible(it));
					};
				},
				{
					'../internals/indexed-object': 71,
					'../internals/require-object-coercible': 99
				}
			],
			111: [
				function(_dereq_, module, exports) {
					var ceil = Math.ceil;
					var floor = Math.floor;

					// `ToInteger` abstract operation
					// https://tc39.github.io/ecma262/#sec-tointeger
					module.exports = function(argument) {
						return isNaN((argument = +argument))
							? 0
							: (argument > 0 ? floor : ceil)(argument);
					};
				},
				{}
			],
			112: [
				function(_dereq_, module, exports) {
					var toInteger = _dereq_('../internals/to-integer');

					var min = Math.min;

					// `ToLength` abstract operation
					// https://tc39.github.io/ecma262/#sec-tolength
					module.exports = function(argument) {
						return argument > 0
							? min(toInteger(argument), 0x1fffffffffffff)
							: 0; // 2 ** 53 - 1 == 9007199254740991
					};
				},
				{ '../internals/to-integer': 111 }
			],
			113: [
				function(_dereq_, module, exports) {
					var requireObjectCoercible = _dereq_(
						'../internals/require-object-coercible'
					);

					// `ToObject` abstract operation
					// https://tc39.github.io/ecma262/#sec-toobject
					module.exports = function(argument) {
						return Object(requireObjectCoercible(argument));
					};
				},
				{ '../internals/require-object-coercible': 99 }
			],
			114: [
				function(_dereq_, module, exports) {
					var toPositiveInteger = _dereq_('../internals/to-positive-integer');

					module.exports = function(it, BYTES) {
						var offset = toPositiveInteger(it);
						if (offset % BYTES) throw RangeError('Wrong offset');
						return offset;
					};
				},
				{ '../internals/to-positive-integer': 115 }
			],
			115: [
				function(_dereq_, module, exports) {
					var toInteger = _dereq_('../internals/to-integer');

					module.exports = function(it) {
						var result = toInteger(it);
						if (result < 0)
							throw RangeError("The argument can't be less than 0");
						return result;
					};
				},
				{ '../internals/to-integer': 111 }
			],
			116: [
				function(_dereq_, module, exports) {
					var isObject = _dereq_('../internals/is-object');

					// `ToPrimitive` abstract operation
					// https://tc39.github.io/ecma262/#sec-toprimitive
					// instead of the ES6 spec version, we didn't implement @@toPrimitive case
					// and the second argument - flag - preferred type is a string
					module.exports = function(input, PREFERRED_STRING) {
						if (!isObject(input)) return input;
						var fn, val;
						if (
							PREFERRED_STRING &&
							typeof (fn = input.toString) == 'function' &&
							!isObject((val = fn.call(input)))
						)
							return val;
						if (
							typeof (fn = input.valueOf) == 'function' &&
							!isObject((val = fn.call(input)))
						)
							return val;
						if (
							!PREFERRED_STRING &&
							typeof (fn = input.toString) == 'function' &&
							!isObject((val = fn.call(input)))
						)
							return val;
						throw TypeError("Can't convert object to primitive value");
					};
				},
				{ '../internals/is-object': 77 }
			],
			117: [
				function(_dereq_, module, exports) {
					var wellKnownSymbol = _dereq_('../internals/well-known-symbol');

					var TO_STRING_TAG = wellKnownSymbol('toStringTag');
					var test = {};

					test[TO_STRING_TAG] = 'z';

					module.exports = String(test) === '[object z]';
				},
				{ '../internals/well-known-symbol': 123 }
			],
			118: [
				function(_dereq_, module, exports) {
					'use strict';
					var $ = _dereq_('../internals/export');
					var global = _dereq_('../internals/global');
					var DESCRIPTORS = _dereq_('../internals/descriptors');
					var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = _dereq_(
						'../internals/typed-arrays-constructors-requires-wrappers'
					);
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var ArrayBufferModule = _dereq_('../internals/array-buffer');
					var anInstance = _dereq_('../internals/an-instance');
					var createPropertyDescriptor = _dereq_(
						'../internals/create-property-descriptor'
					);
					var createNonEnumerableProperty = _dereq_(
						'../internals/create-non-enumerable-property'
					);
					var toLength = _dereq_('../internals/to-length');
					var toIndex = _dereq_('../internals/to-index');
					var toOffset = _dereq_('../internals/to-offset');
					var toPrimitive = _dereq_('../internals/to-primitive');
					var has = _dereq_('../internals/has');
					var classof = _dereq_('../internals/classof');
					var isObject = _dereq_('../internals/is-object');
					var create = _dereq_('../internals/object-create');
					var setPrototypeOf = _dereq_('../internals/object-set-prototype-of');
					var getOwnPropertyNames = _dereq_(
						'../internals/object-get-own-property-names'
					).f;
					var typedArrayFrom = _dereq_('../internals/typed-array-from');
					var forEach = _dereq_('../internals/array-iteration').forEach;
					var setSpecies = _dereq_('../internals/set-species');
					var definePropertyModule = _dereq_(
						'../internals/object-define-property'
					);
					var getOwnPropertyDescriptorModule = _dereq_(
						'../internals/object-get-own-property-descriptor'
					);
					var InternalStateModule = _dereq_('../internals/internal-state');
					var inheritIfRequired = _dereq_('../internals/inherit-if-required');

					var getInternalState = InternalStateModule.get;
					var setInternalState = InternalStateModule.set;
					var nativeDefineProperty = definePropertyModule.f;
					var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
					var round = Math.round;
					var RangeError = global.RangeError;
					var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
					var DataView = ArrayBufferModule.DataView;
					var NATIVE_ARRAY_BUFFER_VIEWS =
						ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
					var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
					var TypedArray = ArrayBufferViewCore.TypedArray;
					var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
					var aTypedArrayConstructor =
						ArrayBufferViewCore.aTypedArrayConstructor;
					var isTypedArray = ArrayBufferViewCore.isTypedArray;
					var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
					var WRONG_LENGTH = 'Wrong length';

					var fromList = function(C, list) {
						var index = 0;
						var length = list.length;
						var result = new (aTypedArrayConstructor(C))(length);
						while (length > index) result[index] = list[index++];
						return result;
					};

					var addGetter = function(it, key) {
						nativeDefineProperty(it, key, {
							get: function() {
								return getInternalState(this)[key];
							}
						});
					};

					var isArrayBuffer = function(it) {
						var klass;
						return (
							it instanceof ArrayBuffer ||
							(klass = classof(it)) == 'ArrayBuffer' ||
							klass == 'SharedArrayBuffer'
						);
					};

					var isTypedArrayIndex = function(target, key) {
						return (
							isTypedArray(target) &&
							typeof key != 'symbol' &&
							key in target &&
							String(+key) == String(key)
						);
					};

					var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(
						target,
						key
					) {
						return isTypedArrayIndex(target, (key = toPrimitive(key, true)))
							? createPropertyDescriptor(2, target[key])
							: nativeGetOwnPropertyDescriptor(target, key);
					};

					var wrappedDefineProperty = function defineProperty(
						target,
						key,
						descriptor
					) {
						if (
							isTypedArrayIndex(target, (key = toPrimitive(key, true))) &&
							isObject(descriptor) &&
							has(descriptor, 'value') &&
							!has(descriptor, 'get') &&
							!has(descriptor, 'set') &&
							// TODO: add validation descriptor w/o calling accessors
							!descriptor.configurable &&
							(!has(descriptor, 'writable') || descriptor.writable) &&
							(!has(descriptor, 'enumerable') || descriptor.enumerable)
						) {
							target[key] = descriptor.value;
							return target;
						}
						return nativeDefineProperty(target, key, descriptor);
					};

					if (DESCRIPTORS) {
						if (!NATIVE_ARRAY_BUFFER_VIEWS) {
							getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
							definePropertyModule.f = wrappedDefineProperty;
							addGetter(TypedArrayPrototype, 'buffer');
							addGetter(TypedArrayPrototype, 'byteOffset');
							addGetter(TypedArrayPrototype, 'byteLength');
							addGetter(TypedArrayPrototype, 'length');
						}

						$(
							{
								target: 'Object',
								stat: true,
								forced: !NATIVE_ARRAY_BUFFER_VIEWS
							},
							{
								getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
								defineProperty: wrappedDefineProperty
							}
						);

						module.exports = function(TYPE, BYTES, wrapper, CLAMPED) {
							var CONSTRUCTOR_NAME =
								TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
							var GETTER = 'get' + TYPE;
							var SETTER = 'set' + TYPE;
							var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
							var TypedArrayConstructor = NativeTypedArrayConstructor;
							var TypedArrayConstructorPrototype =
								TypedArrayConstructor && TypedArrayConstructor.prototype;
							var exported = {};

							var getter = function(that, index) {
								var data = getInternalState(that);
								return data.view[GETTER](index * BYTES + data.byteOffset, true);
							};

							var setter = function(that, index, value) {
								var data = getInternalState(that);
								if (CLAMPED)
									value =
										(value = round(value)) < 0
											? 0
											: value > 0xff
											? 0xff
											: value & 0xff;
								data.view[SETTER](index * BYTES + data.byteOffset, value, true);
							};

							var addElement = function(that, index) {
								nativeDefineProperty(that, index, {
									get: function() {
										return getter(this, index);
									},
									set: function(value) {
										return setter(this, index, value);
									},
									enumerable: true
								});
							};

							if (!NATIVE_ARRAY_BUFFER_VIEWS) {
								TypedArrayConstructor = wrapper(function(
									that,
									data,
									offset,
									$length
								) {
									anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
									var index = 0;
									var byteOffset = 0;
									var buffer, byteLength, length;
									if (!isObject(data)) {
										length = toIndex(data);
										byteLength = length * BYTES;
										buffer = new ArrayBuffer(byteLength);
									} else if (isArrayBuffer(data)) {
										buffer = data;
										byteOffset = toOffset(offset, BYTES);
										var $len = data.byteLength;
										if ($length === undefined) {
											if ($len % BYTES) throw RangeError(WRONG_LENGTH);
											byteLength = $len - byteOffset;
											if (byteLength < 0) throw RangeError(WRONG_LENGTH);
										} else {
											byteLength = toLength($length) * BYTES;
											if (byteLength + byteOffset > $len)
												throw RangeError(WRONG_LENGTH);
										}
										length = byteLength / BYTES;
									} else if (isTypedArray(data)) {
										return fromList(TypedArrayConstructor, data);
									} else {
										return typedArrayFrom.call(TypedArrayConstructor, data);
									}
									setInternalState(that, {
										buffer: buffer,
										byteOffset: byteOffset,
										byteLength: byteLength,
										length: length,
										view: new DataView(buffer)
									});
									while (index < length) addElement(that, index++);
								});

								if (setPrototypeOf)
									setPrototypeOf(TypedArrayConstructor, TypedArray);
								TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(
									TypedArrayPrototype
								);
							} else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
								TypedArrayConstructor = wrapper(function(
									dummy,
									data,
									typedArrayOffset,
									$length
								) {
									anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
									return inheritIfRequired(
										(function() {
											if (!isObject(data))
												return new NativeTypedArrayConstructor(toIndex(data));
											if (isArrayBuffer(data))
												return $length !== undefined
													? new NativeTypedArrayConstructor(
															data,
															toOffset(typedArrayOffset, BYTES),
															$length
													  )
													: typedArrayOffset !== undefined
													? new NativeTypedArrayConstructor(
															data,
															toOffset(typedArrayOffset, BYTES)
													  )
													: new NativeTypedArrayConstructor(data);
											if (isTypedArray(data))
												return fromList(TypedArrayConstructor, data);
											return typedArrayFrom.call(TypedArrayConstructor, data);
										})(),
										dummy,
										TypedArrayConstructor
									);
								});

								if (setPrototypeOf)
									setPrototypeOf(TypedArrayConstructor, TypedArray);
								forEach(
									getOwnPropertyNames(NativeTypedArrayConstructor),
									function(key) {
										if (!(key in TypedArrayConstructor)) {
											createNonEnumerableProperty(
												TypedArrayConstructor,
												key,
												NativeTypedArrayConstructor[key]
											);
										}
									}
								);
								TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
							}

							if (
								TypedArrayConstructorPrototype.constructor !==
								TypedArrayConstructor
							) {
								createNonEnumerableProperty(
									TypedArrayConstructorPrototype,
									'constructor',
									TypedArrayConstructor
								);
							}

							if (TYPED_ARRAY_TAG) {
								createNonEnumerableProperty(
									TypedArrayConstructorPrototype,
									TYPED_ARRAY_TAG,
									CONSTRUCTOR_NAME
								);
							}

							exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

							$(
								{
									global: true,
									forced: TypedArrayConstructor != NativeTypedArrayConstructor,
									sham: !NATIVE_ARRAY_BUFFER_VIEWS
								},
								exported
							);

							if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
								createNonEnumerableProperty(
									TypedArrayConstructor,
									BYTES_PER_ELEMENT,
									BYTES
								);
							}

							if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
								createNonEnumerableProperty(
									TypedArrayConstructorPrototype,
									BYTES_PER_ELEMENT,
									BYTES
								);
							}

							setSpecies(CONSTRUCTOR_NAME);
						};
					} else
						module.exports = function() {
							/* empty */
						};
				},
				{
					'../internals/an-instance': 36,
					'../internals/array-buffer': 39,
					'../internals/array-buffer-view-core': 38,
					'../internals/array-iteration': 43,
					'../internals/classof': 50,
					'../internals/create-non-enumerable-property': 54,
					'../internals/create-property-descriptor': 55,
					'../internals/descriptors': 57,
					'../internals/export': 60,
					'../internals/global': 65,
					'../internals/has': 66,
					'../internals/inherit-if-required': 72,
					'../internals/internal-state': 73,
					'../internals/is-object': 77,
					'../internals/object-create': 83,
					'../internals/object-define-property': 85,
					'../internals/object-get-own-property-descriptor': 86,
					'../internals/object-get-own-property-names': 87,
					'../internals/object-set-prototype-of': 93,
					'../internals/set-species': 101,
					'../internals/to-index': 109,
					'../internals/to-length': 112,
					'../internals/to-offset': 114,
					'../internals/to-primitive': 116,
					'../internals/typed-array-from': 119,
					'../internals/typed-arrays-constructors-requires-wrappers': 120
				}
			],
			119: [
				function(_dereq_, module, exports) {
					var toObject = _dereq_('../internals/to-object');
					var toLength = _dereq_('../internals/to-length');
					var getIteratorMethod = _dereq_('../internals/get-iterator-method');
					var isArrayIteratorMethod = _dereq_(
						'../internals/is-array-iterator-method'
					);
					var bind = _dereq_('../internals/bind-context');
					var aTypedArrayConstructor = _dereq_(
						'../internals/array-buffer-view-core'
					).aTypedArrayConstructor;

					module.exports = function from(source /* , mapfn, thisArg */) {
						var O = toObject(source);
						var argumentsLength = arguments.length;
						var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
						var mapping = mapfn !== undefined;
						var iteratorMethod = getIteratorMethod(O);
						var i, length, result, step, iterator, next;
						if (
							iteratorMethod != undefined &&
							!isArrayIteratorMethod(iteratorMethod)
						) {
							iterator = iteratorMethod.call(O);
							next = iterator.next;
							O = [];
							while (!(step = next.call(iterator)).done) {
								O.push(step.value);
							}
						}
						if (mapping && argumentsLength > 2) {
							mapfn = bind(mapfn, arguments[2], 2);
						}
						length = toLength(O.length);
						result = new (aTypedArrayConstructor(this))(length);
						for (i = 0; length > i; i++) {
							result[i] = mapping ? mapfn(O[i], i) : O[i];
						}
						return result;
					};
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/bind-context': 47,
					'../internals/get-iterator-method': 64,
					'../internals/is-array-iterator-method': 74,
					'../internals/to-length': 112,
					'../internals/to-object': 113
				}
			],
			120: [
				function(_dereq_, module, exports) {
					/* eslint-disable no-new */
					var global = _dereq_('../internals/global');
					var fails = _dereq_('../internals/fails');
					var checkCorrectnessOfIteration = _dereq_(
						'../internals/check-correctness-of-iteration'
					);
					var NATIVE_ARRAY_BUFFER_VIEWS = _dereq_(
						'../internals/array-buffer-view-core'
					).NATIVE_ARRAY_BUFFER_VIEWS;

					var ArrayBuffer = global.ArrayBuffer;
					var Int8Array = global.Int8Array;

					module.exports =
						!NATIVE_ARRAY_BUFFER_VIEWS ||
						!fails(function() {
							Int8Array(1);
						}) ||
						!fails(function() {
							new Int8Array(-1);
						}) ||
						!checkCorrectnessOfIteration(function(iterable) {
							new Int8Array();
							new Int8Array(null);
							new Int8Array(1.5);
							new Int8Array(iterable);
						}, true) ||
						fails(function() {
							// Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
							return (
								new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1
							);
						});
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/check-correctness-of-iteration': 48,
					'../internals/fails': 61,
					'../internals/global': 65
				}
			],
			121: [
				function(_dereq_, module, exports) {
					var id = 0;
					var postfix = Math.random();

					module.exports = function(key) {
						return (
							'Symbol(' +
							String(key === undefined ? '' : key) +
							')_' +
							(++id + postfix).toString(36)
						);
					};
				},
				{}
			],
			122: [
				function(_dereq_, module, exports) {
					var NATIVE_SYMBOL = _dereq_('../internals/native-symbol');

					module.exports =
						NATIVE_SYMBOL &&
						// eslint-disable-next-line no-undef
						!Symbol.sham &&
						// eslint-disable-next-line no-undef
						typeof Symbol() == 'symbol';
				},
				{ '../internals/native-symbol': 81 }
			],
			123: [
				function(_dereq_, module, exports) {
					var global = _dereq_('../internals/global');
					var shared = _dereq_('../internals/shared');
					var has = _dereq_('../internals/has');
					var uid = _dereq_('../internals/uid');
					var NATIVE_SYMBOL = _dereq_('../internals/native-symbol');
					var USE_SYMBOL_AS_UID = _dereq_('../internals/use-symbol-as-uid');

					var WellKnownSymbolsStore = shared('wks');
					var Symbol = global.Symbol;
					var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : uid;

					module.exports = function(name) {
						if (!has(WellKnownSymbolsStore, name)) {
							if (NATIVE_SYMBOL && has(Symbol, name))
								WellKnownSymbolsStore[name] = Symbol[name];
							else
								WellKnownSymbolsStore[name] = createWellKnownSymbol(
									'Symbol.' + name
								);
						}
						return WellKnownSymbolsStore[name];
					};
				},
				{
					'../internals/global': 65,
					'../internals/has': 66,
					'../internals/native-symbol': 81,
					'../internals/shared': 105,
					'../internals/uid': 121,
					'../internals/use-symbol-as-uid': 122
				}
			],
			124: [
				function(_dereq_, module, exports) {
					'use strict';
					var toIndexedObject = _dereq_('../internals/to-indexed-object');
					var addToUnscopables = _dereq_('../internals/add-to-unscopables');
					var Iterators = _dereq_('../internals/iterators');
					var InternalStateModule = _dereq_('../internals/internal-state');
					var defineIterator = _dereq_('../internals/define-iterator');

					var ARRAY_ITERATOR = 'Array Iterator';
					var setInternalState = InternalStateModule.set;
					var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

					// `Array.prototype.entries` method
					// https://tc39.github.io/ecma262/#sec-array.prototype.entries
					// `Array.prototype.keys` method
					// https://tc39.github.io/ecma262/#sec-array.prototype.keys
					// `Array.prototype.values` method
					// https://tc39.github.io/ecma262/#sec-array.prototype.values
					// `Array.prototype[@@iterator]` method
					// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
					// `CreateArrayIterator` internal method
					// https://tc39.github.io/ecma262/#sec-createarrayiterator
					module.exports = defineIterator(
						Array,
						'Array',
						function(iterated, kind) {
							setInternalState(this, {
								type: ARRAY_ITERATOR,
								target: toIndexedObject(iterated), // target
								index: 0, // next index
								kind: kind // kind
							});
							// `%ArrayIteratorPrototype%.next` method
							// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
						},
						function() {
							var state = getInternalState(this);
							var target = state.target;
							var kind = state.kind;
							var index = state.index++;
							if (!target || index >= target.length) {
								state.target = undefined;
								return { value: undefined, done: true };
							}
							if (kind == 'keys') return { value: index, done: false };
							if (kind == 'values')
								return { value: target[index], done: false };
							return { value: [index, target[index]], done: false };
						},
						'values'
					);

					// argumentsList[@@iterator] is %ArrayProto_values%
					// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
					// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
					Iterators.Arguments = Iterators.Array;

					// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
					addToUnscopables('keys');
					addToUnscopables('values');
					addToUnscopables('entries');
				},
				{
					'../internals/add-to-unscopables': 35,
					'../internals/define-iterator': 56,
					'../internals/internal-state': 73,
					'../internals/iterators': 80,
					'../internals/to-indexed-object': 110
				}
			],
			125: [
				function(_dereq_, module, exports) {
					var TO_STRING_TAG_SUPPORT = _dereq_(
						'../internals/to-string-tag-support'
					);
					var redefine = _dereq_('../internals/redefine');
					var toString = _dereq_('../internals/object-to-string');

					// `Object.prototype.toString` method
					// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
					if (!TO_STRING_TAG_SUPPORT) {
						redefine(Object.prototype, 'toString', toString, { unsafe: true });
					}
				},
				{
					'../internals/object-to-string': 94,
					'../internals/redefine': 98,
					'../internals/to-string-tag-support': 117
				}
			],
			126: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var $copyWithin = _dereq_('../internals/array-copy-within');

					var aTypedArray = ArrayBufferViewCore.aTypedArray;

					// `%TypedArray%.prototype.copyWithin` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin
					ArrayBufferViewCore.exportProto('copyWithin', function copyWithin(
						target,
						start /* , end */
					) {
						return $copyWithin.call(
							aTypedArray(this),
							target,
							start,
							arguments.length > 2 ? arguments[2] : undefined
						);
					});
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/array-copy-within': 40
				}
			],
			127: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var $every = _dereq_('../internals/array-iteration').every;

					var aTypedArray = ArrayBufferViewCore.aTypedArray;

					// `%TypedArray%.prototype.every` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every
					ArrayBufferViewCore.exportProto('every', function every(
						callbackfn /* , thisArg */
					) {
						return $every(
							aTypedArray(this),
							callbackfn,
							arguments.length > 1 ? arguments[1] : undefined
						);
					});
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/array-iteration': 43
				}
			],
			128: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var $fill = _dereq_('../internals/array-fill');

					var aTypedArray = ArrayBufferViewCore.aTypedArray;

					// `%TypedArray%.prototype.fill` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
					// eslint-disable-next-line no-unused-vars
					ArrayBufferViewCore.exportProto('fill', function fill(
						value /* , start, end */
					) {
						return $fill.apply(aTypedArray(this), arguments);
					});
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/array-fill': 41
				}
			],
			129: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var $filter = _dereq_('../internals/array-iteration').filter;
					var speciesConstructor = _dereq_('../internals/species-constructor');

					var aTypedArray = ArrayBufferViewCore.aTypedArray;
					var aTypedArrayConstructor =
						ArrayBufferViewCore.aTypedArrayConstructor;

					// `%TypedArray%.prototype.filter` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter
					ArrayBufferViewCore.exportProto('filter', function filter(
						callbackfn /* , thisArg */
					) {
						var list = $filter(
							aTypedArray(this),
							callbackfn,
							arguments.length > 1 ? arguments[1] : undefined
						);
						var C = speciesConstructor(this, this.constructor);
						var index = 0;
						var length = list.length;
						var result = new (aTypedArrayConstructor(C))(length);
						while (length > index) result[index] = list[index++];
						return result;
					});
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/array-iteration': 43,
					'../internals/species-constructor': 107
				}
			],
			130: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var $findIndex = _dereq_('../internals/array-iteration').findIndex;

					var aTypedArray = ArrayBufferViewCore.aTypedArray;

					// `%TypedArray%.prototype.findIndex` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex
					ArrayBufferViewCore.exportProto('findIndex', function findIndex(
						predicate /* , thisArg */
					) {
						return $findIndex(
							aTypedArray(this),
							predicate,
							arguments.length > 1 ? arguments[1] : undefined
						);
					});
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/array-iteration': 43
				}
			],
			131: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var $find = _dereq_('../internals/array-iteration').find;

					var aTypedArray = ArrayBufferViewCore.aTypedArray;

					// `%TypedArray%.prototype.find` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find
					ArrayBufferViewCore.exportProto('find', function find(
						predicate /* , thisArg */
					) {
						return $find(
							aTypedArray(this),
							predicate,
							arguments.length > 1 ? arguments[1] : undefined
						);
					});
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/array-iteration': 43
				}
			],
			132: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var $forEach = _dereq_('../internals/array-iteration').forEach;

					var aTypedArray = ArrayBufferViewCore.aTypedArray;

					// `%TypedArray%.prototype.forEach` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach
					ArrayBufferViewCore.exportProto('forEach', function forEach(
						callbackfn /* , thisArg */
					) {
						$forEach(
							aTypedArray(this),
							callbackfn,
							arguments.length > 1 ? arguments[1] : undefined
						);
					});
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/array-iteration': 43
				}
			],
			133: [
				function(_dereq_, module, exports) {
					'use strict';
					var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = _dereq_(
						'../internals/typed-arrays-constructors-requires-wrappers'
					);
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var typedArrayFrom = _dereq_('../internals/typed-array-from');

					// `%TypedArray%.from` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.from
					ArrayBufferViewCore.exportStatic(
						'from',
						typedArrayFrom,
						TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS
					);
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/typed-array-from': 119,
					'../internals/typed-arrays-constructors-requires-wrappers': 120
				}
			],
			134: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var $includes = _dereq_('../internals/array-includes').includes;

					var aTypedArray = ArrayBufferViewCore.aTypedArray;

					// `%TypedArray%.prototype.includes` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes
					ArrayBufferViewCore.exportProto('includes', function includes(
						searchElement /* , fromIndex */
					) {
						return $includes(
							aTypedArray(this),
							searchElement,
							arguments.length > 1 ? arguments[1] : undefined
						);
					});
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/array-includes': 42
				}
			],
			135: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var $indexOf = _dereq_('../internals/array-includes').indexOf;

					var aTypedArray = ArrayBufferViewCore.aTypedArray;

					// `%TypedArray%.prototype.indexOf` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof
					ArrayBufferViewCore.exportProto('indexOf', function indexOf(
						searchElement /* , fromIndex */
					) {
						return $indexOf(
							aTypedArray(this),
							searchElement,
							arguments.length > 1 ? arguments[1] : undefined
						);
					});
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/array-includes': 42
				}
			],
			136: [
				function(_dereq_, module, exports) {
					'use strict';
					var global = _dereq_('../internals/global');
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var ArrayIterators = _dereq_('../modules/es.array.iterator');
					var wellKnownSymbol = _dereq_('../internals/well-known-symbol');

					var ITERATOR = wellKnownSymbol('iterator');
					var Uint8Array = global.Uint8Array;
					var arrayValues = ArrayIterators.values;
					var arrayKeys = ArrayIterators.keys;
					var arrayEntries = ArrayIterators.entries;
					var aTypedArray = ArrayBufferViewCore.aTypedArray;
					var exportProto = ArrayBufferViewCore.exportProto;
					var nativeTypedArrayIterator =
						Uint8Array && Uint8Array.prototype[ITERATOR];

					var CORRECT_ITER_NAME =
						!!nativeTypedArrayIterator &&
						(nativeTypedArrayIterator.name == 'values' ||
							nativeTypedArrayIterator.name == undefined);

					var typedArrayValues = function values() {
						return arrayValues.call(aTypedArray(this));
					};

					// `%TypedArray%.prototype.entries` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries
					exportProto('entries', function entries() {
						return arrayEntries.call(aTypedArray(this));
					});
					// `%TypedArray%.prototype.keys` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys
					exportProto('keys', function keys() {
						return arrayKeys.call(aTypedArray(this));
					});
					// `%TypedArray%.prototype.values` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values
					exportProto('values', typedArrayValues, !CORRECT_ITER_NAME);
					// `%TypedArray%.prototype[@@iterator]` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator
					exportProto(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/global': 65,
					'../internals/well-known-symbol': 123,
					'../modules/es.array.iterator': 124
				}
			],
			137: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);

					var aTypedArray = ArrayBufferViewCore.aTypedArray;
					var $join = [].join;

					// `%TypedArray%.prototype.join` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join
					// eslint-disable-next-line no-unused-vars
					ArrayBufferViewCore.exportProto('join', function join(separator) {
						return $join.apply(aTypedArray(this), arguments);
					});
				},
				{ '../internals/array-buffer-view-core': 38 }
			],
			138: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var $lastIndexOf = _dereq_('../internals/array-last-index-of');

					var aTypedArray = ArrayBufferViewCore.aTypedArray;

					// `%TypedArray%.prototype.lastIndexOf` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof
					// eslint-disable-next-line no-unused-vars
					ArrayBufferViewCore.exportProto('lastIndexOf', function lastIndexOf(
						searchElement /* , fromIndex */
					) {
						return $lastIndexOf.apply(aTypedArray(this), arguments);
					});
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/array-last-index-of': 44
				}
			],
			139: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var $map = _dereq_('../internals/array-iteration').map;
					var speciesConstructor = _dereq_('../internals/species-constructor');

					var aTypedArray = ArrayBufferViewCore.aTypedArray;
					var aTypedArrayConstructor =
						ArrayBufferViewCore.aTypedArrayConstructor;

					// `%TypedArray%.prototype.map` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map
					ArrayBufferViewCore.exportProto('map', function map(
						mapfn /* , thisArg */
					) {
						return $map(
							aTypedArray(this),
							mapfn,
							arguments.length > 1 ? arguments[1] : undefined,
							function(O, length) {
								return new (aTypedArrayConstructor(
									speciesConstructor(O, O.constructor)
								))(length);
							}
						);
					});
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/array-iteration': 43,
					'../internals/species-constructor': 107
				}
			],
			140: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = _dereq_(
						'../internals/typed-arrays-constructors-requires-wrappers'
					);

					var aTypedArrayConstructor =
						ArrayBufferViewCore.aTypedArrayConstructor;

					// `%TypedArray%.of` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.of
					ArrayBufferViewCore.exportStatic(
						'of',
						function of(/* ...items */) {
							var index = 0;
							var length = arguments.length;
							var result = new (aTypedArrayConstructor(this))(length);
							while (length > index) result[index] = arguments[index++];
							return result;
						},
						TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS
					);
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/typed-arrays-constructors-requires-wrappers': 120
				}
			],
			141: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var $reduceRight = _dereq_('../internals/array-reduce').right;

					var aTypedArray = ArrayBufferViewCore.aTypedArray;

					// `%TypedArray%.prototype.reduceRicht` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright
					ArrayBufferViewCore.exportProto('reduceRight', function reduceRight(
						callbackfn /* , initialValue */
					) {
						return $reduceRight(
							aTypedArray(this),
							callbackfn,
							arguments.length,
							arguments.length > 1 ? arguments[1] : undefined
						);
					});
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/array-reduce': 45
				}
			],
			142: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var $reduce = _dereq_('../internals/array-reduce').left;

					var aTypedArray = ArrayBufferViewCore.aTypedArray;

					// `%TypedArray%.prototype.reduce` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce
					ArrayBufferViewCore.exportProto('reduce', function reduce(
						callbackfn /* , initialValue */
					) {
						return $reduce(
							aTypedArray(this),
							callbackfn,
							arguments.length,
							arguments.length > 1 ? arguments[1] : undefined
						);
					});
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/array-reduce': 45
				}
			],
			143: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);

					var aTypedArray = ArrayBufferViewCore.aTypedArray;
					var floor = Math.floor;

					// `%TypedArray%.prototype.reverse` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse
					ArrayBufferViewCore.exportProto('reverse', function reverse() {
						var that = this;
						var length = aTypedArray(that).length;
						var middle = floor(length / 2);
						var index = 0;
						var value;
						while (index < middle) {
							value = that[index];
							that[index++] = that[--length];
							that[length] = value;
						}
						return that;
					});
				},
				{ '../internals/array-buffer-view-core': 38 }
			],
			144: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var toLength = _dereq_('../internals/to-length');
					var toOffset = _dereq_('../internals/to-offset');
					var toObject = _dereq_('../internals/to-object');
					var fails = _dereq_('../internals/fails');

					var aTypedArray = ArrayBufferViewCore.aTypedArray;

					var FORCED = fails(function() {
						// eslint-disable-next-line no-undef
						new Int8Array(1).set({});
					});

					// `%TypedArray%.prototype.set` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set
					ArrayBufferViewCore.exportProto(
						'set',
						function set(arrayLike /* , offset */) {
							aTypedArray(this);
							var offset = toOffset(
								arguments.length > 1 ? arguments[1] : undefined,
								1
							);
							var length = this.length;
							var src = toObject(arrayLike);
							var len = toLength(src.length);
							var index = 0;
							if (len + offset > length) throw RangeError('Wrong length');
							while (index < len) this[offset + index] = src[index++];
						},
						FORCED
					);
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/fails': 61,
					'../internals/to-length': 112,
					'../internals/to-object': 113,
					'../internals/to-offset': 114
				}
			],
			145: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var speciesConstructor = _dereq_('../internals/species-constructor');
					var fails = _dereq_('../internals/fails');

					var aTypedArray = ArrayBufferViewCore.aTypedArray;
					var aTypedArrayConstructor =
						ArrayBufferViewCore.aTypedArrayConstructor;
					var $slice = [].slice;

					var FORCED = fails(function() {
						// eslint-disable-next-line no-undef
						new Int8Array(1).slice();
					});

					// `%TypedArray%.prototype.slice` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice
					ArrayBufferViewCore.exportProto(
						'slice',
						function slice(start, end) {
							var list = $slice.call(aTypedArray(this), start, end);
							var C = speciesConstructor(this, this.constructor);
							var index = 0;
							var length = list.length;
							var result = new (aTypedArrayConstructor(C))(length);
							while (length > index) result[index] = list[index++];
							return result;
						},
						FORCED
					);
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/fails': 61,
					'../internals/species-constructor': 107
				}
			],
			146: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var $some = _dereq_('../internals/array-iteration').some;

					var aTypedArray = ArrayBufferViewCore.aTypedArray;

					// `%TypedArray%.prototype.some` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some
					ArrayBufferViewCore.exportProto('some', function some(
						callbackfn /* , thisArg */
					) {
						return $some(
							aTypedArray(this),
							callbackfn,
							arguments.length > 1 ? arguments[1] : undefined
						);
					});
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/array-iteration': 43
				}
			],
			147: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);

					var aTypedArray = ArrayBufferViewCore.aTypedArray;
					var $sort = [].sort;

					// `%TypedArray%.prototype.sort` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort
					ArrayBufferViewCore.exportProto('sort', function sort(comparefn) {
						return $sort.call(aTypedArray(this), comparefn);
					});
				},
				{ '../internals/array-buffer-view-core': 38 }
			],
			148: [
				function(_dereq_, module, exports) {
					'use strict';
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var toLength = _dereq_('../internals/to-length');
					var toAbsoluteIndex = _dereq_('../internals/to-absolute-index');
					var speciesConstructor = _dereq_('../internals/species-constructor');

					var aTypedArray = ArrayBufferViewCore.aTypedArray;

					// `%TypedArray%.prototype.subarray` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray
					ArrayBufferViewCore.exportProto('subarray', function subarray(
						begin,
						end
					) {
						var O = aTypedArray(this);
						var length = O.length;
						var beginIndex = toAbsoluteIndex(begin, length);
						return new (speciesConstructor(O, O.constructor))(
							O.buffer,
							O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
							toLength(
								(end === undefined ? length : toAbsoluteIndex(end, length)) -
									beginIndex
							)
						);
					});
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/species-constructor': 107,
					'../internals/to-absolute-index': 108,
					'../internals/to-length': 112
				}
			],
			149: [
				function(_dereq_, module, exports) {
					'use strict';
					var global = _dereq_('../internals/global');
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var fails = _dereq_('../internals/fails');

					var Int8Array = global.Int8Array;
					var aTypedArray = ArrayBufferViewCore.aTypedArray;
					var $toLocaleString = [].toLocaleString;
					var $slice = [].slice;

					// iOS Safari 6.x fails here
					var TO_LOCALE_STRING_BUG =
						!!Int8Array &&
						fails(function() {
							$toLocaleString.call(new Int8Array(1));
						});

					var FORCED =
						fails(function() {
							return (
								[1, 2].toLocaleString() !=
								new Int8Array([1, 2]).toLocaleString()
							);
						}) ||
						!fails(function() {
							Int8Array.prototype.toLocaleString.call([1, 2]);
						});

					// `%TypedArray%.prototype.toLocaleString` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring
					ArrayBufferViewCore.exportProto(
						'toLocaleString',
						function toLocaleString() {
							return $toLocaleString.apply(
								TO_LOCALE_STRING_BUG
									? $slice.call(aTypedArray(this))
									: aTypedArray(this),
								arguments
							);
						},
						FORCED
					);
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/fails': 61,
					'../internals/global': 65
				}
			],
			150: [
				function(_dereq_, module, exports) {
					'use strict';
					var global = _dereq_('../internals/global');
					var ArrayBufferViewCore = _dereq_(
						'../internals/array-buffer-view-core'
					);
					var fails = _dereq_('../internals/fails');

					var Uint8Array = global.Uint8Array;
					var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype;
					var arrayToString = [].toString;
					var arrayJoin = [].join;

					if (
						fails(function() {
							arrayToString.call({});
						})
					) {
						arrayToString = function toString() {
							return arrayJoin.call(this);
						};
					}

					// `%TypedArray%.prototype.toString` method
					// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring
					ArrayBufferViewCore.exportProto(
						'toString',
						arrayToString,
						(Uint8ArrayPrototype || {}).toString != arrayToString
					);
				},
				{
					'../internals/array-buffer-view-core': 38,
					'../internals/fails': 61,
					'../internals/global': 65
				}
			],
			151: [
				function(_dereq_, module, exports) {
					var typedArrayConstructor = _dereq_(
						'../internals/typed-array-constructor'
					);

					// `Uint32Array` constructor
					// https://tc39.github.io/ecma262/#sec-typedarray-objects
					typedArrayConstructor('Uint32', 4, function(init) {
						return function Uint32Array(data, byteOffset, length) {
							return init(this, data, byteOffset, length);
						};
					});
				},
				{ '../internals/typed-array-constructor': 118 }
			],
			152: [
				function(_dereq_, module, exports) {
					module.exports = {
						CssSelectorParser: _dereq_('./lib/css-selector-parser.js')
							.CssSelectorParser
					};
				},
				{ './lib/css-selector-parser.js': 153 }
			],
			153: [
				function(_dereq_, module, exports) {
					function CssSelectorParser() {
						this.pseudos = {};
						this.attrEqualityMods = {};
						this.ruleNestingOperators = {};
						this.substitutesEnabled = false;
					}

					CssSelectorParser.prototype.registerSelectorPseudos = function(name) {
						for (var j = 0, len = arguments.length; j < len; j++) {
							name = arguments[j];
							this.pseudos[name] = 'selector';
						}
						return this;
					};

					CssSelectorParser.prototype.unregisterSelectorPseudos = function(
						name
					) {
						for (var j = 0, len = arguments.length; j < len; j++) {
							name = arguments[j];
							delete this.pseudos[name];
						}
						return this;
					};

					CssSelectorParser.prototype.registerNumericPseudos = function(name) {
						for (var j = 0, len = arguments.length; j < len; j++) {
							name = arguments[j];
							this.pseudos[name] = 'numeric';
						}
						return this;
					};

					CssSelectorParser.prototype.unregisterNumericPseudos = function(
						name
					) {
						for (var j = 0, len = arguments.length; j < len; j++) {
							name = arguments[j];
							delete this.pseudos[name];
						}
						return this;
					};

					CssSelectorParser.prototype.registerNestingOperators = function(
						operator
					) {
						for (var j = 0, len = arguments.length; j < len; j++) {
							operator = arguments[j];
							this.ruleNestingOperators[operator] = true;
						}
						return this;
					};

					CssSelectorParser.prototype.unregisterNestingOperators = function(
						operator
					) {
						for (var j = 0, len = arguments.length; j < len; j++) {
							operator = arguments[j];
							delete this.ruleNestingOperators[operator];
						}
						return this;
					};

					CssSelectorParser.prototype.registerAttrEqualityMods = function(mod) {
						for (var j = 0, len = arguments.length; j < len; j++) {
							mod = arguments[j];
							this.attrEqualityMods[mod] = true;
						}
						return this;
					};

					CssSelectorParser.prototype.unregisterAttrEqualityMods = function(
						mod
					) {
						for (var j = 0, len = arguments.length; j < len; j++) {
							mod = arguments[j];
							delete this.attrEqualityMods[mod];
						}
						return this;
					};

					CssSelectorParser.prototype.enableSubstitutes = function() {
						this.substitutesEnabled = true;
						return this;
					};

					CssSelectorParser.prototype.disableSubstitutes = function() {
						this.substitutesEnabled = false;
						return this;
					};

					function isIdentStart(c) {
						return (
							(c >= 'a' && c <= 'z') ||
							(c >= 'A' && c <= 'Z') ||
							c === '-' ||
							c === '_'
						);
					}

					function isIdent(c) {
						return (
							(c >= 'a' && c <= 'z') ||
							(c >= 'A' && c <= 'Z') ||
							(c >= '0' && c <= '9') ||
							c === '-' ||
							c === '_'
						);
					}

					function isHex(c) {
						return (
							(c >= 'a' && c <= 'f') ||
							(c >= 'A' && c <= 'F') ||
							(c >= '0' && c <= '9')
						);
					}

					function isDecimal(c) {
						return c >= '0' && c <= '9';
					}

					function isAttrMatchOperator(chr) {
						return (
							chr === '=' ||
							chr === '^' ||
							chr === '$' ||
							chr === '*' ||
							chr === '~'
						);
					}

					var identSpecialChars = {
						'!': true,
						'"': true,
						'#': true,
						$: true,
						'%': true,
						'&': true,
						"'": true,
						'(': true,
						')': true,
						'*': true,
						'+': true,
						',': true,
						'.': true,
						'/': true,
						';': true,
						'<': true,
						'=': true,
						'>': true,
						'?': true,
						'@': true,
						'[': true,
						'\\': true,
						']': true,
						'^': true,
						'`': true,
						'{': true,
						'|': true,
						'}': true,
						'~': true
					};

					var strReplacementsRev = {
						'\n': '\\n',
						'\r': '\\r',
						'\t': '\\t',
						'\f': '\\f',
						'\v': '\\v'
					};

					var singleQuoteEscapeChars = {
						n: '\n',
						r: '\r',
						t: '\t',
						f: '\f',
						'\\': '\\',
						"'": "'"
					};

					var doubleQuotesEscapeChars = {
						n: '\n',
						r: '\r',
						t: '\t',
						f: '\f',
						'\\': '\\',
						'"': '"'
					};

					function ParseContext(
						str,
						pos,
						pseudos,
						attrEqualityMods,
						ruleNestingOperators,
						substitutesEnabled
					) {
						var chr, getIdent, getStr, l, skipWhitespace;
						l = str.length;
						chr = null;
						getStr = function(quote, escapeTable) {
							var esc, hex, result;
							result = '';
							pos++;
							chr = str.charAt(pos);
							while (pos < l) {
								if (chr === quote) {
									pos++;
									return result;
								} else if (chr === '\\') {
									pos++;
									chr = str.charAt(pos);
									if (chr === quote) {
										result += quote;
									} else if ((esc = escapeTable[chr])) {
										result += esc;
									} else if (isHex(chr)) {
										hex = chr;
										pos++;
										chr = str.charAt(pos);
										while (isHex(chr)) {
											hex += chr;
											pos++;
											chr = str.charAt(pos);
										}
										if (chr === ' ') {
											pos++;
											chr = str.charAt(pos);
										}
										result += String.fromCharCode(parseInt(hex, 16));
										continue;
									} else {
										result += chr;
									}
								} else {
									result += chr;
								}
								pos++;
								chr = str.charAt(pos);
							}
							return result;
						};
						getIdent = function() {
							var result = '';
							chr = str.charAt(pos);
							while (pos < l) {
								if (isIdent(chr)) {
									result += chr;
								} else if (chr === '\\') {
									pos++;
									if (pos >= l) {
										throw Error('Expected symbol but end of file reached.');
									}
									chr = str.charAt(pos);
									if (identSpecialChars[chr]) {
										result += chr;
									} else if (isHex(chr)) {
										var hex = chr;
										pos++;
										chr = str.charAt(pos);
										while (isHex(chr)) {
											hex += chr;
											pos++;
											chr = str.charAt(pos);
										}
										if (chr === ' ') {
											pos++;
											chr = str.charAt(pos);
										}
										result += String.fromCharCode(parseInt(hex, 16));
										continue;
									} else {
										result += chr;
									}
								} else {
									return result;
								}
								pos++;
								chr = str.charAt(pos);
							}
							return result;
						};
						skipWhitespace = function() {
							chr = str.charAt(pos);
							var result = false;
							while (
								chr === ' ' ||
								chr === '\t' ||
								chr === '\n' ||
								chr === '\r' ||
								chr === '\f'
							) {
								result = true;
								pos++;
								chr = str.charAt(pos);
							}
							return result;
						};
						this.parse = function() {
							var res = this.parseSelector();
							if (pos < l) {
								throw Error(
									'Rule expected but "' + str.charAt(pos) + '" found.'
								);
							}
							return res;
						};
						this.parseSelector = function() {
							var res;
							var selector = (res = this.parseSingleSelector());
							chr = str.charAt(pos);
							while (chr === ',') {
								pos++;
								skipWhitespace();
								if (res.type !== 'selectors') {
									res = {
										type: 'selectors',
										selectors: [selector]
									};
								}
								selector = this.parseSingleSelector();
								if (!selector) {
									throw Error('Rule expected after ",".');
								}
								res.selectors.push(selector);
							}
							return res;
						};

						this.parseSingleSelector = function() {
							skipWhitespace();
							var selector = {
								type: 'ruleSet'
							};
							var rule = this.parseRule();
							if (!rule) {
								return null;
							}
							var currentRule = selector;
							while (rule) {
								rule.type = 'rule';
								currentRule.rule = rule;
								currentRule = rule;
								skipWhitespace();
								chr = str.charAt(pos);
								if (pos >= l || chr === ',' || chr === ')') {
									break;
								}
								if (ruleNestingOperators[chr]) {
									var op = chr;
									pos++;
									skipWhitespace();
									rule = this.parseRule();
									if (!rule) {
										throw Error('Rule expected after "' + op + '".');
									}
									rule.nestingOperator = op;
								} else {
									rule = this.parseRule();
									if (rule) {
										rule.nestingOperator = null;
									}
								}
							}
							return selector;
						};

						this.parseRule = function() {
							var rule = null;
							while (pos < l) {
								chr = str.charAt(pos);
								if (chr === '*') {
									pos++;
									(rule = rule || {}).tagName = '*';
								} else if (isIdentStart(chr) || chr === '\\') {
									(rule = rule || {}).tagName = getIdent();
								} else if (chr === '.') {
									pos++;
									rule = rule || {};
									(rule.classNames = rule.classNames || []).push(getIdent());
								} else if (chr === '#') {
									pos++;
									(rule = rule || {}).id = getIdent();
								} else if (chr === '[') {
									pos++;
									skipWhitespace();
									var attr = {
										name: getIdent()
									};
									skipWhitespace();
									if (chr === ']') {
										pos++;
									} else {
										var operator = '';
										if (attrEqualityMods[chr]) {
											operator = chr;
											pos++;
											chr = str.charAt(pos);
										}
										if (pos >= l) {
											throw Error('Expected "=" but end of file reached.');
										}
										if (chr !== '=') {
											throw Error('Expected "=" but "' + chr + '" found.');
										}
										attr.operator = operator + '=';
										pos++;
										skipWhitespace();
										var attrValue = '';
										attr.valueType = 'string';
										if (chr === '"') {
											attrValue = getStr('"', doubleQuotesEscapeChars);
										} else if (chr === "'") {
											attrValue = getStr("'", singleQuoteEscapeChars);
										} else if (substitutesEnabled && chr === '$') {
											pos++;
											attrValue = getIdent();
											attr.valueType = 'substitute';
										} else {
											while (pos < l) {
												if (chr === ']') {
													break;
												}
												attrValue += chr;
												pos++;
												chr = str.charAt(pos);
											}
											attrValue = attrValue.trim();
										}
										skipWhitespace();
										if (pos >= l) {
											throw Error('Expected "]" but end of file reached.');
										}
										if (chr !== ']') {
											throw Error('Expected "]" but "' + chr + '" found.');
										}
										pos++;
										attr.value = attrValue;
									}
									rule = rule || {};
									(rule.attrs = rule.attrs || []).push(attr);
								} else if (chr === ':') {
									pos++;
									var pseudoName = getIdent();
									var pseudo = {
										name: pseudoName
									};
									if (chr === '(') {
										pos++;
										var value = '';
										skipWhitespace();
										if (pseudos[pseudoName] === 'selector') {
											pseudo.valueType = 'selector';
											value = this.parseSelector();
										} else {
											pseudo.valueType = pseudos[pseudoName] || 'string';
											if (chr === '"') {
												value = getStr('"', doubleQuotesEscapeChars);
											} else if (chr === "'") {
												value = getStr("'", singleQuoteEscapeChars);
											} else if (substitutesEnabled && chr === '$') {
												pos++;
												value = getIdent();
												pseudo.valueType = 'substitute';
											} else {
												while (pos < l) {
													if (chr === ')') {
														break;
													}
													value += chr;
													pos++;
													chr = str.charAt(pos);
												}
												value = value.trim();
											}
											skipWhitespace();
										}
										if (pos >= l) {
											throw Error('Expected ")" but end of file reached.');
										}
										if (chr !== ')') {
											throw Error('Expected ")" but "' + chr + '" found.');
										}
										pos++;
										pseudo.value = value;
									}
									rule = rule || {};
									(rule.pseudos = rule.pseudos || []).push(pseudo);
								} else {
									break;
								}
							}
							return rule;
						};
						return this;
					}

					CssSelectorParser.prototype.parse = function(str) {
						var context = new ParseContext(
							str,
							0,
							this.pseudos,
							this.attrEqualityMods,
							this.ruleNestingOperators,
							this.substitutesEnabled
						);
						return context.parse();
					};

					CssSelectorParser.prototype.escapeIdentifier = function(s) {
						var result = '';
						var i = 0;
						var len = s.length;
						while (i < len) {
							var chr = s.charAt(i);
							if (identSpecialChars[chr]) {
								result += '\\' + chr;
							} else {
								if (
									!(
										chr === '_' ||
										chr === '-' ||
										(chr >= 'A' && chr <= 'Z') ||
										(chr >= 'a' && chr <= 'z') ||
										(i !== 0 && chr >= '0' && chr <= '9')
									)
								) {
									var charCode = chr.charCodeAt(0);
									if ((charCode & 0xf800) === 0xd800) {
										var extraCharCode = s.charCodeAt(i++);
										if (
											(charCode & 0xfc00) !== 0xd800 ||
											(extraCharCode & 0xfc00) !== 0xdc00
										) {
											throw Error('UCS-2(decode): illegal sequence');
										}
										charCode =
											((charCode & 0x3ff) << 10) +
											(extraCharCode & 0x3ff) +
											0x10000;
									}
									result += '\\' + charCode.toString(16) + ' ';
								} else {
									result += chr;
								}
							}
							i++;
						}
						return result;
					};

					CssSelectorParser.prototype.escapeStr = function(s) {
						var result = '';
						var i = 0;
						var len = s.length;
						var chr, replacement;
						while (i < len) {
							chr = s.charAt(i);
							if (chr === '"') {
								chr = '\\"';
							} else if (chr === '\\') {
								chr = '\\\\';
							} else if ((replacement = strReplacementsRev[chr])) {
								chr = replacement;
							}
							result += chr;
							i++;
						}
						return '"' + result + '"';
					};

					CssSelectorParser.prototype.render = function(path) {
						return this._renderEntity(path).trim();
					};

					CssSelectorParser.prototype._renderEntity = function(entity) {
						var currentEntity, parts, res;
						res = '';
						switch (entity.type) {
							case 'ruleSet':
								currentEntity = entity.rule;
								parts = [];
								while (currentEntity) {
									if (currentEntity.nestingOperator) {
										parts.push(currentEntity.nestingOperator);
									}
									parts.push(this._renderEntity(currentEntity));
									currentEntity = currentEntity.rule;
								}
								res = parts.join(' ');
								break;
							case 'selectors':
								res = entity.selectors.map(this._renderEntity, this).join(', ');
								break;
							case 'rule':
								if (entity.tagName) {
									if (entity.tagName === '*') {
										res = '*';
									} else {
										res = this.escapeIdentifier(entity.tagName);
									}
								}
								if (entity.id) {
									res += '#' + this.escapeIdentifier(entity.id);
								}
								if (entity.classNames) {
									res += entity.classNames
										.map(function(cn) {
											return '.' + this.escapeIdentifier(cn);
										}, this)
										.join('');
								}
								if (entity.attrs) {
									res += entity.attrs
										.map(function(attr) {
											if (attr.operator) {
												if (attr.valueType === 'substitute') {
													return (
														'[' +
														this.escapeIdentifier(attr.name) +
														attr.operator +
														'$' +
														attr.value +
														']'
													);
												} else {
													return (
														'[' +
														this.escapeIdentifier(attr.name) +
														attr.operator +
														this.escapeStr(attr.value) +
														']'
													);
												}
											} else {
												return '[' + this.escapeIdentifier(attr.name) + ']';
											}
										}, this)
										.join('');
								}
								if (entity.pseudos) {
									res += entity.pseudos
										.map(function(pseudo) {
											if (pseudo.valueType) {
												if (pseudo.valueType === 'selector') {
													return (
														':' +
														this.escapeIdentifier(pseudo.name) +
														'(' +
														this._renderEntity(pseudo.value) +
														')'
													);
												} else if (pseudo.valueType === 'substitute') {
													return (
														':' +
														this.escapeIdentifier(pseudo.name) +
														'($' +
														pseudo.value +
														')'
													);
												} else if (pseudo.valueType === 'numeric') {
													return (
														':' +
														this.escapeIdentifier(pseudo.name) +
														'(' +
														pseudo.value +
														')'
													);
												} else {
													return (
														':' +
														this.escapeIdentifier(pseudo.name) +
														'(' +
														this.escapeIdentifier(pseudo.value) +
														')'
													);
												}
											} else {
												return ':' + this.escapeIdentifier(pseudo.name);
											}
										}, this)
										.join('');
								}
								break;
							default:
								throw Error('Unknown entity type: "' + entity.type(+'".'));
						}
						return res;
					};

					exports.CssSelectorParser = CssSelectorParser;
				},
				{}
			],
			154: [
				function(_dereq_, module, exports) {
					'use strict';

					var isValue = _dereq_('type/value/is'),
						isPlainFunction = _dereq_('type/plain-function/is'),
						assign = _dereq_('es5-ext/object/assign'),
						normalizeOpts = _dereq_('es5-ext/object/normalize-options'),
						contains = _dereq_('es5-ext/string/#/contains');

					var d = (module.exports = function(dscr, value /*, options*/) {
						var c, e, w, options, desc;
						if (arguments.length < 2 || typeof dscr !== 'string') {
							options = value;
							value = dscr;
							dscr = null;
						} else {
							options = arguments[2];
						}
						if (isValue(dscr)) {
							c = contains.call(dscr, 'c');
							e = contains.call(dscr, 'e');
							w = contains.call(dscr, 'w');
						} else {
							c = w = true;
							e = false;
						}

						desc = {
							value: value,
							configurable: c,
							enumerable: e,
							writable: w
						};
						return !options ? desc : assign(normalizeOpts(options), desc);
					});

					d.gs = function(dscr, get, set /*, options*/) {
						var c, e, options, desc;
						if (typeof dscr !== 'string') {
							options = set;
							set = get;
							get = dscr;
							dscr = null;
						} else {
							options = arguments[3];
						}
						if (!isValue(get)) {
							get = undefined;
						} else if (!isPlainFunction(get)) {
							options = get;
							get = set = undefined;
						} else if (!isValue(set)) {
							set = undefined;
						} else if (!isPlainFunction(set)) {
							options = set;
							set = undefined;
						}
						if (isValue(dscr)) {
							c = contains.call(dscr, 'c');
							e = contains.call(dscr, 'e');
						} else {
							c = true;
							e = false;
						}

						desc = { get: get, set: set, configurable: c, enumerable: e };
						return !options ? desc : assign(normalizeOpts(options), desc);
					};
				},
				{
					'es5-ext/object/assign': 175,
					'es5-ext/object/normalize-options': 187,
					'es5-ext/string/#/contains': 194,
					'type/plain-function/is': 240,
					'type/value/is': 242
				}
			],
			155: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = function() {
						// https://mths.be/emoji
						return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
					};
				},
				{}
			],
			156: [
				function(_dereq_, module, exports) {
					'use strict';

					var numberIsNaN = _dereq_('../../number/is-nan'),
						toPosInt = _dereq_('../../number/to-pos-integer'),
						value = _dereq_('../../object/valid-value'),
						indexOf = Array.prototype.indexOf,
						objHasOwnProperty = Object.prototype.hasOwnProperty,
						abs = Math.abs,
						floor = Math.floor;

					module.exports = function(searchElement /*, fromIndex*/) {
						var i, length, fromIndex, val;
						if (!numberIsNaN(searchElement))
							return indexOf.apply(this, arguments);

						length = toPosInt(value(this).length);
						fromIndex = arguments[1];
						if (isNaN(fromIndex)) fromIndex = 0;
						else if (fromIndex >= 0) fromIndex = floor(fromIndex);
						else fromIndex = toPosInt(this.length) - floor(abs(fromIndex));

						for (i = fromIndex; i < length; ++i) {
							if (objHasOwnProperty.call(this, i)) {
								val = this[i];
								if (numberIsNaN(val)) return i; // Jslint: ignore
							}
						}
						return -1;
					};
				},
				{
					'../../number/is-nan': 169,
					'../../number/to-pos-integer': 173,
					'../../object/valid-value': 190
				}
			],
			157: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = _dereq_('./is-implemented')()
						? Array.from
						: _dereq_('./shim');
				},
				{ './is-implemented': 158, './shim': 159 }
			],
			158: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = function() {
						var from = Array.from,
							arr,
							result;
						if (typeof from !== 'function') return false;
						arr = ['raz', 'dwa'];
						result = from(arr);
						return Boolean(result && result !== arr && result[1] === 'dwa');
					};
				},
				{}
			],
			159: [
				function(_dereq_, module, exports) {
					'use strict';

					var iteratorSymbol = _dereq_('es6-symbol').iterator,
						isArguments = _dereq_('../../function/is-arguments'),
						isFunction = _dereq_('../../function/is-function'),
						toPosInt = _dereq_('../../number/to-pos-integer'),
						callable = _dereq_('../../object/valid-callable'),
						validValue = _dereq_('../../object/valid-value'),
						isValue = _dereq_('../../object/is-value'),
						isString = _dereq_('../../string/is-string'),
						isArray = Array.isArray,
						call = Function.prototype.call,
						desc = {
							configurable: true,
							enumerable: true,
							writable: true,
							value: null
						},
						defineProperty = Object.defineProperty;

					// eslint-disable-next-line complexity, max-lines-per-function
					module.exports = function(arrayLike /*, mapFn, thisArg*/) {
						var mapFn = arguments[1],
							thisArg = arguments[2],
							Context,
							i,
							j,
							arr,
							length,
							code,
							iterator,
							result,
							getIterator,
							value;

						arrayLike = Object(validValue(arrayLike));

						if (isValue(mapFn)) callable(mapFn);
						if (!this || this === Array || !isFunction(this)) {
							// Result: Plain array
							if (!mapFn) {
								if (isArguments(arrayLike)) {
									// Source: Arguments
									length = arrayLike.length;
									if (length !== 1) return Array.apply(null, arrayLike);
									arr = new Array(1);
									arr[0] = arrayLike[0];
									return arr;
								}
								if (isArray(arrayLike)) {
									// Source: Array
									arr = new Array((length = arrayLike.length));
									for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
									return arr;
								}
							}
							arr = [];
						} else {
							// Result: Non plain array
							Context = this;
						}

						if (!isArray(arrayLike)) {
							if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
								// Source: Iterator
								iterator = callable(getIterator).call(arrayLike);
								if (Context) arr = new Context();
								result = iterator.next();
								i = 0;
								while (!result.done) {
									value = mapFn
										? call.call(mapFn, thisArg, result.value, i)
										: result.value;
									if (Context) {
										desc.value = value;
										defineProperty(arr, i, desc);
									} else {
										arr[i] = value;
									}
									result = iterator.next();
									++i;
								}
								length = i;
							} else if (isString(arrayLike)) {
								// Source: String
								length = arrayLike.length;
								if (Context) arr = new Context();
								for (i = 0, j = 0; i < length; ++i) {
									value = arrayLike[i];
									if (i + 1 < length) {
										code = value.charCodeAt(0);
										// eslint-disable-next-line max-depth
										if (code >= 0xd800 && code <= 0xdbff)
											value += arrayLike[++i];
									}
									value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
									if (Context) {
										desc.value = value;
										defineProperty(arr, j, desc);
									} else {
										arr[j] = value;
									}
									++j;
								}
								length = j;
							}
						}
						if (length === undefined) {
							// Source: array or array-like
							length = toPosInt(arrayLike.length);
							if (Context) arr = new Context(length);
							for (i = 0; i < length; ++i) {
								value = mapFn
									? call.call(mapFn, thisArg, arrayLike[i], i)
									: arrayLike[i];
								if (Context) {
									desc.value = value;
									defineProperty(arr, i, desc);
								} else {
									arr[i] = value;
								}
							}
						}
						if (Context) {
							desc.value = null;
							arr.length = length;
						}
						return arr;
					};
				},
				{
					'../../function/is-arguments': 163,
					'../../function/is-function': 164,
					'../../number/to-pos-integer': 173,
					'../../object/is-value': 181,
					'../../object/valid-callable': 189,
					'../../object/valid-value': 190,
					'../../string/is-string': 197,
					'es6-symbol': 200
				}
			],
			160: [
				function(_dereq_, module, exports) {
					'use strict';

					var from = _dereq_('./from'),
						isArray = Array.isArray;

					module.exports = function(arrayLike) {
						return isArray(arrayLike) ? arrayLike : from(arrayLike);
					};
				},
				{ './from': 157 }
			],
			161: [
				function(_dereq_, module, exports) {
					'use strict';

					var assign = _dereq_('../object/assign'),
						isObject = _dereq_('../object/is-object'),
						isValue = _dereq_('../object/is-value'),
						captureStackTrace = Error.captureStackTrace;

					module.exports = function(message /*, code, ext*/) {
						var err = new Error(message),
							code = arguments[1],
							ext = arguments[2];
						if (!isValue(ext)) {
							if (isObject(code)) {
								ext = code;
								code = null;
							}
						}
						if (isValue(ext)) assign(err, ext);
						if (isValue(code)) err.code = code;
						if (captureStackTrace) captureStackTrace(err, module.exports);
						return err;
					};
				},
				{
					'../object/assign': 175,
					'../object/is-object': 180,
					'../object/is-value': 181
				}
			],
			162: [
				function(_dereq_, module, exports) {
					'use strict';

					var toPosInt = _dereq_('../number/to-pos-integer');

					var test = function(arg1, arg2) {
						return arg2;
					};

					var desc, defineProperty, generate, mixin;

					try {
						Object.defineProperty(test, 'length', {
							configurable: true,
							writable: false,
							enumerable: false,
							value: 1
						});
					} catch (ignore) {}

					if (test.length === 1) {
						// ES6
						desc = { configurable: true, writable: false, enumerable: false };
						defineProperty = Object.defineProperty;
						module.exports = function(fn, length) {
							length = toPosInt(length);
							if (fn.length === length) return fn;
							desc.value = length;
							return defineProperty(fn, 'length', desc);
						};
					} else {
						mixin = _dereq_('../object/mixin');
						generate = (function() {
							var cache = [];
							return function(length) {
								var args,
									i = 0;
								if (cache[length]) return cache[length];
								args = [];
								while (length--) args.push('a' + (++i).toString(36));
								// eslint-disable-next-line no-new-func
								return new Function(
									'fn',
									'return function (' +
										args.join(', ') +
										') { return fn.apply(this, arguments); };'
								);
							};
						})();
						module.exports = function(src, length) {
							var target;
							length = toPosInt(length);
							if (src.length === length) return src;
							target = generate(length)(src);
							try {
								mixin(target, src);
							} catch (ignore) {}
							return target;
						};
					}
				},
				{ '../number/to-pos-integer': 173, '../object/mixin': 186 }
			],
			163: [
				function(_dereq_, module, exports) {
					'use strict';

					var objToString = Object.prototype.toString,
						id = objToString.call(
							(function() {
								return arguments;
							})()
						);

					module.exports = function(value) {
						return objToString.call(value) === id;
					};
				},
				{}
			],
			164: [
				function(_dereq_, module, exports) {
					'use strict';

					var objToString = Object.prototype.toString,
						isFunctionStringTag = RegExp.prototype.test.bind(
							/^[object [A-Za-z0-9]*Function]$/
						);

					module.exports = function(value) {
						return (
							typeof value === 'function' &&
							isFunctionStringTag(objToString.call(value))
						);
					};
				},
				{}
			],
			165: [
				function(_dereq_, module, exports) {
					'use strict';

					// eslint-disable-next-line no-empty-function
					module.exports = function() {};
				},
				{}
			],
			166: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = _dereq_('./is-implemented')()
						? Math.sign
						: _dereq_('./shim');
				},
				{ './is-implemented': 167, './shim': 168 }
			],
			167: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = function() {
						var sign = Math.sign;
						if (typeof sign !== 'function') return false;
						return sign(10) === 1 && sign(-20) === -1;
					};
				},
				{}
			],
			168: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = function(value) {
						value = Number(value);
						if (isNaN(value) || value === 0) return value;
						return value > 0 ? 1 : -1;
					};
				},
				{}
			],
			169: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = _dereq_('./is-implemented')()
						? Number.isNaN
						: _dereq_('./shim');
				},
				{ './is-implemented': 170, './shim': 171 }
			],
			170: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = function() {
						var numberIsNaN = Number.isNaN;
						if (typeof numberIsNaN !== 'function') return false;
						return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
					};
				},
				{}
			],
			171: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = function(value) {
						// eslint-disable-next-line no-self-compare
						return value !== value;
					};
				},
				{}
			],
			172: [
				function(_dereq_, module, exports) {
					'use strict';

					var sign = _dereq_('../math/sign'),
						abs = Math.abs,
						floor = Math.floor;

					module.exports = function(value) {
						if (isNaN(value)) return 0;
						value = Number(value);
						if (value === 0 || !isFinite(value)) return value;
						return sign(value) * floor(abs(value));
					};
				},
				{ '../math/sign': 166 }
			],
			173: [
				function(_dereq_, module, exports) {
					'use strict';

					var toInteger = _dereq_('./to-integer'),
						max = Math.max;

					module.exports = function(value) {
						return max(0, toInteger(value));
					};
				},
				{ './to-integer': 172 }
			],
			174: [
				function(_dereq_, module, exports) {
					// Internal method, used by iteration functions.
					// Calls a function for each key-value pair found in object
					// Optionally takes compareFn to iterate object in specific order

					'use strict';

					var callable = _dereq_('./valid-callable'),
						value = _dereq_('./valid-value'),
						bind = Function.prototype.bind,
						call = Function.prototype.call,
						keys = Object.keys,
						objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;

					module.exports = function(method, defVal) {
						return function(obj, cb /*, thisArg, compareFn*/) {
							var list,
								thisArg = arguments[2],
								compareFn = arguments[3];
							obj = Object(value(obj));
							callable(cb);

							list = keys(obj);
							if (compareFn) {
								list.sort(
									typeof compareFn === 'function'
										? bind.call(compareFn, obj)
										: undefined
								);
							}
							if (typeof method !== 'function') method = list[method];
							return call.call(method, list, function(key, index) {
								if (!objPropertyIsEnumerable.call(obj, key)) return defVal;
								return call.call(cb, thisArg, obj[key], key, obj, index);
							});
						};
					};
				},
				{ './valid-callable': 189, './valid-value': 190 }
			],
			175: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = _dereq_('./is-implemented')()
						? Object.assign
						: _dereq_('./shim');
				},
				{ './is-implemented': 176, './shim': 177 }
			],
			176: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = function() {
						var assign = Object.assign,
							obj;
						if (typeof assign !== 'function') return false;
						obj = { foo: 'raz' };
						assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
						return obj.foo + obj.bar + obj.trzy === 'razdwatrzy';
					};
				},
				{}
			],
			177: [
				function(_dereq_, module, exports) {
					'use strict';

					var keys = _dereq_('../keys'),
						value = _dereq_('../valid-value'),
						max = Math.max;

					module.exports = function(dest, src /*, srcn*/) {
						var error,
							i,
							length = max(arguments.length, 2),
							assign;
						dest = Object(value(dest));
						assign = function(key) {
							try {
								dest[key] = src[key];
							} catch (e) {
								if (!error) error = e;
							}
						};
						for (i = 1; i < length; ++i) {
							src = arguments[i];
							keys(src).forEach(assign);
						}
						if (error !== undefined) throw error;
						return dest;
					};
				},
				{ '../keys': 182, '../valid-value': 190 }
			],
			178: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = _dereq_('./_iterate')('forEach');
				},
				{ './_iterate': 174 }
			],
			179: [
				function(_dereq_, module, exports) {
					// Deprecated

					'use strict';

					module.exports = function(obj) {
						return typeof obj === 'function';
					};
				},
				{}
			],
			180: [
				function(_dereq_, module, exports) {
					'use strict';

					var isValue = _dereq_('./is-value');

					var map = { function: true, object: true };

					module.exports = function(value) {
						return (isValue(value) && map[typeof value]) || false;
					};
				},
				{ './is-value': 181 }
			],
			181: [
				function(_dereq_, module, exports) {
					'use strict';

					var _undefined = _dereq_('../function/noop')(); // Support ES3 engines

					module.exports = function(val) {
						return val !== _undefined && val !== null;
					};
				},
				{ '../function/noop': 165 }
			],
			182: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = _dereq_('./is-implemented')()
						? Object.keys
						: _dereq_('./shim');
				},
				{ './is-implemented': 183, './shim': 184 }
			],
			183: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = function() {
						try {
							Object.keys('primitive');
							return true;
						} catch (e) {
							return false;
						}
					};
				},
				{}
			],
			184: [
				function(_dereq_, module, exports) {
					'use strict';

					var isValue = _dereq_('../is-value');

					var keys = Object.keys;

					module.exports = function(object) {
						return keys(isValue(object) ? Object(object) : object);
					};
				},
				{ '../is-value': 181 }
			],
			185: [
				function(_dereq_, module, exports) {
					'use strict';

					var callable = _dereq_('./valid-callable'),
						forEach = _dereq_('./for-each'),
						call = Function.prototype.call;

					module.exports = function(obj, cb /*, thisArg*/) {
						var result = {},
							thisArg = arguments[2];
						callable(cb);
						forEach(obj, function(value, key, targetObj, index) {
							result[key] = call.call(
								cb,
								thisArg,
								value,
								key,
								targetObj,
								index
							);
						});
						return result;
					};
				},
				{ './for-each': 178, './valid-callable': 189 }
			],
			186: [
				function(_dereq_, module, exports) {
					'use strict';

					var value = _dereq_('./valid-value'),
						defineProperty = Object.defineProperty,
						getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
						getOwnPropertyNames = Object.getOwnPropertyNames,
						getOwnPropertySymbols = Object.getOwnPropertySymbols;

					module.exports = function(target, source) {
						var error,
							sourceObject = Object(value(source));
						target = Object(value(target));
						getOwnPropertyNames(sourceObject).forEach(function(name) {
							try {
								defineProperty(
									target,
									name,
									getOwnPropertyDescriptor(source, name)
								);
							} catch (e) {
								error = e;
							}
						});
						if (typeof getOwnPropertySymbols === 'function') {
							getOwnPropertySymbols(sourceObject).forEach(function(symbol) {
								try {
									defineProperty(
										target,
										symbol,
										getOwnPropertyDescriptor(source, symbol)
									);
								} catch (e) {
									error = e;
								}
							});
						}
						if (error !== undefined) throw error;
						return target;
					};
				},
				{ './valid-value': 190 }
			],
			187: [
				function(_dereq_, module, exports) {
					'use strict';

					var isValue = _dereq_('./is-value');

					var forEach = Array.prototype.forEach,
						create = Object.create;

					var process = function(src, obj) {
						var key;
						for (key in src) obj[key] = src[key];
					};

					// eslint-disable-next-line no-unused-vars
					module.exports = function(opts1 /*, options*/) {
						var result = create(null);
						forEach.call(arguments, function(options) {
							if (!isValue(options)) return;
							process(Object(options), result);
						});
						return result;
					};
				},
				{ './is-value': 181 }
			],
			188: [
				function(_dereq_, module, exports) {
					'use strict';

					var forEach = Array.prototype.forEach,
						create = Object.create;

					// eslint-disable-next-line no-unused-vars
					module.exports = function(arg /*, args*/) {
						var set = create(null);
						forEach.call(arguments, function(name) {
							set[name] = true;
						});
						return set;
					};
				},
				{}
			],
			189: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = function(fn) {
						if (typeof fn !== 'function')
							throw new TypeError(fn + ' is not a function');
						return fn;
					};
				},
				{}
			],
			190: [
				function(_dereq_, module, exports) {
					'use strict';

					var isValue = _dereq_('./is-value');

					module.exports = function(value) {
						if (!isValue(value))
							throw new TypeError('Cannot use null or undefined');
						return value;
					};
				},
				{ './is-value': 181 }
			],
			191: [
				function(_dereq_, module, exports) {
					'use strict';

					var ensureValue = _dereq_('./valid-value'),
						stringifiable = _dereq_('./validate-stringifiable');

					module.exports = function(value) {
						return stringifiable(ensureValue(value));
					};
				},
				{ './valid-value': 190, './validate-stringifiable': 192 }
			],
			192: [
				function(_dereq_, module, exports) {
					'use strict';

					var isCallable = _dereq_('./is-callable');

					module.exports = function(stringifiable) {
						try {
							if (stringifiable && isCallable(stringifiable.toString))
								return stringifiable.toString();
							return String(stringifiable);
						} catch (e) {
							throw new TypeError('Passed argument cannot be stringifed');
						}
					};
				},
				{ './is-callable': 179 }
			],
			193: [
				function(_dereq_, module, exports) {
					'use strict';

					var isCallable = _dereq_('./object/is-callable');

					module.exports = function(value) {
						try {
							if (value && isCallable(value.toString)) return value.toString();
							return String(value);
						} catch (e) {
							return '<Non-coercible to string value>';
						}
					};
				},
				{ './object/is-callable': 179 }
			],
			194: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = _dereq_('./is-implemented')()
						? String.prototype.contains
						: _dereq_('./shim');
				},
				{ './is-implemented': 195, './shim': 196 }
			],
			195: [
				function(_dereq_, module, exports) {
					'use strict';

					var str = 'razdwatrzy';

					module.exports = function() {
						if (typeof str.contains !== 'function') return false;
						return (
							str.contains('dwa') === true && str.contains('foo') === false
						);
					};
				},
				{}
			],
			196: [
				function(_dereq_, module, exports) {
					'use strict';

					var indexOf = String.prototype.indexOf;

					module.exports = function(searchString /*, position*/) {
						return indexOf.call(this, searchString, arguments[1]) > -1;
					};
				},
				{}
			],
			197: [
				function(_dereq_, module, exports) {
					'use strict';

					var objToString = Object.prototype.toString,
						id = objToString.call('');

					module.exports = function(value) {
						return (
							typeof value === 'string' ||
							(value &&
								typeof value === 'object' &&
								(value instanceof String || objToString.call(value) === id)) ||
							false
						);
					};
				},
				{}
			],
			198: [
				function(_dereq_, module, exports) {
					'use strict';

					var safeToString = _dereq_('./safe-to-string');

					var reNewLine = /[\n\r\u2028\u2029]/g;

					module.exports = function(value) {
						var string = safeToString(value);
						// Trim if too long
						if (string.length > 100) string = string.slice(0, 99) + '';
						// Replace eventual new lines
						string = string.replace(reNewLine, function(char) {
							return JSON.stringify(char).slice(1, -1);
						});
						return string;
					};
				},
				{ './safe-to-string': 193 }
			],
			199: [
				function(_dereq_, module, exports) {
					(function(process, global) {
						/*!
						 * @overview es6-promise - a tiny implementation of Promises/A+.
						 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
						 * @license   Licensed under MIT license
						 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
						 * @version   v4.2.8+1e68dce6
						 */

						(function(global, factory) {
							typeof exports === 'object' && typeof module !== 'undefined'
								? (module.exports = factory())
								: typeof define === 'function' && define.amd
								? define(factory)
								: (global.ES6Promise = factory());
						})(this, function() {
							'use strict';

							function objectOrFunction(x) {
								var type = typeof x;
								return x !== null && (type === 'object' || type === 'function');
							}

							function isFunction(x) {
								return typeof x === 'function';
							}

							var _isArray = void 0;
							if (Array.isArray) {
								_isArray = Array.isArray;
							} else {
								_isArray = function(x) {
									return Object.prototype.toString.call(x) === '[object Array]';
								};
							}

							var isArray = _isArray;

							var len = 0;
							var vertxNext = void 0;
							var customSchedulerFn = void 0;

							var asap = function asap(callback, arg) {
								queue[len] = callback;
								queue[len + 1] = arg;
								len += 2;
								if (len === 2) {
									// If len is 2, that means that we need to schedule an async flush.
									// If additional callbacks are queued before the queue is flushed, they
									// will be processed by this flush that we are scheduling.
									if (customSchedulerFn) {
										customSchedulerFn(flush);
									} else {
										scheduleFlush();
									}
								}
							};

							function setScheduler(scheduleFn) {
								customSchedulerFn = scheduleFn;
							}

							function setAsap(asapFn) {
								asap = asapFn;
							}

							var browserWindow =
								typeof window !== 'undefined' ? window : undefined;
							var browserGlobal = browserWindow || {};
							var BrowserMutationObserver =
								browserGlobal.MutationObserver ||
								browserGlobal.WebKitMutationObserver;
							var isNode =
								typeof self === 'undefined' &&
								typeof process !== 'undefined' &&
								{}.toString.call(process) === '[object process]';

							// test for web worker but not in IE10
							var isWorker =
								typeof Uint8ClampedArray !== 'undefined' &&
								typeof importScripts !== 'undefined' &&
								typeof MessageChannel !== 'undefined';

							// node
							function useNextTick() {
								// node version 0.10.x displays a deprecation warning when nextTick is used recursively
								// see https://github.com/cujojs/when/issues/410 for details
								return function() {
									return process.nextTick(flush);
								};
							}

							// vertx
							function useVertxTimer() {
								if (typeof vertxNext !== 'undefined') {
									return function() {
										vertxNext(flush);
									};
								}

								return useSetTimeout();
							}

							function useMutationObserver() {
								var iterations = 0;
								var observer = new BrowserMutationObserver(flush);
								var node = document.createTextNode('');
								observer.observe(node, { characterData: true });

								return function() {
									node.data = iterations = ++iterations % 2;
								};
							}

							// web worker
							function useMessageChannel() {
								var channel = new MessageChannel();
								channel.port1.onmessage = flush;
								return function() {
									return channel.port2.postMessage(0);
								};
							}

							function useSetTimeout() {
								// Store setTimeout reference so es6-promise will be unaffected by
								// other code modifying setTimeout (like sinon.useFakeTimers())
								var globalSetTimeout = setTimeout;
								return function() {
									return globalSetTimeout(flush, 1);
								};
							}

							var queue = new Array(1000);
							function flush() {
								for (var i = 0; i < len; i += 2) {
									var callback = queue[i];
									var arg = queue[i + 1];

									callback(arg);

									queue[i] = undefined;
									queue[i + 1] = undefined;
								}

								len = 0;
							}

							function attemptVertx() {
								try {
									var vertx = Function('return this')().require('vertx');
									vertxNext = vertx.runOnLoop || vertx.runOnContext;
									return useVertxTimer();
								} catch (e) {
									return useSetTimeout();
								}
							}

							var scheduleFlush = void 0;
							// Decide what async method to use to triggering processing of queued callbacks:
							if (isNode) {
								scheduleFlush = useNextTick();
							} else if (BrowserMutationObserver) {
								scheduleFlush = useMutationObserver();
							} else if (isWorker) {
								scheduleFlush = useMessageChannel();
							} else if (
								browserWindow === undefined &&
								typeof _dereq_ === 'function'
							) {
								scheduleFlush = attemptVertx();
							} else {
								scheduleFlush = useSetTimeout();
							}

							function then(onFulfillment, onRejection) {
								var parent = this;

								var child = new this.constructor(noop);

								if (child[PROMISE_ID] === undefined) {
									makePromise(child);
								}

								var _state = parent._state;

								if (_state) {
									var callback = arguments[_state - 1];
									asap(function() {
										return invokeCallback(
											_state,
											child,
											callback,
											parent._result
										);
									});
								} else {
									subscribe(parent, child, onFulfillment, onRejection);
								}

								return child;
							}

							/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
							function resolve$1(object) {
								/*jshint validthis:true */
								var Constructor = this;

								if (
									object &&
									typeof object === 'object' &&
									object.constructor === Constructor
								) {
									return object;
								}

								var promise = new Constructor(noop);
								resolve(promise, object);
								return promise;
							}

							var PROMISE_ID = Math.random()
								.toString(36)
								.substring(2);

							function noop() {}

							var PENDING = void 0;
							var FULFILLED = 1;
							var REJECTED = 2;

							function selfFulfillment() {
								return new TypeError(
									'You cannot resolve a promise with itself'
								);
							}

							function cannotReturnOwn() {
								return new TypeError(
									'A promises callback cannot return that same promise.'
								);
							}

							function tryThen(
								then$$1,
								value,
								fulfillmentHandler,
								rejectionHandler
							) {
								try {
									then$$1.call(value, fulfillmentHandler, rejectionHandler);
								} catch (e) {
									return e;
								}
							}

							function handleForeignThenable(promise, thenable, then$$1) {
								asap(function(promise) {
									var sealed = false;
									var error = tryThen(
										then$$1,
										thenable,
										function(value) {
											if (sealed) {
												return;
											}
											sealed = true;
											if (thenable !== value) {
												resolve(promise, value);
											} else {
												fulfill(promise, value);
											}
										},
										function(reason) {
											if (sealed) {
												return;
											}
											sealed = true;

											reject(promise, reason);
										},
										'Settle: ' + (promise._label || ' unknown promise')
									);

									if (!sealed && error) {
										sealed = true;
										reject(promise, error);
									}
								}, promise);
							}

							function handleOwnThenable(promise, thenable) {
								if (thenable._state === FULFILLED) {
									fulfill(promise, thenable._result);
								} else if (thenable._state === REJECTED) {
									reject(promise, thenable._result);
								} else {
									subscribe(
										thenable,
										undefined,
										function(value) {
											return resolve(promise, value);
										},
										function(reason) {
											return reject(promise, reason);
										}
									);
								}
							}

							function handleMaybeThenable(promise, maybeThenable, then$$1) {
								if (
									maybeThenable.constructor === promise.constructor &&
									then$$1 === then &&
									maybeThenable.constructor.resolve === resolve$1
								) {
									handleOwnThenable(promise, maybeThenable);
								} else {
									if (then$$1 === undefined) {
										fulfill(promise, maybeThenable);
									} else if (isFunction(then$$1)) {
										handleForeignThenable(promise, maybeThenable, then$$1);
									} else {
										fulfill(promise, maybeThenable);
									}
								}
							}

							function resolve(promise, value) {
								if (promise === value) {
									reject(promise, selfFulfillment());
								} else if (objectOrFunction(value)) {
									var then$$1 = void 0;
									try {
										then$$1 = value.then;
									} catch (error) {
										reject(promise, error);
										return;
									}
									handleMaybeThenable(promise, value, then$$1);
								} else {
									fulfill(promise, value);
								}
							}

							function publishRejection(promise) {
								if (promise._onerror) {
									promise._onerror(promise._result);
								}

								publish(promise);
							}

							function fulfill(promise, value) {
								if (promise._state !== PENDING) {
									return;
								}

								promise._result = value;
								promise._state = FULFILLED;

								if (promise._subscribers.length !== 0) {
									asap(publish, promise);
								}
							}

							function reject(promise, reason) {
								if (promise._state !== PENDING) {
									return;
								}
								promise._state = REJECTED;
								promise._result = reason;

								asap(publishRejection, promise);
							}

							function subscribe(parent, child, onFulfillment, onRejection) {
								var _subscribers = parent._subscribers;
								var length = _subscribers.length;

								parent._onerror = null;

								_subscribers[length] = child;
								_subscribers[length + FULFILLED] = onFulfillment;
								_subscribers[length + REJECTED] = onRejection;

								if (length === 0 && parent._state) {
									asap(publish, parent);
								}
							}

							function publish(promise) {
								var subscribers = promise._subscribers;
								var settled = promise._state;

								if (subscribers.length === 0) {
									return;
								}

								var child = void 0,
									callback = void 0,
									detail = promise._result;

								for (var i = 0; i < subscribers.length; i += 3) {
									child = subscribers[i];
									callback = subscribers[i + settled];

									if (child) {
										invokeCallback(settled, child, callback, detail);
									} else {
										callback(detail);
									}
								}

								promise._subscribers.length = 0;
							}

							function invokeCallback(settled, promise, callback, detail) {
								var hasCallback = isFunction(callback),
									value = void 0,
									error = void 0,
									succeeded = true;

								if (hasCallback) {
									try {
										value = callback(detail);
									} catch (e) {
										succeeded = false;
										error = e;
									}

									if (promise === value) {
										reject(promise, cannotReturnOwn());
										return;
									}
								} else {
									value = detail;
								}

								if (promise._state !== PENDING) {
									// noop
								} else if (hasCallback && succeeded) {
									resolve(promise, value);
								} else if (succeeded === false) {
									reject(promise, error);
								} else if (settled === FULFILLED) {
									fulfill(promise, value);
								} else if (settled === REJECTED) {
									reject(promise, value);
								}
							}

							function initializePromise(promise, resolver) {
								try {
									resolver(
										function resolvePromise(value) {
											resolve(promise, value);
										},
										function rejectPromise(reason) {
											reject(promise, reason);
										}
									);
								} catch (e) {
									reject(promise, e);
								}
							}

							var id = 0;
							function nextId() {
								return id++;
							}

							function makePromise(promise) {
								promise[PROMISE_ID] = id++;
								promise._state = undefined;
								promise._result = undefined;
								promise._subscribers = [];
							}

							function validationError() {
								return new Error('Array Methods must be provided an Array');
							}

							var Enumerator = (function() {
								function Enumerator(Constructor, input) {
									this._instanceConstructor = Constructor;
									this.promise = new Constructor(noop);

									if (!this.promise[PROMISE_ID]) {
										makePromise(this.promise);
									}

									if (isArray(input)) {
										this.length = input.length;
										this._remaining = input.length;

										this._result = new Array(this.length);

										if (this.length === 0) {
											fulfill(this.promise, this._result);
										} else {
											this.length = this.length || 0;
											this._enumerate(input);
											if (this._remaining === 0) {
												fulfill(this.promise, this._result);
											}
										}
									} else {
										reject(this.promise, validationError());
									}
								}

								Enumerator.prototype._enumerate = function _enumerate(input) {
									for (
										var i = 0;
										this._state === PENDING && i < input.length;
										i++
									) {
										this._eachEntry(input[i], i);
									}
								};

								Enumerator.prototype._eachEntry = function _eachEntry(
									entry,
									i
								) {
									var c = this._instanceConstructor;
									var resolve$$1 = c.resolve;

									if (resolve$$1 === resolve$1) {
										var _then = void 0;
										var error = void 0;
										var didError = false;
										try {
											_then = entry.then;
										} catch (e) {
											didError = true;
											error = e;
										}

										if (_then === then && entry._state !== PENDING) {
											this._settledAt(entry._state, i, entry._result);
										} else if (typeof _then !== 'function') {
											this._remaining--;
											this._result[i] = entry;
										} else if (c === Promise$1) {
											var promise = new c(noop);
											if (didError) {
												reject(promise, error);
											} else {
												handleMaybeThenable(promise, entry, _then);
											}
											this._willSettleAt(promise, i);
										} else {
											this._willSettleAt(
												new c(function(resolve$$1) {
													return resolve$$1(entry);
												}),
												i
											);
										}
									} else {
										this._willSettleAt(resolve$$1(entry), i);
									}
								};

								Enumerator.prototype._settledAt = function _settledAt(
									state,
									i,
									value
								) {
									var promise = this.promise;

									if (promise._state === PENDING) {
										this._remaining--;

										if (state === REJECTED) {
											reject(promise, value);
										} else {
											this._result[i] = value;
										}
									}

									if (this._remaining === 0) {
										fulfill(promise, this._result);
									}
								};

								Enumerator.prototype._willSettleAt = function _willSettleAt(
									promise,
									i
								) {
									var enumerator = this;

									subscribe(
										promise,
										undefined,
										function(value) {
											return enumerator._settledAt(FULFILLED, i, value);
										},
										function(reason) {
											return enumerator._settledAt(REJECTED, i, reason);
										}
									);
								};

								return Enumerator;
							})();

							/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
							function all(entries) {
								return new Enumerator(this, entries).promise;
							}

							/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
							function race(entries) {
								/*jshint validthis:true */
								var Constructor = this;

								if (!isArray(entries)) {
									return new Constructor(function(_, reject) {
										return reject(
											new TypeError('You must pass an array to race.')
										);
									});
								} else {
									return new Constructor(function(resolve, reject) {
										var length = entries.length;
										for (var i = 0; i < length; i++) {
											Constructor.resolve(entries[i]).then(resolve, reject);
										}
									});
								}
							}

							/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
							function reject$1(reason) {
								/*jshint validthis:true */
								var Constructor = this;
								var promise = new Constructor(noop);
								reject(promise, reason);
								return promise;
							}

							function needsResolver() {
								throw new TypeError(
									'You must pass a resolver function as the first argument to the promise constructor'
								);
							}

							function needsNew() {
								throw new TypeError(
									"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function."
								);
							}

							/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

							var Promise$1 = (function() {
								function Promise(resolver) {
									this[PROMISE_ID] = nextId();
									this._result = this._state = undefined;
									this._subscribers = [];

									if (noop !== resolver) {
										typeof resolver !== 'function' && needsResolver();
										this instanceof Promise
											? initializePromise(this, resolver)
											: needsNew();
									}
								}

								/**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

								/**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */

								Promise.prototype.catch = function _catch(onRejection) {
									return this.then(null, onRejection);
								};

								/**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */

								Promise.prototype.finally = function _finally(callback) {
									var promise = this;
									var constructor = promise.constructor;

									if (isFunction(callback)) {
										return promise.then(
											function(value) {
												return constructor.resolve(callback()).then(function() {
													return value;
												});
											},
											function(reason) {
												return constructor.resolve(callback()).then(function() {
													throw reason;
												});
											}
										);
									}

									return promise.then(callback, callback);
								};

								return Promise;
							})();

							Promise$1.prototype.then = then;
							Promise$1.all = all;
							Promise$1.race = race;
							Promise$1.resolve = resolve$1;
							Promise$1.reject = reject$1;
							Promise$1._setScheduler = setScheduler;
							Promise$1._setAsap = setAsap;
							Promise$1._asap = asap;

							/*global self*/
							function polyfill() {
								var local = void 0;

								if (typeof global !== 'undefined') {
									local = global;
								} else if (typeof self !== 'undefined') {
									local = self;
								} else {
									try {
										local = Function('return this')();
									} catch (e) {
										throw new Error(
											'polyfill failed because global object is unavailable in this environment'
										);
									}
								}

								var P = local.Promise;

								if (P) {
									var promiseToString = null;
									try {
										promiseToString = Object.prototype.toString.call(
											P.resolve()
										);
									} catch (e) {
										// silently ignored
									}

									if (promiseToString === '[object Promise]' && !P.cast) {
										return;
									}
								}

								local.Promise = Promise$1;
							}

							// Strange compat..
							Promise$1.polyfill = polyfill;
							Promise$1.Promise = Promise$1;

							return Promise$1;
						});
					}.call(
						this,
						_dereq_('_process'),
						typeof global !== 'undefined'
							? global
							: typeof self !== 'undefined'
							? self
							: typeof window !== 'undefined'
							? window
							: {}
					));
				},
				{ _process: 234 }
			],
			200: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = _dereq_('./is-implemented')()
						? _dereq_('ext/global-this').Symbol
						: _dereq_('./polyfill');
				},
				{ './is-implemented': 201, './polyfill': 206, 'ext/global-this': 210 }
			],
			201: [
				function(_dereq_, module, exports) {
					'use strict';

					var global = _dereq_('ext/global-this'),
						validTypes = { object: true, symbol: true };

					module.exports = function() {
						var Symbol = global.Symbol;
						var symbol;
						if (typeof Symbol !== 'function') return false;
						symbol = Symbol('test symbol');
						try {
							String(symbol);
						} catch (e) {
							return false;
						}

						// Return 'true' also for polyfills
						if (!validTypes[typeof Symbol.iterator]) return false;
						if (!validTypes[typeof Symbol.toPrimitive]) return false;
						if (!validTypes[typeof Symbol.toStringTag]) return false;

						return true;
					};
				},
				{ 'ext/global-this': 210 }
			],
			202: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = function(value) {
						if (!value) return false;
						if (typeof value === 'symbol') return true;
						if (!value.constructor) return false;
						if (value.constructor.name !== 'Symbol') return false;
						return value[value.constructor.toStringTag] === 'Symbol';
					};
				},
				{}
			],
			203: [
				function(_dereq_, module, exports) {
					'use strict';

					var d = _dereq_('d');

					var create = Object.create,
						defineProperty = Object.defineProperty,
						objPrototype = Object.prototype;

					var created = create(null);
					module.exports = function(desc) {
						var postfix = 0,
							name,
							ie11BugWorkaround;
						while (created[desc + (postfix || '')]) ++postfix;
						desc += postfix || '';
						created[desc] = true;
						name = '@@' + desc;
						defineProperty(
							objPrototype,
							name,
							d.gs(null, function(value) {
								// For IE11 issue see:
								// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
								//    ie11-broken-getters-on-dom-objects
								// https://github.com/medikoo/es6-symbol/issues/12
								if (ie11BugWorkaround) return;
								ie11BugWorkaround = true;
								defineProperty(this, name, d(value));
								ie11BugWorkaround = false;
							})
						);
						return name;
					};
				},
				{ d: 154 }
			],
			204: [
				function(_dereq_, module, exports) {
					'use strict';

					var d = _dereq_('d'),
						NativeSymbol = _dereq_('ext/global-this').Symbol;

					module.exports = function(SymbolPolyfill) {
						return Object.defineProperties(SymbolPolyfill, {
							// To ensure proper interoperability with other native functions (e.g. Array.from)
							// fallback to eventual native implementation of given symbol
							hasInstance: d(
								'',
								(NativeSymbol && NativeSymbol.hasInstance) ||
									SymbolPolyfill('hasInstance')
							),
							isConcatSpreadable: d(
								'',
								(NativeSymbol && NativeSymbol.isConcatSpreadable) ||
									SymbolPolyfill('isConcatSpreadable')
							),
							iterator: d(
								'',
								(NativeSymbol && NativeSymbol.iterator) ||
									SymbolPolyfill('iterator')
							),
							match: d(
								'',
								(NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')
							),
							replace: d(
								'',
								(NativeSymbol && NativeSymbol.replace) ||
									SymbolPolyfill('replace')
							),
							search: d(
								'',
								(NativeSymbol && NativeSymbol.search) ||
									SymbolPolyfill('search')
							),
							species: d(
								'',
								(NativeSymbol && NativeSymbol.species) ||
									SymbolPolyfill('species')
							),
							split: d(
								'',
								(NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')
							),
							toPrimitive: d(
								'',
								(NativeSymbol && NativeSymbol.toPrimitive) ||
									SymbolPolyfill('toPrimitive')
							),
							toStringTag: d(
								'',
								(NativeSymbol && NativeSymbol.toStringTag) ||
									SymbolPolyfill('toStringTag')
							),
							unscopables: d(
								'',
								(NativeSymbol && NativeSymbol.unscopables) ||
									SymbolPolyfill('unscopables')
							)
						});
					};
				},
				{ d: 154, 'ext/global-this': 210 }
			],
			205: [
				function(_dereq_, module, exports) {
					'use strict';

					var d = _dereq_('d'),
						validateSymbol = _dereq_('../../../validate-symbol');

					var registry = Object.create(null);

					module.exports = function(SymbolPolyfill) {
						return Object.defineProperties(SymbolPolyfill, {
							for: d(function(key) {
								if (registry[key]) return registry[key];
								return (registry[key] = SymbolPolyfill(String(key)));
							}),
							keyFor: d(function(symbol) {
								var key;
								validateSymbol(symbol);
								for (key in registry) {
									if (registry[key] === symbol) return key;
								}
								return undefined;
							})
						});
					};
				},
				{ '../../../validate-symbol': 207, d: 154 }
			],
			206: [
				function(_dereq_, module, exports) {
					// ES2015 Symbol polyfill for environments that do not (or partially) support it

					'use strict';

					var d = _dereq_('d'),
						validateSymbol = _dereq_('./validate-symbol'),
						NativeSymbol = _dereq_('ext/global-this').Symbol,
						generateName = _dereq_('./lib/private/generate-name'),
						setupStandardSymbols = _dereq_(
							'./lib/private/setup/standard-symbols'
						),
						setupSymbolRegistry = _dereq_(
							'./lib/private/setup/symbol-registry'
						);

					var create = Object.create,
						defineProperties = Object.defineProperties,
						defineProperty = Object.defineProperty;

					var SymbolPolyfill, HiddenSymbol, isNativeSafe;

					if (typeof NativeSymbol === 'function') {
						try {
							String(NativeSymbol());
							isNativeSafe = true;
						} catch (ignore) {}
					} else {
						NativeSymbol = null;
					}

					// Internal constructor (not one exposed) for creating Symbol instances.
					// This one is used to ensure that `someSymbol instanceof Symbol` always return false
					HiddenSymbol = function Symbol(description) {
						if (this instanceof HiddenSymbol)
							throw new TypeError('Symbol is not a constructor');
						return SymbolPolyfill(description);
					};

					// Exposed `Symbol` constructor
					// (returns instances of HiddenSymbol)
					module.exports = SymbolPolyfill = function Symbol(description) {
						var symbol;
						if (this instanceof Symbol)
							throw new TypeError('Symbol is not a constructor');
						if (isNativeSafe) return NativeSymbol(description);
						symbol = create(HiddenSymbol.prototype);
						description = description === undefined ? '' : String(description);
						return defineProperties(symbol, {
							__description__: d('', description),
							__name__: d('', generateName(description))
						});
					};

					setupStandardSymbols(SymbolPolyfill);
					setupSymbolRegistry(SymbolPolyfill);

					// Internal tweaks for real symbol producer
					defineProperties(HiddenSymbol.prototype, {
						constructor: d(SymbolPolyfill),
						toString: d('', function() {
							return this.__name__;
						})
					});

					// Proper implementation of methods exposed on Symbol.prototype
					// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
					defineProperties(SymbolPolyfill.prototype, {
						toString: d(function() {
							return 'Symbol (' + validateSymbol(this).__description__ + ')';
						}),
						valueOf: d(function() {
							return validateSymbol(this);
						})
					});
					defineProperty(
						SymbolPolyfill.prototype,
						SymbolPolyfill.toPrimitive,
						d('', function() {
							var symbol = validateSymbol(this);
							if (typeof symbol === 'symbol') return symbol;
							return symbol.toString();
						})
					);
					defineProperty(
						SymbolPolyfill.prototype,
						SymbolPolyfill.toStringTag,
						d('c', 'Symbol')
					);

					// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
					defineProperty(
						HiddenSymbol.prototype,
						SymbolPolyfill.toStringTag,
						d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])
					);

					// Note: It's important to define `toPrimitive` as last one, as some implementations
					// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
					// And that may invoke error in definition flow:
					// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
					defineProperty(
						HiddenSymbol.prototype,
						SymbolPolyfill.toPrimitive,
						d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])
					);
				},
				{
					'./lib/private/generate-name': 203,
					'./lib/private/setup/standard-symbols': 204,
					'./lib/private/setup/symbol-registry': 205,
					'./validate-symbol': 207,
					d: 154,
					'ext/global-this': 210
				}
			],
			207: [
				function(_dereq_, module, exports) {
					'use strict';

					var isSymbol = _dereq_('./is-symbol');

					module.exports = function(value) {
						if (!isSymbol(value))
							throw new TypeError(value + ' is not a symbol');
						return value;
					};
				},
				{ './is-symbol': 202 }
			],
			208: [
				function(_dereq_, module, exports) {
					'use strict';

					var d = _dereq_('d'),
						callable = _dereq_('es5-ext/object/valid-callable'),
						apply = Function.prototype.apply,
						call = Function.prototype.call,
						create = Object.create,
						defineProperty = Object.defineProperty,
						defineProperties = Object.defineProperties,
						hasOwnProperty = Object.prototype.hasOwnProperty,
						descriptor = {
							configurable: true,
							enumerable: false,
							writable: true
						},
						on,
						once,
						off,
						emit,
						methods,
						descriptors,
						base;

					on = function(type, listener) {
						var data;

						callable(listener);

						if (!hasOwnProperty.call(this, '__ee__')) {
							data = descriptor.value = create(null);
							defineProperty(this, '__ee__', descriptor);
							descriptor.value = null;
						} else {
							data = this.__ee__;
						}
						if (!data[type]) data[type] = listener;
						else if (typeof data[type] === 'object') data[type].push(listener);
						else data[type] = [data[type], listener];

						return this;
					};

					once = function(type, listener) {
						var once, self;

						callable(listener);
						self = this;
						on.call(
							this,
							type,
							(once = function() {
								off.call(self, type, once);
								apply.call(listener, this, arguments);
							})
						);

						once.__eeOnceListener__ = listener;
						return this;
					};

					off = function(type, listener) {
						var data, listeners, candidate, i;

						callable(listener);

						if (!hasOwnProperty.call(this, '__ee__')) return this;
						data = this.__ee__;
						if (!data[type]) return this;
						listeners = data[type];

						if (typeof listeners === 'object') {
							for (i = 0; (candidate = listeners[i]); ++i) {
								if (
									candidate === listener ||
									candidate.__eeOnceListener__ === listener
								) {
									if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
									else listeners.splice(i, 1);
								}
							}
						} else {
							if (
								listeners === listener ||
								listeners.__eeOnceListener__ === listener
							) {
								delete data[type];
							}
						}

						return this;
					};

					emit = function(type) {
						var i, l, listener, listeners, args;

						if (!hasOwnProperty.call(this, '__ee__')) return;
						listeners = this.__ee__[type];
						if (!listeners) return;

						if (typeof listeners === 'object') {
							l = arguments.length;
							args = new Array(l - 1);
							for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

							listeners = listeners.slice();
							for (i = 0; (listener = listeners[i]); ++i) {
								apply.call(listener, this, args);
							}
						} else {
							switch (arguments.length) {
								case 1:
									call.call(listeners, this);
									break;
								case 2:
									call.call(listeners, this, arguments[1]);
									break;
								case 3:
									call.call(listeners, this, arguments[1], arguments[2]);
									break;
								default:
									l = arguments.length;
									args = new Array(l - 1);
									for (i = 1; i < l; ++i) {
										args[i - 1] = arguments[i];
									}
									apply.call(listeners, this, args);
							}
						}
					};

					methods = {
						on: on,
						once: once,
						off: off,
						emit: emit
					};

					descriptors = {
						on: d(on),
						once: d(once),
						off: d(off),
						emit: d(emit)
					};

					base = defineProperties({}, descriptors);

					module.exports = exports = function(o) {
						return o == null
							? create(base)
							: defineProperties(Object(o), descriptors);
					};
					exports.methods = methods;
				},
				{ d: 154, 'es5-ext/object/valid-callable': 189 }
			],
			209: [
				function(_dereq_, module, exports) {
					var naiveFallback = function() {
						if (typeof self === 'object' && self) return self;
						if (typeof window === 'object' && window) return window;
						throw new Error('Unable to resolve global `this`');
					};

					module.exports = (function() {
						if (this) return this;

						// Unexpected strict mode (may happen if e.g. bundled into ESM module)

						// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis
						// In all ES5+ engines global object inherits from Object.prototype
						// (if you approached one that doesn't please report)
						try {
							Object.defineProperty(Object.prototype, '__global__', {
								get: function() {
									return this;
								},
								configurable: true
							});
						} catch (error) {
							// Unfortunate case of Object.prototype being sealed (via preventExtensions, seal or freeze)
							return naiveFallback();
						}
						try {
							// Safari case (window.__global__ is resolved with global context, but __global__ does not)
							if (!__global__) return naiveFallback();
							return __global__;
						} finally {
							delete Object.prototype.__global__;
						}
					})();
				},
				{}
			],
			210: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = _dereq_('./is-implemented')()
						? globalThis
						: _dereq_('./implementation');
				},
				{ './implementation': 209, './is-implemented': 211 }
			],
			211: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = function() {
						if (typeof globalThis !== 'object') return false;
						if (!globalThis) return false;
						return globalThis.Array === Array;
					};
				},
				{}
			],
			212: [
				function(_dereq_, module, exports) {
					/*!
					 * Determine if an object is a Buffer
					 *
					 * @author   Feross Aboukhadijeh <https://feross.org>
					 * @license  MIT
					 */

					module.exports = function isBuffer(obj) {
						return (
							obj != null &&
							obj.constructor != null &&
							typeof obj.constructor.isBuffer === 'function' &&
							obj.constructor.isBuffer(obj)
						);
					};
				},
				{}
			],
			213: [
				function(_dereq_, module, exports) {
					module.exports = isPromise;

					function isPromise(obj) {
						return (
							!!obj &&
							(typeof obj === 'object' || typeof obj === 'function') &&
							typeof obj.then === 'function'
						);
					}
				},
				{}
			],
			214: [
				function(_dereq_, module, exports) {
					'use strict';

					var toPosInt = _dereq_('es5-ext/number/to-pos-integer'),
						create = Object.create,
						hasOwnProperty = Object.prototype.hasOwnProperty;

					module.exports = function(limit) {
						var size = 0,
							base = 1,
							queue = create(null),
							map = create(null),
							index = 0,
							del;
						limit = toPosInt(limit);
						return {
							hit: function(id) {
								var oldIndex = map[id],
									nuIndex = ++index;
								queue[nuIndex] = id;
								map[id] = nuIndex;
								if (!oldIndex) {
									++size;
									if (size <= limit) return;
									id = queue[base];
									del(id);
									return id;
								}
								delete queue[oldIndex];
								if (base !== oldIndex) return;
								while (!hasOwnProperty.call(queue, ++base)) continue; //jslint: skip
							},
							delete: (del = function(id) {
								var oldIndex = map[id];
								if (!oldIndex) return;
								delete queue[oldIndex];
								delete map[id];
								--size;
								if (base !== oldIndex) return;
								if (!size) {
									index = 0;
									base = 1;
									return;
								}
								while (!hasOwnProperty.call(queue, ++base)) continue; //jslint: skip
							}),
							clear: function() {
								size = 0;
								base = 1;
								queue = create(null);
								map = create(null);
								index = 0;
							}
						};
					};
				},
				{ 'es5-ext/number/to-pos-integer': 173 }
			],
			215: [
				function(_dereq_, module, exports) {
					/* eslint consistent-this: 0, no-shadow:0, no-eq-null: 0, eqeqeq: 0, no-unused-vars: 0 */

					// Support for asynchronous functions

					'use strict';

					var aFrom = _dereq_('es5-ext/array/from'),
						objectMap = _dereq_('es5-ext/object/map'),
						mixin = _dereq_('es5-ext/object/mixin'),
						defineLength = _dereq_('es5-ext/function/_define-length'),
						nextTick = _dereq_('next-tick');

					var slice = Array.prototype.slice,
						apply = Function.prototype.apply,
						create = Object.create;

					_dereq_('../lib/registered-extensions').async = function(tbi, conf) {
						var waiting = create(null),
							cache = create(null),
							base = conf.memoized,
							original = conf.original,
							currentCallback,
							currentContext,
							currentArgs;

						// Initial
						conf.memoized = defineLength(function(arg) {
							var args = arguments,
								last = args[args.length - 1];
							if (typeof last === 'function') {
								currentCallback = last;
								args = slice.call(args, 0, -1);
							}
							return base.apply((currentContext = this), (currentArgs = args));
						}, base);
						try {
							mixin(conf.memoized, base);
						} catch (ignore) {}

						// From cache (sync)
						conf.on('get', function(id) {
							var cb, context, args;
							if (!currentCallback) return;

							// Unresolved
							if (waiting[id]) {
								if (typeof waiting[id] === 'function')
									waiting[id] = [waiting[id], currentCallback];
								else waiting[id].push(currentCallback);
								currentCallback = null;
								return;
							}

							// Resolved, assure next tick invocation
							cb = currentCallback;
							context = currentContext;
							args = currentArgs;
							currentCallback = currentContext = currentArgs = null;
							nextTick(function() {
								var data;
								if (hasOwnProperty.call(cache, id)) {
									data = cache[id];
									conf.emit('getasync', id, args, context);
									apply.call(cb, data.context, data.args);
								} else {
									// Purged in a meantime, we shouldn't rely on cached value, recall
									currentCallback = cb;
									currentContext = context;
									currentArgs = args;
									base.apply(context, args);
								}
							});
						});

						// Not from cache
						conf.original = function() {
							var args, cb, origCb, result;
							if (!currentCallback)
								return apply.call(original, this, arguments);
							args = aFrom(arguments);
							cb = function self(err) {
								var cb,
									args,
									id = self.id;
								if (id == null) {
									// Shouldn't happen, means async callback was called sync way
									nextTick(apply.bind(self, this, arguments));
									return undefined;
								}
								delete self.id;
								cb = waiting[id];
								delete waiting[id];
								if (!cb) {
									// Already processed,
									// outcome of race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)
									return undefined;
								}
								args = aFrom(arguments);
								if (conf.has(id)) {
									if (err) {
										conf.delete(id);
									} else {
										cache[id] = { context: this, args: args };
										conf.emit(
											'setasync',
											id,
											typeof cb === 'function' ? 1 : cb.length
										);
									}
								}
								if (typeof cb === 'function') {
									result = apply.call(cb, this, args);
								} else {
									cb.forEach(function(cb) {
										result = apply.call(cb, this, args);
									}, this);
								}
								return result;
							};
							origCb = currentCallback;
							currentCallback = currentContext = currentArgs = null;
							args.push(cb);
							result = apply.call(original, this, args);
							cb.cb = origCb;
							currentCallback = cb;
							return result;
						};

						// After not from cache call
						conf.on('set', function(id) {
							if (!currentCallback) {
								conf.delete(id);
								return;
							}
							if (waiting[id]) {
								// Race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)
								if (typeof waiting[id] === 'function')
									waiting[id] = [waiting[id], currentCallback.cb];
								else waiting[id].push(currentCallback.cb);
							} else {
								waiting[id] = currentCallback.cb;
							}
							delete currentCallback.cb;
							currentCallback.id = id;
							currentCallback = null;
						});

						// On delete
						conf.on('delete', function(id) {
							var result;
							// If false, we don't have value yet, so we assume that intention is not
							// to memoize this call. After value is obtained we don't cache it but
							// gracefully pass to callback
							if (hasOwnProperty.call(waiting, id)) return;
							if (!cache[id]) return;
							result = cache[id];
							delete cache[id];
							conf.emit('deleteasync', id, slice.call(result.args, 1));
						});

						// On clear
						conf.on('clear', function() {
							var oldCache = cache;
							cache = create(null);
							conf.emit(
								'clearasync',
								objectMap(oldCache, function(data) {
									return slice.call(data.args, 1);
								})
							);
						});
					};
				},
				{
					'../lib/registered-extensions': 223,
					'es5-ext/array/from': 157,
					'es5-ext/function/_define-length': 162,
					'es5-ext/object/map': 185,
					'es5-ext/object/mixin': 186,
					'next-tick': 233
				}
			],
			216: [
				function(_dereq_, module, exports) {
					// Call dispose callback on each cache purge

					'use strict';

					var callable = _dereq_('es5-ext/object/valid-callable'),
						forEach = _dereq_('es5-ext/object/for-each'),
						extensions = _dereq_('../lib/registered-extensions'),
						apply = Function.prototype.apply;

					extensions.dispose = function(dispose, conf, options) {
						var del;
						callable(dispose);
						if (
							(options.async && extensions.async) ||
							(options.promise && extensions.promise)
						) {
							conf.on(
								'deleteasync',
								(del = function(id, resultArray) {
									apply.call(dispose, null, resultArray);
								})
							);
							conf.on('clearasync', function(cache) {
								forEach(cache, function(result, id) {
									del(id, result);
								});
							});
							return;
						}
						conf.on(
							'delete',
							(del = function(id, result) {
								dispose(result);
							})
						);
						conf.on('clear', function(cache) {
							forEach(cache, function(result, id) {
								del(id, result);
							});
						});
					};
				},
				{
					'../lib/registered-extensions': 223,
					'es5-ext/object/for-each': 178,
					'es5-ext/object/valid-callable': 189
				}
			],
			217: [
				function(_dereq_, module, exports) {
					/* eslint consistent-this: 0 */

					// Timeout cached values

					'use strict';

					var aFrom = _dereq_('es5-ext/array/from'),
						forEach = _dereq_('es5-ext/object/for-each'),
						nextTick = _dereq_('next-tick'),
						isPromise = _dereq_('is-promise'),
						timeout = _dereq_('timers-ext/valid-timeout'),
						extensions = _dereq_('../lib/registered-extensions');

					var noop = Function.prototype,
						max = Math.max,
						min = Math.min,
						create = Object.create;

					extensions.maxAge = function(maxAge, conf, options) {
						var timeouts, postfix, preFetchAge, preFetchTimeouts;

						maxAge = timeout(maxAge);
						if (!maxAge) return;

						timeouts = create(null);
						postfix =
							(options.async && extensions.async) ||
							(options.promise && extensions.promise)
								? 'async'
								: '';
						conf.on('set' + postfix, function(id) {
							timeouts[id] = setTimeout(function() {
								conf.delete(id);
							}, maxAge);
							if (typeof timeouts[id].unref === 'function')
								timeouts[id].unref();
							if (!preFetchTimeouts) return;
							if (preFetchTimeouts[id]) {
								if (preFetchTimeouts[id] !== 'nextTick')
									clearTimeout(preFetchTimeouts[id]);
							}
							preFetchTimeouts[id] = setTimeout(function() {
								delete preFetchTimeouts[id];
							}, preFetchAge);
							if (typeof preFetchTimeouts[id].unref === 'function')
								preFetchTimeouts[id].unref();
						});
						conf.on('delete' + postfix, function(id) {
							clearTimeout(timeouts[id]);
							delete timeouts[id];
							if (!preFetchTimeouts) return;
							if (preFetchTimeouts[id] !== 'nextTick')
								clearTimeout(preFetchTimeouts[id]);
							delete preFetchTimeouts[id];
						});

						if (options.preFetch) {
							if (options.preFetch === true || isNaN(options.preFetch)) {
								preFetchAge = 0.333;
							} else {
								preFetchAge = max(min(Number(options.preFetch), 1), 0);
							}
							if (preFetchAge) {
								preFetchTimeouts = {};
								preFetchAge = (1 - preFetchAge) * maxAge;
								conf.on('get' + postfix, function(id, args, context) {
									if (!preFetchTimeouts[id]) {
										preFetchTimeouts[id] = 'nextTick';
										nextTick(function() {
											var result;
											if (preFetchTimeouts[id] !== 'nextTick') return;
											delete preFetchTimeouts[id];
											conf.delete(id);
											if (options.async) {
												args = aFrom(args);
												args.push(noop);
											}
											result = conf.memoized.apply(context, args);
											if (options.promise) {
												// Supress eventual error warnings
												if (isPromise(result)) {
													if (typeof result.done === 'function')
														result.done(noop, noop);
													else result.then(noop, noop);
												}
											}
										});
									}
								});
							}
						}

						conf.on('clear' + postfix, function() {
							forEach(timeouts, function(id) {
								clearTimeout(id);
							});
							timeouts = {};
							if (preFetchTimeouts) {
								forEach(preFetchTimeouts, function(id) {
									if (id !== 'nextTick') clearTimeout(id);
								});
								preFetchTimeouts = {};
							}
						});
					};
				},
				{
					'../lib/registered-extensions': 223,
					'es5-ext/array/from': 157,
					'es5-ext/object/for-each': 178,
					'is-promise': 213,
					'next-tick': 233,
					'timers-ext/valid-timeout': 237
				}
			],
			218: [
				function(_dereq_, module, exports) {
					// Limit cache size, LRU (least recently used) algorithm.

					'use strict';

					var toPosInteger = _dereq_('es5-ext/number/to-pos-integer'),
						lruQueue = _dereq_('lru-queue'),
						extensions = _dereq_('../lib/registered-extensions');

					extensions.max = function(max, conf, options) {
						var postfix, queue, hit;

						max = toPosInteger(max);
						if (!max) return;

						queue = lruQueue(max);
						postfix =
							(options.async && extensions.async) ||
							(options.promise && extensions.promise)
								? 'async'
								: '';

						conf.on(
							'set' + postfix,
							(hit = function(id) {
								id = queue.hit(id);
								if (id === undefined) return;
								conf.delete(id);
							})
						);
						conf.on('get' + postfix, hit);
						conf.on('delete' + postfix, queue.delete);
						conf.on('clear' + postfix, queue.clear);
					};
				},
				{
					'../lib/registered-extensions': 223,
					'es5-ext/number/to-pos-integer': 173,
					'lru-queue': 214
				}
			],
			219: [
				function(_dereq_, module, exports) {
					/* eslint max-statements: 0 */

					// Support for functions returning promise

					'use strict';

					var objectMap = _dereq_('es5-ext/object/map'),
						primitiveSet = _dereq_('es5-ext/object/primitive-set'),
						ensureString = _dereq_(
							'es5-ext/object/validate-stringifiable-value'
						),
						toShortString = _dereq_('es5-ext/to-short-string-representation'),
						isPromise = _dereq_('is-promise'),
						nextTick = _dereq_('next-tick');

					var create = Object.create,
						supportedModes = primitiveSet(
							'then',
							'then:finally',
							'done',
							'done:finally'
						);

					_dereq_('../lib/registered-extensions').promise = function(
						mode,
						conf
					) {
						var waiting = create(null),
							cache = create(null),
							promises = create(null);

						if (mode === true) {
							mode = null;
						} else {
							mode = ensureString(mode);
							if (!supportedModes[mode]) {
								throw new TypeError(
									"'" + toShortString(mode) + "' is not valid promise mode"
								);
							}
						}

						// After not from cache call
						conf.on('set', function(id, ignore, promise) {
							var isFailed = false;

							if (!isPromise(promise)) {
								// Non promise result
								cache[id] = promise;
								conf.emit('setasync', id, 1);
								return;
							}
							waiting[id] = 1;
							promises[id] = promise;
							var onSuccess = function(result) {
								var count = waiting[id];
								if (isFailed) {
									throw new Error(
										'Memoizee error: Detected unordered then|done & finally resolution, which ' +
											'in turn makes proper detection of success/failure impossible (when in ' +
											"'done:finally' mode)\n" +
											"Consider to rely on 'then' or 'done' mode instead."
									);
								}
								if (!count) return; // Deleted from cache before resolved
								delete waiting[id];
								cache[id] = result;
								conf.emit('setasync', id, count);
							};
							var onFailure = function() {
								isFailed = true;
								if (!waiting[id]) return; // Deleted from cache (or succeed in case of finally)
								delete waiting[id];
								delete promises[id];
								conf.delete(id);
							};

							var resolvedMode = mode;
							if (!resolvedMode) resolvedMode = 'then';

							if (resolvedMode === 'then') {
								var nextTickFailure = function() {
									nextTick(onFailure);
								};
								// Eventual finally needs to be attached to non rejected promise
								// (so we not force propagation of unhandled rejection)
								promise = promise.then(function(result) {
									nextTick(onSuccess.bind(this, result));
								}, nextTickFailure);
								// If `finally` is a function we attach to it to remove cancelled promises.
								if (typeof promise.finally === 'function') {
									promise.finally(nextTickFailure);
								}
							} else if (resolvedMode === 'done') {
								// Not recommended, as it may mute any eventual "Unhandled error" events
								if (typeof promise.done !== 'function') {
									throw new Error(
										"Memoizee error: Retrieved promise does not implement 'done' " +
											"in 'done' mode"
									);
								}
								promise.done(onSuccess, onFailure);
							} else if (resolvedMode === 'done:finally') {
								// The only mode with no side effects assuming library does not throw unconditionally
								// for rejected promises.
								if (typeof promise.done !== 'function') {
									throw new Error(
										"Memoizee error: Retrieved promise does not implement 'done' " +
											"in 'done:finally' mode"
									);
								}
								if (typeof promise.finally !== 'function') {
									throw new Error(
										"Memoizee error: Retrieved promise does not implement 'finally' " +
											"in 'done:finally' mode"
									);
								}
								promise.done(onSuccess);
								promise.finally(onFailure);
							}
						});

						// From cache (sync)
						conf.on('get', function(id, args, context) {
							var promise;
							if (waiting[id]) {
								++waiting[id]; // Still waiting
								return;
							}
							promise = promises[id];
							var emit = function() {
								conf.emit('getasync', id, args, context);
							};
							if (isPromise(promise)) {
								if (typeof promise.done === 'function') promise.done(emit);
								else {
									promise.then(function() {
										nextTick(emit);
									});
								}
							} else {
								emit();
							}
						});

						// On delete
						conf.on('delete', function(id) {
							delete promises[id];
							if (waiting[id]) {
								delete waiting[id];
								return; // Not yet resolved
							}
							if (!hasOwnProperty.call(cache, id)) return;
							var result = cache[id];
							delete cache[id];
							conf.emit('deleteasync', id, [result]);
						});

						// On clear
						conf.on('clear', function() {
							var oldCache = cache;
							cache = create(null);
							waiting = create(null);
							promises = create(null);
							conf.emit(
								'clearasync',
								objectMap(oldCache, function(data) {
									return [data];
								})
							);
						});
					};
				},
				{
					'../lib/registered-extensions': 223,
					'es5-ext/object/map': 185,
					'es5-ext/object/primitive-set': 188,
					'es5-ext/object/validate-stringifiable-value': 191,
					'es5-ext/to-short-string-representation': 198,
					'is-promise': 213,
					'next-tick': 233
				}
			],
			220: [
				function(_dereq_, module, exports) {
					// Reference counter, useful for garbage collector like functionality

					'use strict';

					var d = _dereq_('d'),
						extensions = _dereq_('../lib/registered-extensions'),
						create = Object.create,
						defineProperties = Object.defineProperties;

					extensions.refCounter = function(ignore, conf, options) {
						var cache, postfix;

						cache = create(null);
						postfix =
							(options.async && extensions.async) ||
							(options.promise && extensions.promise)
								? 'async'
								: '';

						conf.on('set' + postfix, function(id, length) {
							cache[id] = length || 1;
						});
						conf.on('get' + postfix, function(id) {
							++cache[id];
						});
						conf.on('delete' + postfix, function(id) {
							delete cache[id];
						});
						conf.on('clear' + postfix, function() {
							cache = {};
						});

						defineProperties(conf.memoized, {
							deleteRef: d(function() {
								var id = conf.get(arguments);
								if (id === null) return null;
								if (!cache[id]) return null;
								if (!--cache[id]) {
									conf.delete(id);
									return true;
								}
								return false;
							}),
							getRefCount: d(function() {
								var id = conf.get(arguments);
								if (id === null) return 0;
								if (!cache[id]) return 0;
								return cache[id];
							})
						});
					};
				},
				{ '../lib/registered-extensions': 223, d: 154 }
			],
			221: [
				function(_dereq_, module, exports) {
					'use strict';

					var normalizeOpts = _dereq_('es5-ext/object/normalize-options'),
						resolveLength = _dereq_('./lib/resolve-length'),
						plain = _dereq_('./plain');

					module.exports = function(fn /*, options*/) {
						var options = normalizeOpts(arguments[1]),
							length;

						if (!options.normalizer) {
							length = options.length = resolveLength(
								options.length,
								fn.length,
								options.async
							);
							if (length !== 0) {
								if (options.primitive) {
									if (length === false) {
										options.normalizer = _dereq_('./normalizers/primitive');
									} else if (length > 1) {
										options.normalizer = _dereq_(
											'./normalizers/get-primitive-fixed'
										)(length);
									}
								} else if (length === false)
									options.normalizer = _dereq_('./normalizers/get')();
								else if (length === 1)
									options.normalizer = _dereq_('./normalizers/get-1')();
								else
									options.normalizer = _dereq_('./normalizers/get-fixed')(
										length
									);
							}
						}

						// Assure extensions
						if (options.async) _dereq_('./ext/async');
						if (options.promise) _dereq_('./ext/promise');
						if (options.dispose) _dereq_('./ext/dispose');
						if (options.maxAge) _dereq_('./ext/max-age');
						if (options.max) _dereq_('./ext/max');
						if (options.refCounter) _dereq_('./ext/ref-counter');

						return plain(fn, options);
					};
				},
				{
					'./ext/async': 215,
					'./ext/dispose': 216,
					'./ext/max': 218,
					'./ext/max-age': 217,
					'./ext/promise': 219,
					'./ext/ref-counter': 220,
					'./lib/resolve-length': 224,
					'./normalizers/get': 230,
					'./normalizers/get-1': 227,
					'./normalizers/get-fixed': 228,
					'./normalizers/get-primitive-fixed': 229,
					'./normalizers/primitive': 231,
					'./plain': 232,
					'es5-ext/object/normalize-options': 187
				}
			],
			222: [
				function(_dereq_, module, exports) {
					/* eslint no-eq-null: 0, eqeqeq: 0, no-unused-vars: 0 */

					'use strict';

					var customError = _dereq_('es5-ext/error/custom'),
						defineLength = _dereq_('es5-ext/function/_define-length'),
						d = _dereq_('d'),
						ee = _dereq_('event-emitter').methods,
						resolveResolve = _dereq_('./resolve-resolve'),
						resolveNormalize = _dereq_('./resolve-normalize');

					var apply = Function.prototype.apply,
						call = Function.prototype.call,
						create = Object.create,
						defineProperties = Object.defineProperties,
						on = ee.on,
						emit = ee.emit;

					module.exports = function(original, length, options) {
						var cache = create(null),
							conf,
							memLength,
							get,
							set,
							del,
							clear,
							extDel,
							extGet,
							extHas,
							normalizer,
							getListeners,
							setListeners,
							deleteListeners,
							memoized,
							resolve;
						if (length !== false) memLength = length;
						else if (isNaN(original.length)) memLength = 1;
						else memLength = original.length;

						if (options.normalizer) {
							normalizer = resolveNormalize(options.normalizer);
							get = normalizer.get;
							set = normalizer.set;
							del = normalizer.delete;
							clear = normalizer.clear;
						}
						if (options.resolvers != null)
							resolve = resolveResolve(options.resolvers);

						if (get) {
							memoized = defineLength(function(arg) {
								var id,
									result,
									args = arguments;
								if (resolve) args = resolve(args);
								id = get(args);
								if (id !== null) {
									if (hasOwnProperty.call(cache, id)) {
										if (getListeners) conf.emit('get', id, args, this);
										return cache[id];
									}
								}
								if (args.length === 1)
									result = call.call(original, this, args[0]);
								else result = apply.call(original, this, args);
								if (id === null) {
									id = get(args);
									if (id !== null)
										throw customError(
											'Circular invocation',
											'CIRCULAR_INVOCATION'
										);
									id = set(args);
								} else if (hasOwnProperty.call(cache, id)) {
									throw customError(
										'Circular invocation',
										'CIRCULAR_INVOCATION'
									);
								}
								cache[id] = result;
								if (setListeners) conf.emit('set', id, null, result);
								return result;
							}, memLength);
						} else if (length === 0) {
							memoized = function() {
								var result;
								if (hasOwnProperty.call(cache, 'data')) {
									if (getListeners) conf.emit('get', 'data', arguments, this);
									return cache.data;
								}
								if (arguments.length)
									result = apply.call(original, this, arguments);
								else result = call.call(original, this);
								if (hasOwnProperty.call(cache, 'data')) {
									throw customError(
										'Circular invocation',
										'CIRCULAR_INVOCATION'
									);
								}
								cache.data = result;
								if (setListeners) conf.emit('set', 'data', null, result);
								return result;
							};
						} else {
							memoized = function(arg) {
								var result,
									args = arguments,
									id;
								if (resolve) args = resolve(arguments);
								id = String(args[0]);
								if (hasOwnProperty.call(cache, id)) {
									if (getListeners) conf.emit('get', id, args, this);
									return cache[id];
								}
								if (args.length === 1)
									result = call.call(original, this, args[0]);
								else result = apply.call(original, this, args);
								if (hasOwnProperty.call(cache, id)) {
									throw customError(
										'Circular invocation',
										'CIRCULAR_INVOCATION'
									);
								}
								cache[id] = result;
								if (setListeners) conf.emit('set', id, null, result);
								return result;
							};
						}
						conf = {
							original: original,
							memoized: memoized,
							profileName: options.profileName,
							get: function(args) {
								if (resolve) args = resolve(args);
								if (get) return get(args);
								return String(args[0]);
							},
							has: function(id) {
								return hasOwnProperty.call(cache, id);
							},
							delete: function(id) {
								var result;
								if (!hasOwnProperty.call(cache, id)) return;
								if (del) del(id);
								result = cache[id];
								delete cache[id];
								if (deleteListeners) conf.emit('delete', id, result);
							},
							clear: function() {
								var oldCache = cache;
								if (clear) clear();
								cache = create(null);
								conf.emit('clear', oldCache);
							},
							on: function(type, listener) {
								if (type === 'get') getListeners = true;
								else if (type === 'set') setListeners = true;
								else if (type === 'delete') deleteListeners = true;
								return on.call(this, type, listener);
							},
							emit: emit,
							updateEnv: function() {
								original = conf.original;
							}
						};
						if (get) {
							extDel = defineLength(function(arg) {
								var id,
									args = arguments;
								if (resolve) args = resolve(args);
								id = get(args);
								if (id === null) return;
								conf.delete(id);
							}, memLength);
						} else if (length === 0) {
							extDel = function() {
								return conf.delete('data');
							};
						} else {
							extDel = function(arg) {
								if (resolve) arg = resolve(arguments)[0];
								return conf.delete(arg);
							};
						}
						extGet = defineLength(function() {
							var id,
								args = arguments;
							if (length === 0) return cache.data;
							if (resolve) args = resolve(args);
							if (get) id = get(args);
							else id = String(args[0]);
							return cache[id];
						});
						extHas = defineLength(function() {
							var id,
								args = arguments;
							if (length === 0) return conf.has('data');
							if (resolve) args = resolve(args);
							if (get) id = get(args);
							else id = String(args[0]);
							if (id === null) return false;
							return conf.has(id);
						});
						defineProperties(memoized, {
							__memoized__: d(true),
							delete: d(extDel),
							clear: d(conf.clear),
							_get: d(extGet),
							_has: d(extHas)
						});
						return conf;
					};
				},
				{
					'./resolve-normalize': 225,
					'./resolve-resolve': 226,
					d: 154,
					'es5-ext/error/custom': 161,
					'es5-ext/function/_define-length': 162,
					'event-emitter': 208
				}
			],
			223: [
				function(_dereq_, module, exports) {
					'use strict';

				},
				{}
			],
			224: [
				function(_dereq_, module, exports) {
					'use strict';

					var toPosInt = _dereq_('es5-ext/number/to-pos-integer');

					module.exports = function(optsLength, fnLength, isAsync) {
						var length;
						if (isNaN(optsLength)) {
							length = fnLength;
							if (!(length >= 0)) return 1;
							if (isAsync && length) return length - 1;
							return length;
						}
						if (optsLength === false) return false;
						return toPosInt(optsLength);
					};
				},
				{ 'es5-ext/number/to-pos-integer': 173 }
			],
			225: [
				function(_dereq_, module, exports) {
					'use strict';

					var callable = _dereq_('es5-ext/object/valid-callable');

					module.exports = function(userNormalizer) {
						var normalizer;
						if (typeof userNormalizer === 'function')
							return { set: userNormalizer, get: userNormalizer };
						normalizer = { get: callable(userNormalizer.get) };
						if (userNormalizer.set !== undefined) {
							normalizer.set = callable(userNormalizer.set);
							if (userNormalizer.delete)
								normalizer.delete = callable(userNormalizer.delete);
							if (userNormalizer.clear)
								normalizer.clear = callable(userNormalizer.clear);
							return normalizer;
						}
						normalizer.set = normalizer.get;
						return normalizer;
					};
				},
				{ 'es5-ext/object/valid-callable': 189 }
			],
			226: [
				function(_dereq_, module, exports) {
					'use strict';

					var toArray = _dereq_('es5-ext/array/to-array'),
						isValue = _dereq_('es5-ext/object/is-value'),
						callable = _dereq_('es5-ext/object/valid-callable');

					var slice = Array.prototype.slice,
						resolveArgs;

					resolveArgs = function(args) {
						return this.map(function(resolve, i) {
							return resolve ? resolve(args[i]) : args[i];
						}).concat(slice.call(args, this.length));
					};

					module.exports = function(resolvers) {
						resolvers = toArray(resolvers);
						resolvers.forEach(function(resolve) {
							if (isValue(resolve)) callable(resolve);
						});
						return resolveArgs.bind(resolvers);
					};
				},
				{
					'es5-ext/array/to-array': 160,
					'es5-ext/object/is-value': 181,
					'es5-ext/object/valid-callable': 189
				}
			],
			227: [
				function(_dereq_, module, exports) {
					'use strict';

					var indexOf = _dereq_('es5-ext/array/#/e-index-of');

					module.exports = function() {
						var lastId = 0,
							argsMap = [],
							cache = [];
						return {
							get: function(args) {
								var index = indexOf.call(argsMap, args[0]);
								return index === -1 ? null : cache[index];
							},
							set: function(args) {
								argsMap.push(args[0]);
								cache.push(++lastId);
								return lastId;
							},
							delete: function(id) {
								var index = indexOf.call(cache, id);
								if (index !== -1) {
									argsMap.splice(index, 1);
									cache.splice(index, 1);
								}
							},
							clear: function() {
								argsMap = [];
								cache = [];
							}
						};
					};
				},
				{ 'es5-ext/array/#/e-index-of': 156 }
			],
			228: [
				function(_dereq_, module, exports) {
					'use strict';

					var indexOf = _dereq_('es5-ext/array/#/e-index-of'),
						create = Object.create;

					module.exports = function(length) {
						var lastId = 0,
							map = [[], []],
							cache = create(null);
						return {
							get: function(args) {
								var index = 0,
									set = map,
									i;
								while (index < length - 1) {
									i = indexOf.call(set[0], args[index]);
									if (i === -1) return null;
									set = set[1][i];
									++index;
								}
								i = indexOf.call(set[0], args[index]);
								if (i === -1) return null;
								return set[1][i] || null;
							},
							set: function(args) {
								var index = 0,
									set = map,
									i;
								while (index < length - 1) {
									i = indexOf.call(set[0], args[index]);
									if (i === -1) {
										i = set[0].push(args[index]) - 1;
										set[1].push([[], []]);
									}
									set = set[1][i];
									++index;
								}
								i = indexOf.call(set[0], args[index]);
								if (i === -1) {
									i = set[0].push(args[index]) - 1;
								}
								set[1][i] = ++lastId;
								cache[lastId] = args;
								return lastId;
							},
							delete: function(id) {
								var index = 0,
									set = map,
									i,
									path = [],
									args = cache[id];
								while (index < length - 1) {
									i = indexOf.call(set[0], args[index]);
									if (i === -1) {
										return;
									}
									path.push(set, i);
									set = set[1][i];
									++index;
								}
								i = indexOf.call(set[0], args[index]);
								if (i === -1) {
									return;
								}
								id = set[1][i];
								set[0].splice(i, 1);
								set[1].splice(i, 1);
								while (!set[0].length && path.length) {
									i = path.pop();
									set = path.pop();
									set[0].splice(i, 1);
									set[1].splice(i, 1);
								}
								delete cache[id];
							},
							clear: function() {
								map = [[], []];
								cache = create(null);
							}
						};
					};
				},
				{ 'es5-ext/array/#/e-index-of': 156 }
			],
			229: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = function(length) {
						if (!length) {
							return function() {
								return '';
							};
						}
						return function(args) {
							var id = String(args[0]),
								i = 0,
								currentLength = length;
							while (--currentLength) {
								id += '\u0001' + args[++i];
							}
							return id;
						};
					};
				},
				{}
			],
			230: [
				function(_dereq_, module, exports) {
					/* eslint max-statements: 0 */

					'use strict';

					var indexOf = _dereq_('es5-ext/array/#/e-index-of');

					var create = Object.create;

					module.exports = function() {
						var lastId = 0,
							map = [],
							cache = create(null);
						return {
							get: function(args) {
								var index = 0,
									set = map,
									i,
									length = args.length;
								if (length === 0) return set[length] || null;
								if ((set = set[length])) {
									while (index < length - 1) {
										i = indexOf.call(set[0], args[index]);
										if (i === -1) return null;
										set = set[1][i];
										++index;
									}
									i = indexOf.call(set[0], args[index]);
									if (i === -1) return null;
									return set[1][i] || null;
								}
								return null;
							},
							set: function(args) {
								var index = 0,
									set = map,
									i,
									length = args.length;
								if (length === 0) {
									set[length] = ++lastId;
								} else {
									if (!set[length]) {
										set[length] = [[], []];
									}
									set = set[length];
									while (index < length - 1) {
										i = indexOf.call(set[0], args[index]);
										if (i === -1) {
											i = set[0].push(args[index]) - 1;
											set[1].push([[], []]);
										}
										set = set[1][i];
										++index;
									}
									i = indexOf.call(set[0], args[index]);
									if (i === -1) {
										i = set[0].push(args[index]) - 1;
									}
									set[1][i] = ++lastId;
								}
								cache[lastId] = args;
								return lastId;
							},
							delete: function(id) {
								var index = 0,
									set = map,
									i,
									args = cache[id],
									length = args.length,
									path = [];
								if (length === 0) {
									delete set[length];
								} else if ((set = set[length])) {
									while (index < length - 1) {
										i = indexOf.call(set[0], args[index]);
										if (i === -1) {
											return;
										}
										path.push(set, i);
										set = set[1][i];
										++index;
									}
									i = indexOf.call(set[0], args[index]);
									if (i === -1) {
										return;
									}
									id = set[1][i];
									set[0].splice(i, 1);
									set[1].splice(i, 1);
									while (!set[0].length && path.length) {
										i = path.pop();
										set = path.pop();
										set[0].splice(i, 1);
										set[1].splice(i, 1);
									}
								}
								delete cache[id];
							},
							clear: function() {
								map = [];
								cache = create(null);
							}
						};
					};
				},
				{ 'es5-ext/array/#/e-index-of': 156 }
			],
			231: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = function(args) {
						var id,
							i,
							length = args.length;
						if (!length) return '\u0002';
						id = String(args[(i = 0)]);
						while (--length) id += '\u0001' + args[++i];
						return id;
					};
				},
				{}
			],
			232: [
				function(_dereq_, module, exports) {
					'use strict';

					var callable = _dereq_('es5-ext/object/valid-callable'),
						forEach = _dereq_('es5-ext/object/for-each'),
						extensions = _dereq_('./lib/registered-extensions'),
						configure = _dereq_('./lib/configure-map'),
						resolveLength = _dereq_('./lib/resolve-length');

					module.exports = function self(fn /*, options */) {
						var options, length, conf;

						callable(fn);
						options = Object(arguments[1]);

						if (options.async && options.promise) {
							throw new Error(
								"Options 'async' and 'promise' cannot be used together"
							);
						}

						// Do not memoize already memoized function
						if (hasOwnProperty.call(fn, '__memoized__') && !options.force)
							return fn;

						// Resolve length;
						length = resolveLength(
							options.length,
							fn.length,
							options.async && extensions.async
						);

						// Configure cache map
						conf = configure(fn, length, options);

						// Bind eventual extensions
						forEach(extensions, function(extFn, name) {
							if (options[name]) extFn(options[name], conf, options);
						});

						if (self.__profiler__) self.__profiler__(conf);

						conf.updateEnv();
						return conf.memoized;
					};
				},
				{
					'./lib/configure-map': 222,
					'./lib/registered-extensions': 223,
					'./lib/resolve-length': 224,
					'es5-ext/object/for-each': 178,
					'es5-ext/object/valid-callable': 189
				}
			],
			233: [
				function(_dereq_, module, exports) {
					(function(process, setImmediate) {
						'use strict';

						var callable, byObserver;

						callable = function(fn) {
							if (typeof fn !== 'function')
								throw new TypeError(fn + ' is not a function');
							return fn;
						};

						byObserver = function(Observer) {
							var node = document.createTextNode(''),
								queue,
								currentQueue,
								i = 0;
							new Observer(function() {
								var callback;
								if (!queue) {
									if (!currentQueue) return;
									queue = currentQueue;
								} else if (currentQueue) {
									queue = currentQueue.concat(queue);
								}
								currentQueue = queue;
								queue = null;
								if (typeof currentQueue === 'function') {
									callback = currentQueue;
									currentQueue = null;
									callback();
									return;
								}
								node.data = i = ++i % 2; // Invoke other batch, to handle leftover callbacks in case of crash
								while (currentQueue) {
									callback = currentQueue.shift();
									if (!currentQueue.length) currentQueue = null;
									callback();
								}
							}).observe(node, { characterData: true });
							return function(fn) {
								callable(fn);
								if (queue) {
									if (typeof queue === 'function') queue = [queue, fn];
									else queue.push(fn);
									return;
								}
								queue = fn;
								node.data = i = ++i % 2;
							};
						};

						module.exports = (function() {
							// Node.js
							if (
								typeof process === 'object' &&
								process &&
								typeof process.nextTick === 'function'
							) {
								return process.nextTick;
							}

							// MutationObserver
							if (typeof document === 'object' && document) {
								if (typeof MutationObserver === 'function')
									return byObserver(MutationObserver);
								if (typeof WebKitMutationObserver === 'function')
									return byObserver(WebKitMutationObserver);
							}

							// W3C Draft
							// http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
							if (typeof setImmediate === 'function') {
								return function(cb) {
									setImmediate(callable(cb));
								};
							}

							// Wide available standard
							if (
								typeof setTimeout === 'function' ||
								typeof setTimeout === 'object'
							) {
								return function(cb) {
									setTimeout(callable(cb), 0);
								};
							}

							return null;
						})();
					}.call(this, _dereq_('_process'), _dereq_('timers').setImmediate));
				},
				{ _process: 234, timers: 235 }
			],
			234: [
				function(_dereq_, module, exports) {
					// shim for using process in browser
					var process = (module.exports = {});

					// cached from whatever global is present so that test runners that stub it
					// don't break things.  But we need to wrap it in a try catch in case it is
					// wrapped in strict mode code which doesn't define any globals.  It's inside a
					// function because try/catches deoptimize in certain engines.

					var cachedSetTimeout;
					var cachedClearTimeout;

					function defaultSetTimout() {
						throw new Error('setTimeout has not been defined');
					}
					function defaultClearTimeout() {
						throw new Error('clearTimeout has not been defined');
					}
					(function() {
						try {
							if (typeof setTimeout === 'function') {
								cachedSetTimeout = setTimeout;
							} else {
								cachedSetTimeout = defaultSetTimout;
							}
						} catch (e) {
							cachedSetTimeout = defaultSetTimout;
						}
						try {
							if (typeof clearTimeout === 'function') {
								cachedClearTimeout = clearTimeout;
							} else {
								cachedClearTimeout = defaultClearTimeout;
							}
						} catch (e) {
							cachedClearTimeout = defaultClearTimeout;
						}
					})();
					function runTimeout(fun) {
						if (cachedSetTimeout === setTimeout) {
							//normal enviroments in sane situations
							return setTimeout(fun, 0);
						}
						// if setTimeout wasn't available but was latter defined
						if (
							(cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
							setTimeout
						) {
							cachedSetTimeout = setTimeout;
							return setTimeout(fun, 0);
						}
						try {
							// when when somebody has screwed with setTimeout but no I.E. maddness
							return cachedSetTimeout(fun, 0);
						} catch (e) {
							try {
								// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
								return cachedSetTimeout.call(null, fun, 0);
							} catch (e) {
								// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
								return cachedSetTimeout.call(this, fun, 0);
							}
						}
					}
					function runClearTimeout(marker) {
						if (cachedClearTimeout === clearTimeout) {
							//normal enviroments in sane situations
							return clearTimeout(marker);
						}
						// if clearTimeout wasn't available but was latter defined
						if (
							(cachedClearTimeout === defaultClearTimeout ||
								!cachedClearTimeout) &&
							clearTimeout
						) {
							cachedClearTimeout = clearTimeout;
							return clearTimeout(marker);
						}
						try {
							// when when somebody has screwed with setTimeout but no I.E. maddness
							return cachedClearTimeout(marker);
						} catch (e) {
							try {
								// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
								return cachedClearTimeout.call(null, marker);
							} catch (e) {
								// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
								// Some versions of I.E. have different rules for clearTimeout vs setTimeout
								return cachedClearTimeout.call(this, marker);
							}
						}
					}
					var queue = [];
					var draining = false;
					var currentQueue;
					var queueIndex = -1;

					function cleanUpNextTick() {
						if (!draining || !currentQueue) {
							return;
						}
						draining = false;
						if (currentQueue.length) {
							queue = currentQueue.concat(queue);
						} else {
							queueIndex = -1;
						}
						if (queue.length) {
							drainQueue();
						}
					}

					function drainQueue() {
						if (draining) {
							return;
						}
						var timeout = runTimeout(cleanUpNextTick);
						draining = true;

						var len = queue.length;
						while (len) {
							currentQueue = queue;
							queue = [];
							while (++queueIndex < len) {
								if (currentQueue) {
									currentQueue[queueIndex].run();
								}
							}
							queueIndex = -1;
							len = queue.length;
						}
						currentQueue = null;
						draining = false;
						runClearTimeout(timeout);
					}

					process.nextTick = function(fun) {
						var args = new Array(arguments.length - 1);
						if (arguments.length > 1) {
							for (var i = 1; i < arguments.length; i++) {
								args[i - 1] = arguments[i];
							}
						}
						queue.push(new Item(fun, args));
						if (queue.length === 1 && !draining) {
							runTimeout(drainQueue);
						}
					};

					// v8 likes predictible objects
					function Item(fun, array) {
						this.fun = fun;
						this.array = array;
					}
					Item.prototype.run = function() {
						this.fun.apply(null, this.array);
					};
					process.title = 'browser';
					process.browser = true;
					process.env = {};
					process.argv = [];
					process.version = ''; // empty string to avoid regexp issues
					process.versions = {};

					function noop() {}

					process.on = noop;
					process.addListener = noop;
					process.once = noop;
					process.off = noop;
					process.removeListener = noop;
					process.removeAllListeners = noop;
					process.emit = noop;
					process.prependListener = noop;
					process.prependOnceListener = noop;

					process.listeners = function(name) {
						return [];
					};

					process.binding = function(name) {
						throw new Error('process.binding is not supported');
					};

					process.cwd = function() {
						return '/';
					};
					process.chdir = function(dir) {
						throw new Error('process.chdir is not supported');
					};
					process.umask = function() {
						return 0;
					};
				},
				{}
			],
			235: [
				function(_dereq_, module, exports) {
					(function(setImmediate, clearImmediate) {
						var nextTick = _dereq_('process/browser.js').nextTick;
						var apply = Function.prototype.apply;
						var slice = Array.prototype.slice;
						var immediateIds = {};
						var nextImmediateId = 0;

						// DOM APIs, for completeness

						exports.setTimeout = function() {
							return new Timeout(
								apply.call(setTimeout, window, arguments),
								clearTimeout
							);
						};
						exports.setInterval = function() {
							return new Timeout(
								apply.call(setInterval, window, arguments),
								clearInterval
							);
						};
						exports.clearTimeout = exports.clearInterval = function(timeout) {
							timeout.close();
						};

						function Timeout(id, clearFn) {
							this._id = id;
							this._clearFn = clearFn;
						}
						Timeout.prototype.unref = Timeout.prototype.ref = function() {};
						Timeout.prototype.close = function() {
							this._clearFn.call(window, this._id);
						};

						// Does not start the time, just sets up the members needed.
						exports.enroll = function(item, msecs) {
							clearTimeout(item._idleTimeoutId);
							item._idleTimeout = msecs;
						};

						exports.unenroll = function(item) {
							clearTimeout(item._idleTimeoutId);
							item._idleTimeout = -1;
						};

						exports._unrefActive = exports.active = function(item) {
							clearTimeout(item._idleTimeoutId);

							var msecs = item._idleTimeout;
							if (msecs >= 0) {
								item._idleTimeoutId = setTimeout(function onTimeout() {
									if (item._onTimeout) item._onTimeout();
								}, msecs);
							}
						};

						// That's not how node.js implements it but the exposed api is the same.
						exports.setImmediate =
							typeof setImmediate === 'function'
								? setImmediate
								: function(fn) {
										var id = nextImmediateId++;
										var args =
											arguments.length < 2 ? false : slice.call(arguments, 1);

										immediateIds[id] = true;

										nextTick(function onNextTick() {
											if (immediateIds[id]) {
												// fn.call() is faster so we optimize for the common use-case
												// @see http://jsperf.com/call-apply-segu
												if (args) {
													fn.apply(null, args);
												} else {
													fn.call(null);
												}
												// Prevent ids from leaking
												exports.clearImmediate(id);
											}
										});

										return id;
								  };

						exports.clearImmediate =
							typeof clearImmediate === 'function'
								? clearImmediate
								: function(id) {
										delete immediateIds[id];
								  };
					}.call(
						this,
						_dereq_('timers').setImmediate,
						_dereq_('timers').clearImmediate
					));
				},
				{ 'process/browser.js': 234, timers: 235 }
			],
			236: [
				function(_dereq_, module, exports) {
					'use strict';

					module.exports = 2147483647;
				},
				{}
			],
			237: [
				function(_dereq_, module, exports) {
					'use strict';

					var toPosInt = _dereq_('es5-ext/number/to-pos-integer'),
						maxTimeout = _dereq_('./max-timeout');

					module.exports = function(value) {
						value = toPosInt(value);
						if (value > maxTimeout)
							throw new TypeError(value + ' exceeds maximum possible timeout');
						return value;
					};
				},
				{ './max-timeout': 236, 'es5-ext/number/to-pos-integer': 173 }
			],
			238: [
				function(_dereq_, module, exports) {
					'use strict';

					var isPrototype = _dereq_('../prototype/is');

					module.exports = function(value) {
						if (typeof value !== 'function') return false;

						if (!hasOwnProperty.call(value, 'length')) return false;

						try {
							if (typeof value.length !== 'number') return false;
							if (typeof value.call !== 'function') return false;
							if (typeof value.apply !== 'function') return false;
						} catch (error) {
							return false;
						}

						return !isPrototype(value);
					};
				},
				{ '../prototype/is': 241 }
			],
			239: [
				function(_dereq_, module, exports) {
					'use strict';

					var isValue = _dereq_('../value/is');

					// prettier-ignore
					var possibleTypes = { "object": true, "function": true, "undefined": true /* document.all */ };

					module.exports = function(value) {
						if (!isValue(value)) return false;
						return hasOwnProperty.call(possibleTypes, typeof value);
					};
				},
				{ '../value/is': 242 }
			],
			240: [
				function(_dereq_, module, exports) {
					'use strict';

					var isFunction = _dereq_('../function/is');

					var classRe = /^\s*class[\s{/}]/,
						functionToString = Function.prototype.toString;

					module.exports = function(value) {
						if (!isFunction(value)) return false;
						if (classRe.test(functionToString.call(value))) return false;
						return true;
					};
				},
				{ '../function/is': 238 }
			],
			241: [
				function(_dereq_, module, exports) {
					'use strict';

					var isObject = _dereq_('../object/is');

					module.exports = function(value) {
						if (!isObject(value)) return false;
						try {
							if (!value.constructor) return false;
							return value.constructor.prototype === value;
						} catch (error) {
							return false;
						}
					};
				},
				{ '../object/is': 239 }
			],
			242: [
				function(_dereq_, module, exports) {
					'use strict';

					// ES3 safe
					var _undefined = void 0;

					module.exports = function(value) {
						return value !== _undefined && value !== null;
					};
				},
				{}
			],
			243: [
				function(_dereq_, module, exports) {
					(function(global) {
						/*!
						 * weakmap-polyfill v2.0.0 - ECMAScript6 WeakMap polyfill
						 * https://github.com/polygonplanet/weakmap-polyfill
						 * Copyright (c) 2015-2016 polygon planet <polygon.planet.aqua@gmail.com>
						 * @license MIT
						 */

						(function(self) {
							'use strict';

							if (self.WeakMap) {
								return;
							}

							var hasOwnProperty = Object.prototype.hasOwnProperty;
							var defineProperty = function(object, name, value) {
								if (Object.defineProperty) {
									Object.defineProperty(object, name, {
										configurable: true,
										writable: true,
										value: value
									});
								} else {
									object[name] = value;
								}
							};

							self.WeakMap = (function() {
								// ECMA-262 23.3 WeakMap Objects
								function WeakMap() {
									if (this === void 0) {
										throw new TypeError("Constructor WeakMap requires 'new'");
									}

									defineProperty(this, '_id', genId('_WeakMap'));

									// ECMA-262 23.3.1.1 WeakMap([iterable])
									if (arguments.length > 0) {
										// Currently, WeakMap `iterable` argument is not supported
										throw new TypeError('WeakMap iterable is not supported');
									}
								}

								// ECMA-262 23.3.3.2 WeakMap.prototype.delete(key)
								defineProperty(WeakMap.prototype, 'delete', function(key) {
									checkInstance(this, 'delete');

									if (!isObject(key)) {
										return false;
									}

									var entry = key[this._id];
									if (entry && entry[0] === key) {
										delete key[this._id];
										return true;
									}

									return false;
								});

								// ECMA-262 23.3.3.3 WeakMap.prototype.get(key)
								defineProperty(WeakMap.prototype, 'get', function(key) {
									checkInstance(this, 'get');

									if (!isObject(key)) {
										return void 0;
									}

									var entry = key[this._id];
									if (entry && entry[0] === key) {
										return entry[1];
									}

									return void 0;
								});

								// ECMA-262 23.3.3.4 WeakMap.prototype.has(key)
								defineProperty(WeakMap.prototype, 'has', function(key) {
									checkInstance(this, 'has');

									if (!isObject(key)) {
										return false;
									}

									var entry = key[this._id];
									if (entry && entry[0] === key) {
										return true;
									}

									return false;
								});

								// ECMA-262 23.3.3.5 WeakMap.prototype.set(key, value)
								defineProperty(WeakMap.prototype, 'set', function(key, value) {
									checkInstance(this, 'set');

									if (!isObject(key)) {
										throw new TypeError('Invalid value used as weak map key');
									}

									var entry = key[this._id];
									if (entry && entry[0] === key) {
										entry[1] = value;
										return this;
									}

									defineProperty(key, this._id, [key, value]);
									return this;
								});

								function checkInstance(x, methodName) {
									if (!isObject(x) || !hasOwnProperty.call(x, '_id')) {
										throw new TypeError(
											methodName +
												' method called on incompatible receiver ' +
												typeof x
										);
									}
								}

								function genId(prefix) {
									return prefix + '_' + rand() + '.' + rand();
								}

								function rand() {
									return Math.random()
										.toString()
										.substring(2);
								}

								defineProperty(WeakMap, '_polyfill', true);
								return WeakMap;
							})();

							function isObject(x) {
								return Object(x) === x;
							}
						})(
							typeof self !== 'undefined'
								? self
								: typeof window !== 'undefined'
								? window
								: typeof global !== 'undefined'
								? global
								: this
						);
					}.call(
						this,
						typeof global !== 'undefined'
							? global
							: typeof self !== 'undefined'
							? self
							: typeof window !== 'undefined'
							? window
							: {}
					));
				},
				{}
			]
		},
		{},
		[1]
	);

	('use strict');

	/*eslint no-unused-vars: 0*/

	/* exported utils */

	/**
	 * Namespace for utility helper methods.
	 * @namespace utils
	 * @memberof axe
	 */
	var utils = (axe.utils = {});

	('use strict');

	/*eslint no-unused-vars: 0*/

	/*exported helpers */
	var helpers = {};

	('use strict');

	function _typeof(obj) {
		if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
			_typeof = function _typeof(obj) {
				return typeof obj;
			};
		} else {
			_typeof = function _typeof(obj) {
				return obj &&
					typeof Symbol === 'function' &&
					obj.constructor === Symbol &&
					obj !== Symbol.prototype
					? 'symbol'
					: typeof obj;
			};
		}
		return _typeof(obj);
	}

	function _extends() {
		_extends =
			Object.assign ||
			function(target) {
				for (var i = 1; i < arguments.length; i++) {
					var source = arguments[i];
					for (var key in source) {
						if (Object.prototype.hasOwnProperty.call(source, key)) {
							target[key] = source[key];
						}
					}
				}
				return target;
			};
		return _extends.apply(this, arguments);
	}

	/*global Rule, Check, RuleResult, commons: true */
	var dotRegex = /\{\{.+?\}\}/g;
	/*eslint no-unused-vars: 0*/

	function getDefaultConfiguration(audit) {
		'use strict';

		var config;

		if (audit) {
			config = axe.utils.clone(audit); // Commons are configured into axe like everything else,
			// however because things go funky if we have multiple commons objects
			// we're not using the copy of that.

			config.commons = audit.commons;
		} else {
			config = {};
		}

		config.reporter = config.reporter || null;
		config.rules = config.rules || [];
		config.checks = config.checks || [];
		config.data = _extends(
			{
				checks: {},
				rules: {}
			},
			config.data
		);
		return config;
	}

	function unpackToObject(collection, audit, method) {
		'use strict';

		var i, l;

		for (i = 0, l = collection.length; i < l; i++) {
			audit[method](collection[i]);
		}
	}
	/**
	 * Constructor which holds configured rules and information about the document under test
	 */

	function Audit(audit) {
		// defaults
		this.brand = 'axe';
		this.application = 'axeAPI';
		this.tagExclude = ['experimental'];
		this.lang = 'en';
		this.defaultConfig = audit;

		this._init(); // A copy of the "default" locale. This will be set if the user
		// provides a new locale to `axe.configure()` and used to undo
		// changes in `axe.reset()`.

		this._defaultLocale = null;
	}
	/**
	 * Build and set the previous locale. Will noop if a previous
	 * locale was already set, as we want the ability to "reset"
	 * to the default ("first") configuration.
	 */

	Audit.prototype._setDefaultLocale = function() {
		if (this._defaultLocale) {
			return;
		}

		var locale = {
			checks: {},
			rules: {},
			failureSummaries: {},
			incompleteFallbackMessage: '',
			lang: this.lang
		}; // XXX: unable to use `for-of` here, as doing so would
		// require us to polyfill `Symbol`.

		var checkIDs = Object.keys(this.data.checks);

		for (var i = 0; i < checkIDs.length; i++) {
			var id = checkIDs[i];
			var check = this.data.checks[id];
			var _check$messages = check.messages,
				pass = _check$messages.pass,
				fail = _check$messages.fail,
				incomplete = _check$messages.incomplete;
			locale.checks[id] = {
				pass: pass,
				fail: fail,
				incomplete: incomplete
			};
		}

		var ruleIDs = Object.keys(this.data.rules);

		for (var _i = 0; _i < ruleIDs.length; _i++) {
			var _id = ruleIDs[_i];
			var rule = this.data.rules[_id];
			var description = rule.description,
				help = rule.help;
			locale.rules[_id] = {
				description: description,
				help: help
			};
		}

		var failureSummaries = Object.keys(this.data.failureSummaries);

		for (var _i2 = 0; _i2 < failureSummaries.length; _i2++) {
			var type = failureSummaries[_i2];
			var failureSummary = this.data.failureSummaries[type];
			var failureMessage = failureSummary.failureMessage;
			locale.failureSummaries[type] = {
				failureMessage: failureMessage
			};
		}

		locale.incompleteFallbackMessage = this.data.incompleteFallbackMessage;
		this._defaultLocale = locale;
	};
	/**
	 * Reset the locale to the "default".
	 */

	Audit.prototype._resetLocale = function() {
		// If the default locale has not already been set, we can exit early.
		var defaultLocale = this._defaultLocale;

		if (!defaultLocale) {
			return;
		} // Apply the default locale

		this.applyLocale(defaultLocale);
	};
	/**
	 * Merge two check locales (a, b), favoring `b`.
	 *
	 * Both locale `a` and the returned shape resemble:
	 *
	 *    {
	 *      impact: string,
	 *      messages: {
	 *        pass: string | function,
	 *        fail: string | function,
	 *        incomplete: string | {
	 *          [key: string]: string | function
	 *        }
	 *      }
	 *    }
	 *
	 * Locale `b` follows the `axe.CheckLocale` shape and resembles:
	 *
	 *    {
	 *      pass: string,
	 *      fail: string,
	 *      incomplete: string | { [key: string]: string }
	 *    }
	 */

	var mergeCheckLocale = function mergeCheckLocale(a, b) {
		var pass = b.pass,
			fail = b.fail; // If the message(s) are Strings, they have not yet been run
		// thru doT (which will return a Function).

		if (typeof pass === 'string' && dotRegex.test(pass)) {
			pass = axe.imports.doT.compile(pass);
		}

		if (typeof fail === 'string' && dotRegex.test(fail)) {
			fail = axe.imports.doT.compile(fail);
		}

		return _extends({}, a, {
			messages: {
				pass: pass || a.messages.pass,
				fail: fail || a.messages.fail,
				incomplete:
					_typeof(a.messages.incomplete) === 'object' // TODO: for compleness-sake, we should be running
						? // incomplete messages thru doT as well. This was
						  // out-of-scope for runtime localization, but should
						  // eventually be addressed.
						  _extends({}, a.messages.incomplete, {}, b.incomplete)
						: b.incomplete
			}
		});
	};
	/**
	 * Merge two rule locales (a, b), favoring `b`.
	 */

	var mergeRuleLocale = function mergeRuleLocale(a, b) {
		var help = b.help,
			description = b.description; // If the message(s) are Strings, they have not yet been run
		// thru doT (which will return a Function).

		if (typeof help === 'string' && dotRegex.test(help)) {
			help = axe.imports.doT.compile(help);
		}

		if (typeof description === 'string' && dotRegex.test(description)) {
			description = axe.imports.doT.compile(description);
		}

		return _extends({}, a, {
			help: help || a.help,
			description: description || a.description
		});
	};
	/**
	 * Merge two failure messages (a, b), favoring `b`.
	 */

	var mergeFailureMessage = function mergeFailureMessage(a, b) {
		var failureMessage = b.failureMessage; // If the message(s) are Strings, they have not yet been run
		// thru doT (which will return a Function).

		if (typeof failureMessage === 'string' && dotRegex.test(failureMessage)) {
			failureMessage = axe.imports.doT.compile(failureMessage);
		}

		return _extends({}, a, {
			failureMessage: failureMessage || a.failureMessage
		});
	};
	/**
	 * Merge two incomplete fallback messages (a, b), favoring `b`.
	 */

	var mergeFallbackMessage = function mergeFallbackMessage(a, b) {
		if (typeof b === 'string' && dotRegex.test(b)) {
			b = axe.imports.doT.compile(b);
		}

		return b || a;
	};
	/**
	 * Apply locale for the given `checks`.
	 */

	Audit.prototype._applyCheckLocale = function(checks) {
		var keys = Object.keys(checks);

		for (var i = 0; i < keys.length; i++) {
			var id = keys[i];

			if (!this.data.checks[id]) {
				throw new Error('Locale provided for unknown check: "'.concat(id, '"'));
			}

			this.data.checks[id] = mergeCheckLocale(this.data.checks[id], checks[id]);
		}
	};
	/**
	 * Apply locale for the given `rules`.
	 */

	Audit.prototype._applyRuleLocale = function(rules) {
		var keys = Object.keys(rules);

		for (var i = 0; i < keys.length; i++) {
			var id = keys[i];

			if (!this.data.rules[id]) {
				throw new Error('Locale provided for unknown rule: "'.concat(id, '"'));
			}

			this.data.rules[id] = mergeRuleLocale(this.data.rules[id], rules[id]);
		}
	};
	/**
	 * Apply locale for the given failureMessage
	 */

	Audit.prototype._applyFailureSummaries = function(messages) {
		var keys = Object.keys(messages);

		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];

			if (!this.data.failureSummaries[key]) {
				throw new Error(
					'Locale provided for unknown failureMessage: "'.concat(key, '"')
				);
			}

			this.data.failureSummaries[key] = mergeFailureMessage(
				this.data.failureSummaries[key],
				messages[key]
			);
		}
	};
	/**
	 * Apply the given `locale`.
	 *
	 * @param {axe.Locale}
	 */

	Audit.prototype.applyLocale = function(locale) {
		this._setDefaultLocale();

		if (locale.checks) {
			this._applyCheckLocale(locale.checks);
		}

		if (locale.rules) {
			this._applyRuleLocale(locale.rules);
		}

		if (locale.failureSummaries) {
			this._applyFailureSummaries(locale.failureSummaries, 'failureSummaries');
		}

		if (locale.incompleteFallbackMessage) {
			this.data.incompleteFallbackMessage = mergeFallbackMessage(
				this.data.incompleteFallbackMessage,
				locale.incompleteFallbackMessage
			);
		}

		if (locale.lang) {
			this.lang = locale.lang;
		}
	};
	/**
	 * Initializes the rules and checks
	 */

	Audit.prototype._init = function() {
		var audit = getDefaultConfiguration(this.defaultConfig);
		axe.commons = commons = audit.commons;
		this.lang = audit.lang || 'en';
		this.reporter = audit.reporter;
		this.commands = {};
		this.rules = [];
		this.checks = {};
		unpackToObject(audit.rules, this, 'addRule');
		unpackToObject(audit.checks, this, 'addCheck');
		this.data = {};
		this.data.checks = (audit.data && audit.data.checks) || {};
		this.data.rules = (audit.data && audit.data.rules) || {};
		this.data.failureSummaries =
			(audit.data && audit.data.failureSummaries) || {};
		this.data.incompleteFallbackMessage =
			(audit.data && audit.data.incompleteFallbackMessage) || '';

		this._constructHelpUrls(); // create default helpUrls
	};
	/**
	 * Adds a new command to the audit
	 */

	Audit.prototype.registerCommand = function(command) {
		'use strict';

		this.commands[command.id] = command.callback;
	};
	/**
	 * Adds a new rule to the Audit.  If a rule with specified ID already exists, it will be overridden
	 * @param {Object} spec Rule specification object
	 */

	Audit.prototype.addRule = function(spec) {
		'use strict';

		if (spec.metadata) {
			this.data.rules[spec.id] = spec.metadata;
		}

		var rule = this.getRule(spec.id);

		if (rule) {
			rule.configure(spec);
		} else {
			this.rules.push(new Rule(spec, this));
		}
	};
	/**
	 * Adds a new check to the Audit.  If a Check with specified ID already exists, it will be
	 * reconfigured
	 *
	 * @param {Object} spec Check specification object
	 */

	Audit.prototype.addCheck = function(spec) {
		/*eslint no-eval: 0 */
		'use strict';

		var metadata = spec.metadata;

		if (_typeof(metadata) === 'object') {
			this.data.checks[spec.id] = metadata; // Transform messages into functions:

			if (_typeof(metadata.messages) === 'object') {
				Object.keys(metadata.messages)
					.filter(function(prop) {
						return (
							metadata.messages.hasOwnProperty(prop) &&
							typeof metadata.messages[prop] === 'string'
						);
					})
					.forEach(function(prop) {
						if (metadata.messages[prop].indexOf('function') === 0) {
							metadata.messages[prop] = new Function(
								'return ' + metadata.messages[prop] + ';'
							)();
						}
					});
			}
		}

		if (this.checks[spec.id]) {
			this.checks[spec.id].configure(spec);
		} else {
			this.checks[spec.id] = new Check(spec);
		}
	};
	/**
	 * Splits a given array of rules to two, with rules that can be run immediately and one's that are dependent on preloadedAssets
	 * @method getRulesToRun
	 * @param {Array<Object>} rules complete list of rules
	 * @param {Object} context
	 * @param {Object} options
	 * @return {Object} out, an object containing two arrays, one being list of rules to run now and list of rules to run later
	 * @private
	 */

	function getRulesToRun(rules, context, options) {
		// entry object for reduce function below
		var base = {
			now: [],
			later: []
		}; // iterate through rules and separate out rules that need to be run now vs later

		var splitRules = rules.reduce(function(out, rule) {
			// ensure rule can run
			if (!axe.utils.ruleShouldRun(rule, context, options)) {
				return out;
			} // does rule require preload assets - push to later array

			if (rule.preload) {
				out.later.push(rule);
				return out;
			} // default to now array

			out.now.push(rule); // return

			return out;
		}, base); // return

		return splitRules;
	}
	/**
	 * Convenience method, that consturcts a rule `run` function that can be deferred
	 * @param {Object} rule rule to be deferred
	 * @param {Object} context context object essential to be passed into rule `run`
	 * @param {Object} options normalised options to be passed into rule `run`
	 * @param {Object} assets (optional) preloaded assets to be passed into rule and checks (if the rule is preload dependent)
	 * @return {Function} a deferrable function for rule
	 */

	function getDefferedRule(rule, context, options) {
		// init performance timer of requested via options
		if (options.performanceTimer) {
			axe.utils.performanceTimer.mark('mark_rule_start_' + rule.id);
		}

		return function(resolve, reject) {
			// invoke `rule.run`
			rule.run(
				context,
				options, // resolve callback for rule `run`
				function(ruleResult) {
					// resolve
					resolve(ruleResult);
				}, // reject callback for rule `run`
				function(err) {
					// if debug - construct error details
					if (!options.debug) {
						var errResult = Object.assign(new RuleResult(rule), {
							result: axe.constants.CANTTELL,
							description: 'An error occured while running this rule',
							message: err.message,
							stack: err.stack,
							error: err,
							// Add a serialized reference to the node the rule failed on for easier debugging.
							// See https://github.com/dequelabs/axe-core/issues/1317.
							errorNode: err.errorNode
						}); // resolve

						resolve(errResult);
					} else {
						// reject
						reject(err);
					}
				}
			);
		};
	}
	/**
	 * Runs the Audit; which in turn should call `run` on each rule.
	 * @async
	 * @param  {Context}   context The scope definition/context for analysis (include/exclude)
	 * @param  {Object}    options Options object to pass into rules and/or disable rules or checks
	 * @param  {Function} fn       Callback function to fire when audit is complete
	 */

	Audit.prototype.run = function(context, options, resolve, reject) {
		'use strict';

		this.normalizeOptions(options);
		axe._selectCache = []; // get a list of rules to run NOW vs. LATER (later are preload assets dependent rules)

		var allRulesToRun = getRulesToRun(this.rules, context, options);
		var runNowRules = allRulesToRun.now;
		var runLaterRules = allRulesToRun.later; // init a NOW queue for rules to run immediately

		var nowRulesQueue = axe.utils.queue(); // construct can run NOW rules into NOW queue

		runNowRules.forEach(function(rule) {
			nowRulesQueue.defer(getDefferedRule(rule, context, options));
		}); // init a PRELOADER queue to start preloading assets

		var preloaderQueue = axe.utils.queue(); // defer preload if preload dependent rules exist

		if (runLaterRules.length) {
			preloaderQueue.defer(function(resolve) {
				// handle both success and fail of preload
				// and resolve, to allow to run all checks
				axe.utils
					.preload(options)
					.then(function(assets) {
						return resolve(assets);
					})
					['catch'](function(err) {
						/**
						 * Note:
						 * we do not reject, to allow other (non-preload) rules to `run`
						 * -> instead we resolve as `undefined`
						 */
						console.warn("Couldn't load preload assets: ", err);
						resolve(undefined);
					});
			});
		} // defer now and preload queue to run immediately

		var queueForNowRulesAndPreloader = axe.utils.queue();
		queueForNowRulesAndPreloader.defer(nowRulesQueue);
		queueForNowRulesAndPreloader.defer(preloaderQueue); // invoke the now queue

		queueForNowRulesAndPreloader
			.then(function(nowRulesAndPreloaderResults) {
				// interpolate results into separate variables
				var assetsFromQueue = nowRulesAndPreloaderResults.pop();

				if (assetsFromQueue && assetsFromQueue.length) {
					// result is a queue (again), hence the index resolution
					// assets is either an object of key value pairs of asset type and values
					// eg: cssom: [stylesheets]
					// or undefined if preload failed
					var assets = assetsFromQueue[0]; // extend context with preloaded assets

					if (assets) {
						context = _extends({}, context, {}, assets);
					}
				} // the reminder of the results are RuleResults

				var nowRulesResults = nowRulesAndPreloaderResults[0]; // if there are no rules to run LATER - resolve with rule results

				if (!runLaterRules.length) {
					// remove the cache
					axe._selectCache = undefined; // resolve

					resolve(
						nowRulesResults.filter(function(result) {
							return !!result;
						})
					);
					return;
				} // init a LATER queue for rules that are dependant on preloaded assets

				var laterRulesQueue = axe.utils.queue();
				runLaterRules.forEach(function(rule) {
					var deferredRule = getDefferedRule(rule, context, options);
					laterRulesQueue.defer(deferredRule);
				}); // invoke the later queue

				laterRulesQueue
					.then(function(laterRuleResults) {
						// remove the cache
						axe._selectCache = undefined; // resolve

						resolve(
							nowRulesResults.concat(laterRuleResults).filter(function(result) {
								return !!result;
							})
						);
					})
					['catch'](reject);
			})
			['catch'](reject);
	};
	/**
	 * Runs Rule `after` post processing functions
	 * @param  {Array} results  Array of RuleResults to postprocess
	 * @param  {Mixed} options  Options object to pass into rules and/or disable rules or checks
	 */

	Audit.prototype.after = function(results, options) {
		'use strict';

		var rules = this.rules;
		return results.map(function(ruleResult) {
			var rule = axe.utils.findBy(rules, 'id', ruleResult.id);

			if (!rule) {
				// If you see this, you're probably running the Mocha tests with the axe extension installed
				throw new Error(
					'Result for unknown rule. You may be running mismatch axe-core versions'
				);
			}

			return rule.after(ruleResult, options);
		});
	};
	/**
	 * Get the rule with a given ID
	 * @param  {string}
	 * @return {Rule}
	 */

	Audit.prototype.getRule = function(ruleId) {
		return this.rules.find(function(rule) {
			return rule.id === ruleId;
		});
	};
	/**
	 * Ensure all rules that are expected to run exist
	 * @throws {Error} If any tag or rule specified in options is unknown
	 * @param  {Object} options  Options object
	 * @return {Object}          Validated options object
	 */

	Audit.prototype.normalizeOptions = function(options) {
		'use strict';

		var audit = this;
		var tags = [];
		var ruleIds = [];
		audit.rules.forEach(function(rule) {
			ruleIds.push(rule.id);
			rule.tags.forEach(function(tag) {
				if (!tags.includes(tag)) {
					tags.push(tag);
				}
			});
		}); // Validate runOnly

		if (_typeof(options.runOnly) === 'object') {
			if (Array.isArray(options.runOnly)) {
				var hasTag = options.runOnly.find(function(value) {
					return tags.includes(value);
				});
				var hasRule = options.runOnly.find(function(value) {
					return ruleIds.includes(value);
				});

				if (hasTag && hasRule) {
					throw new Error('runOnly cannot be both rules and tags');
				}

				if (hasRule) {
					options.runOnly = {
						type: 'rule',
						values: options.runOnly
					};
				} else {
					options.runOnly = {
						type: 'tag',
						values: options.runOnly
					};
				}
			}

			var only = options.runOnly;

			if (only.value && !only.values) {
				only.values = only.value;
				delete only.value;
			}

			if (!Array.isArray(only.values) || only.values.length === 0) {
				throw new Error('runOnly.values must be a non-empty array');
			} // Check if every value in options.runOnly is a known rule ID

			if (['rule', 'rules'].includes(only.type)) {
				only.type = 'rule';
				only.values.forEach(function(ruleId) {
					if (!ruleIds.includes(ruleId)) {
						throw new Error('unknown rule `' + ruleId + '` in options.runOnly');
					}
				}); // Validate 'tags' (e.g. anything not 'rule')
			} else if (['tag', 'tags', undefined].includes(only.type)) {
				only.type = 'tag';
				var unmatchedTags = only.values.filter(function(tag) {
					return !tags.includes(tag);
				});

				if (unmatchedTags.length !== 0) {
					axe.log('Could not find tags `' + unmatchedTags.join('`, `') + '`');
				}
			} else {
				throw new Error("Unknown runOnly type '".concat(only.type, "'"));
			}
		}

		if (_typeof(options.rules) === 'object') {
			Object.keys(options.rules).forEach(function(ruleId) {
				if (!ruleIds.includes(ruleId)) {
					throw new Error('unknown rule `' + ruleId + '` in options.rules');
				}
			});
		}

		return options;
	};
	/*
	 * Updates the default options and then applies them
	 * @param  {Mixed} options  Options object
	 */

	Audit.prototype.setBranding = function(branding) {
		'use strict';

		var previous = {
			brand: this.brand,
			application: this.application
		};

		if (
			branding &&
			branding.hasOwnProperty('brand') &&
			branding.brand &&
			typeof branding.brand === 'string'
		) {
			this.brand = branding.brand;
		}

		if (
			branding &&
			branding.hasOwnProperty('application') &&
			branding.application &&
			typeof branding.application === 'string'
		) {
			this.application = branding.application;
		}

		this._constructHelpUrls(previous);
	};
	/**
	 * For all the rules, create the helpUrl and add it to the data for that rule
	 */

	function getHelpUrl(_ref, ruleId, version) {
		var brand = _ref.brand,
			application = _ref.application,
			lang = _ref.lang;
		return (
			axe.constants.helpUrlBase +
			brand +
			'/' +
			(version || axe.version.substring(0, axe.version.lastIndexOf('.'))) +
			'/' +
			ruleId +
			'?application=' +
			encodeURIComponent(application) +
			(lang && lang !== 'en' ? '&lang=' + encodeURIComponent(lang) : '')
		);
	}

	Audit.prototype._constructHelpUrls = function() {
		var _this = this;

		var previous =
			arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
		var version = (axe.version.match(/^[1-9][0-9]*\.[0-9]+/) || ['x.y'])[0];
		this.rules.forEach(function(rule) {
			if (!_this.data.rules[rule.id]) {
				_this.data.rules[rule.id] = {};
			}

			var metaData = _this.data.rules[rule.id];

			if (
				typeof metaData.helpUrl !== 'string' ||
				(previous &&
					metaData.helpUrl === getHelpUrl(previous, rule.id, version))
			) {
				metaData.helpUrl = getHelpUrl(_this, rule.id, version);
			}
		});
	};
	/**
	 * Reset the default rules, checks and meta data
	 */

	Audit.prototype.resetRulesAndChecks = function() {
		'use strict';

		this._init();

		this._resetLocale();
	};

	('use strict');

	(function() {
		'use strict';

		var _cache = {};
		var cache = {
			/**
			 * Set an item in the cache.
			 * @param {String} key - Name of the key.
			 * @param {*} value - Value to store.
			 */
			set: function set(key, value) {
				_cache[key] = value;
			},

			/**
			 * Retrieve an item from the cache.
			 * @param {String} key - Name of the key the value was stored as.
			 * @returns {*} The item stored
			 */
			get: function get(key) {
				return _cache[key];
			},

			/**
			 * Clear the cache.
			 */
			clear: function clear() {
				_cache = {};
			}
		};
		axe._cache = cache;
	})();

	('use strict');

	/*exported CheckResult */

	/*eslint no-unused-vars: 0*/

	/**
	 * Constructor for the result of checks
	 * @param {Check} check
	 */
	function CheckResult(check) {
		'use strict';
		/**
		 * ID of the check.  Unique in the context of a rule.
		 * @type {String}
		 */

		this.id = check.id;
		/**
		 * Any data passed by Check (by calling `this.data()`)
		 * @type {Mixed}
		 */

		this.data = null;
		/**
		 * Any node that is related to the Check, specified by calling `this.relatedNodes([HTMLElement...])` inside the Check
		 * @type {Array}
		 */

		this.relatedNodes = [];
		/**
		 * The return value of the Check's evaluate function
		 * @type {Mixed}
		 */

		this.result = null;
	}

	('use strict');

	/*global CheckResult,DqElement */
	function createExecutionContext(spec) {
		/*eslint no-eval:0 */
		'use strict';

		if (typeof spec === 'string') {
			return new Function('return ' + spec + ';')();
		}

		return spec;
	}

	function Check(spec) {
		if (spec) {
			this.id = spec.id;
			this.configure(spec);
		}
	}
	/**
	 * Unique ID for the check.  Checks may be re-used, so there may be additional instances of checks
	 * with the same ID.
	 * @type {String}
	 */
	// Check.prototype.id;

	/**
	 * Free-form options that are passed as the second parameter to the `evaluate`
	 * @type {Mixed}
	 */
	// Check.prototype.options;

	/**
	 * The actual code, accepts 2 parameters: node (the node under test), options (see this.options).
	 * This function is run in the context of a checkHelper, which has the following methods
	 * - `async()` - if called, the check is considered to be asynchronous; returns a callback function
	 * - `data()` - free-form data object, associated to the `CheckResult` which is specific to each node
	 * @type {Function}
	 */
	// Check.prototype.evaluate;

	/**
	 * Optional. Filter and/or modify checks for all nodes
	 * @type {Function}
	 */
	// Check.prototype.after;

	/**
	 * enabled by default, if false, this check will not be included in the rule's evaluation
	 * @type {Boolean}
	 */

	Check.prototype.enabled = true;
	/**
	 * Run the check's evaluate function (call `this.evaluate(node, options)`)
	 * @param  {HTMLElement} node  The node to test
	 * @param  {Object} options    The options that override the defaults and provide additional
	 *                             information for the check
	 * @param  {Function} callback Function to fire when check is complete
	 */

	Check.prototype.run = function(node, options, context, resolve, reject) {
		'use strict';

		options = options || {};
		var enabled = options.hasOwnProperty('enabled')
				? options.enabled
				: this.enabled,
			checkOptions = options.options || this.options;

		if (enabled) {
			var checkResult = new CheckResult(this);
			var checkHelper = axe.utils.checkHelper(
				checkResult,
				options,
				resolve,
				reject
			);
			var result;

			try {
				result = this.evaluate.call(
					checkHelper,
					node.actualNode,
					checkOptions,
					node,
					context
				);
			} catch (e) {
				// In the "Audit#run: should run all the rules" test, there is no `node` here. I do
				// not know if this is intentional or not, so to be safe, we guard against the
				// possible reference error.
				if (node && node.actualNode) {
					// Save a reference to the node we errored on for futher debugging.
					e.errorNode = new DqElement(node.actualNode).toJSON();
				}

				reject(e);
				return;
			}

			if (!checkHelper.isAsync) {
				checkResult.result = result;
				resolve(checkResult);
			}
		} else {
			resolve(null);
		}
	};
	/**
	 * Run the check's evaluate function (call `this.evaluate(node, options)`) synchronously
	 * @param  {HTMLElement} node  The node to test
	 * @param  {Object} options    The options that override the defaults and provide additional
	 *                             information for the check
	 */

	Check.prototype.runSync = function(node, options, context) {
		options = options || {};
		var _options = options,
			_options$enabled = _options.enabled,
			enabled = _options$enabled === void 0 ? this.enabled : _options$enabled;

		if (!enabled) {
			return null;
		}

		var checkOptions = options.options || this.options;
		var checkResult = new CheckResult(this);
		var checkHelper = axe.utils.checkHelper(checkResult, options); // throw error if a check is run that requires async behavior

		checkHelper.async = function() {
			throw new Error('Cannot run async check while in a synchronous run');
		};

		var result;

		try {
			result = this.evaluate.call(
				checkHelper,
				node.actualNode,
				checkOptions,
				node,
				context
			);
		} catch (e) {
			// In the "Audit#run: should run all the rules" test, there is no `node` here. I do
			// not know if this is intentional or not, so to be safe, we guard against the
			// possible reference error.
			if (node && node.actualNode) {
				// Save a reference to the node we errored on for futher debugging.
				e.errorNode = new DqElement(node.actualNode).toJSON();
			}

			throw e;
		}

		checkResult.result = result;
		return checkResult;
	};
	/**
	 * Override a check's settings after construction to allow for changing options
	 * without having to implement the entire check
	 *
	 * @param {Object} spec - the specification of the attributes to be changed
	 */

	Check.prototype.configure = function(spec) {
		var _this = this;

		['options', 'enabled']
			.filter(function(prop) {
				return spec.hasOwnProperty(prop);
			})
			.forEach(function(prop) {
				return (_this[prop] = spec[prop]);
			});
		['evaluate', 'after']
			.filter(function(prop) {
				return spec.hasOwnProperty(prop);
			})
			.forEach(function(prop) {
				return (_this[prop] = createExecutionContext(spec[prop]));
			});
	};

	('use strict');

	function _typeof(obj) {
		if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
			_typeof = function _typeof(obj) {
				return typeof obj;
			};
		} else {
			_typeof = function _typeof(obj) {
				return obj &&
					typeof Symbol === 'function' &&
					obj.constructor === Symbol &&
					obj !== Symbol.prototype
					? 'symbol'
					: typeof obj;
			};
		}
		return _typeof(obj);
	}

	/*exported Context */

	/*global isNodeInContext */

	/**
	 * Pushes a unique frame onto `frames` array, filtering any hidden iframes
	 * @private
	 * @param  {Array} collection The array of unique frames that is being operated on
	 * @param  {HTMLElement} frame   The frame to push onto Context
	 */
	function pushUniqueFrame(collection, frame) {
		'use strict';

		if (axe.utils.isHidden(frame)) {
			return;
		}

		var fr = axe.utils.findBy(collection, 'node', frame);

		if (!fr) {
			collection.push({
				node: frame,
				include: [],
				exclude: []
			});
		}
	}
	/**
	 * Unshift selectors of matching iframes
	 * @private
	 * @param  {Context} context 	  The context object to operate on and assign to
	 * @param  {String} type          The "type" of context, 'include' or 'exclude'
	 * @param  {Array} selectorArray  Array of CSS selectors, each element represents a frame;
	 * where the last element is the actual node
	 */

	function pushUniqueFrameSelector(context, type, selectorArray) {
		'use strict';

		context.frames = context.frames || [];
		var result, frame;
		var frames = document.querySelectorAll(selectorArray.shift());

		frameloop: for (var i = 0, l = frames.length; i < l; i++) {
			frame = frames[i];

			for (var j = 0, l2 = context.frames.length; j < l2; j++) {
				if (context.frames[j].node === frame) {
					context.frames[j][type].push(selectorArray);
					break frameloop;
				}
			}

			result = {
				node: frame,
				include: [],
				exclude: []
			};

			if (selectorArray) {
				result[type].push(selectorArray);
			}

			context.frames.push(result);
		}
	}
	/**
	 * Normalize the input of "context" so that many different methods of input are accepted
	 * @private
	 * @param  {Mixed} context  The configuration object passed to `Context`
	 * @return {Object}         Normalized context spec to include both `include` and `exclude` arrays
	 */

	function normalizeContext(context) {
		'use strict'; // typeof NodeList.length in PhantomJS === function

		if (
			(context && _typeof(context) === 'object') ||
			context instanceof NodeList
		) {
			if (context instanceof Node) {
				return {
					include: [context],
					exclude: []
				};
			}

			if (
				context.hasOwnProperty('include') ||
				context.hasOwnProperty('exclude')
			) {
				return {
					include:
						context.include && +context.include.length
							? context.include
							: [document],
					exclude: context.exclude || []
				};
			}

			if (context.length === +context.length) {
				return {
					include: context,
					exclude: []
				};
			}
		}

		if (typeof context === 'string') {
			return {
				include: [context],
				exclude: []
			};
		}

		return {
			include: [document],
			exclude: []
		};
	}
	/**
	 * Finds frames in context, converts selectors to Element references and pushes unique frames
	 * @private
	 * @param  {Context} context The instance of Context to operate on
	 * @param  {String} type     The "type" of thing to parse, "include" or "exclude"
	 * @return {Array}           Parsed array of matching elements
	 */

	function parseSelectorArray(context, type) {
		'use strict';

		var item,
			result = [],
			nodeList;

		for (var i = 0, l = context[type].length; i < l; i++) {
			item = context[type][i]; // selector

			if (typeof item === 'string') {
				nodeList = Array.from(document.querySelectorAll(item)); //eslint no-loop-func:0

				result = result.concat(
					nodeList.map(function(node) {
						return axe.utils.getNodeFromTree(node);
					})
				);
				break;
			} else if (item && item.length && !(item instanceof Node)) {
				if (item.length > 1) {
					pushUniqueFrameSelector(context, type, item);
				} else {
					nodeList = Array.from(document.querySelectorAll(item[0])); //eslint no-loop-func:0

					result = result.concat(
						nodeList.map(function(node) {
							return axe.utils.getNodeFromTree(node);
						})
					);
				}
			} else if (item instanceof Node) {
				if (item.documentElement instanceof Node) {
					result.push(context.flatTree[0]);
				} else {
					result.push(axe.utils.getNodeFromTree(item));
				}
			}
		} // filter nulls

		return result.filter(function(r) {
			return r;
		});
	}
	/**
	 * Check that the context, as well as each frame includes at least 1 element
	 * @private
	 * @param  {context} context
	 * @return {Error}
	 */

	function validateContext(context) {
		'use strict';

		if (context.include.length === 0) {
			if (context.frames.length === 0) {
				var env = axe.utils.respondable.isInFrame() ? 'frame' : 'page';
				return new Error(
					'No elements found for include in ' + env + ' Context'
				);
			}

			context.frames.forEach(function(frame, i) {
				if (frame.include.length === 0) {
					return new Error(
						'No elements found for include in Context of frame ' + i
					);
				}
			});
		}
	}
	/**
	 * For a context-like object, find its shared root node
	 */

	function getRootNode(_ref) {
		var include = _ref.include,
			exclude = _ref.exclude;
		var selectors = Array.from(include).concat(Array.from(exclude)); // Find the first Element.ownerDocument or Document

		for (var i = 0; i < selectors.length; ++i) {
			var item = selectors[i];

			if (item instanceof Element) {
				return item.ownerDocument.documentElement;
			}

			if (item instanceof Document) {
				return item.documentElement;
			}
		}

		return document.documentElement;
	}
	/**
	 * Holds context of includes, excludes and frames for analysis.
	 *
	 * @todo  clarify and sync changes to design doc
	 * Context : {IncludeStrings} || {
	 *   // defaults to document/all
	 *   include: {IncludeStrings},
	 *   exclude : {ExcludeStrings}
	 * }
	 *
	 * IncludeStrings : [{CSSSelectorArray}] || Node
	 * ExcludeStrings : [{CSSSelectorArray}]
	 * `CSSSelectorArray` an Array of selector strings that addresses a Node in a multi-frame document. All addresses
	 * are in this form regardless of whether the document contains any frames.To evaluate the selectors to
	 * find the node referenced by the array, evaluate the selectors in-order, starting in window.top. If N
	 * is the length of the array, then the first N-1 selectors should result in an iframe and the last
	 * selector should result in the specific node.
	 *
	 * @param {Object} spec Configuration or "specification" object
	 */

	function Context(spec) {
		/* eslint no-unused-vars:0 */
		'use strict';

		var _this = this;

		this.frames = [];
		this.initiator =
			spec && typeof spec.initiator === 'boolean' ? spec.initiator : true;
		this.page = false;
		spec = normalizeContext(spec); //cache the flattened tree

		this.flatTree = axe.utils.getFlattenedTree(getRootNode(spec));
		this.exclude = spec.exclude;
		this.include = spec.include;
		this.include = parseSelectorArray(this, 'include');
		this.exclude = parseSelectorArray(this, 'exclude');
		axe.utils.select('frame, iframe', this).forEach(function(frame) {
			if (isNodeInContext(frame, _this)) {
				pushUniqueFrame(_this.frames, frame.actualNode);
			}
		});

		if (
			this.include.length === 1 &&
			this.include[0].actualNode === document.documentElement
		) {
			this.page = true;
		} // Validate outside of a frame

		var err = validateContext(this);

		if (err instanceof Error) {
			throw err;
		}

		if (!Array.isArray(this.include)) {
			this.include = Array.from(this.include);
		}

		this.include.sort(axe.utils.nodeSorter); // ensure that the order of the include nodes is document order
	}

	('use strict');

	/*exported RuleResult */

	/*eslint no-unused-vars:0*/

	/**
	 * Constructor for the result of Rules
	 * @param {Rule} rule
	 */
	function RuleResult(rule) {
		'use strict';
		/**
		 * The ID of the Rule whom this result belongs to
		 * @type {String}
		 */

		this.id = rule.id;
		/**
		 * The calculated result of the Rule, either PASS, FAIL or NA
		 * @type {String}
		 */

		this.result = axe.constants.NA;
		/**
		 * Whether the Rule is a "pageLevel" rule
		 * @type {Boolean}
		 */

		this.pageLevel = rule.pageLevel;
		/**
		 * Impact of the violation
		 * @type {String}  Plain-english impact or null if rule passes
		 */

		this.impact = null;
		/**
		 * Holds information regarding nodes and individual CheckResults
		 * @type {Array}
		 */

		this.nodes = [];
	}

	('use strict');

	/*global RuleResult, createExecutionContext, SupportError */
	function Rule(spec, parentAudit) {
		'use strict';

		this._audit = parentAudit;
		/**
		 * The code, or string ID of the rule
		 * @type {String}
		 */

		this.id = spec.id;
		/**
		 * Selector that this rule applies to
		 * @type {String}
		 */

		this.selector = spec.selector || '*';
		/**
		 * Whether to exclude hiddden elements form analysis.  Defaults to true.
		 * @type {Boolean}
		 */

		this.excludeHidden =
			typeof spec.excludeHidden === 'boolean' ? spec.excludeHidden : true;
		/**
		 * Flag to enable or disable rule
		 * @type {Boolean}
		 */

		this.enabled = typeof spec.enabled === 'boolean' ? spec.enabled : true;
		/**
		 * Denotes if the rule should be run if Context is not an entire page AND whether
		 * the Rule should be satisified regardless of Node
		 * @type {Boolean}
		 */

		this.pageLevel =
			typeof spec.pageLevel === 'boolean' ? spec.pageLevel : false;
		/**
		 * Checks that any may return true to satisfy rule
		 * @type {Array}
		 */

		this.any = spec.any || [];
		/**
		 * Checks that must all return true to satisfy rule
		 * @type {Array}
		 */

		this.all = spec.all || [];
		/**
		 * Checks that none may return true to satisfy rule
		 * @type {Array}
		 */

		this.none = spec.none || [];
		/**
		 * Tags associated to this rule
		 * @type {Array}
		 */

		this.tags = spec.tags || [];
		/**
		 * Preload necessary for this rule
		 */

		this.preload = spec.preload ? true : false;

		if (spec.matches) {
			/**
			 * Optional function to test if rule should be run against a node, overrides Rule#matches
			 * @type {Function}
			 */
			this.matches = createExecutionContext(spec.matches);
		}
	}
	/**
	 * Optionally test each node against a `matches` function to determine if the rule should run against
	 * a given node.  Defaults to `true`.
	 * @return {Boolean}    Whether the rule should run
	 */

	Rule.prototype.matches = function() {
		'use strict';

		return true;
	};
	/**
	 * Selects `HTMLElement`s based on configured selector
	 * @param  {Context} context The resolved Context object
	 * @param  {Mixed}   options Options specific to this rule
	 * @return {Array}           All matching `HTMLElement`s
	 */

	Rule.prototype.gather = function(context) {
		var options =
			arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		var markStart = 'mark_gather_start_' + this.id;
		var markEnd = 'mark_gather_end_' + this.id;
		var markHiddenStart = 'mark_isHidden_start_' + this.id;
		var markHiddenEnd = 'mark_isHidden_end_' + this.id;

		if (options.performanceTimer) {
			axe.utils.performanceTimer.mark(markStart);
		}

		var elements = axe.utils.select(this.selector, context);

		if (this.excludeHidden) {
			if (options.performanceTimer) {
				axe.utils.performanceTimer.mark(markHiddenStart);
			}

			elements = elements.filter(function(element) {
				return !axe.utils.isHidden(element.actualNode);
			});

			if (options.performanceTimer) {
				axe.utils.performanceTimer.mark(markHiddenEnd);
				axe.utils.performanceTimer.measure(
					'rule_' + this.id + '#gather_axe.utils.isHidden',
					markHiddenStart,
					markHiddenEnd
				);
			}
		}

		if (options.performanceTimer) {
			axe.utils.performanceTimer.mark(markEnd);
			axe.utils.performanceTimer.measure(
				'rule_' + this.id + '#gather',
				markStart,
				markEnd
			);
		}

		return elements;
	};

	Rule.prototype.runChecks = function(
		type,
		node,
		options,
		context,
		resolve,
		reject
	) {
		'use strict';

		var self = this;
		var checkQueue = axe.utils.queue();
		this[type].forEach(function(c) {
			var check = self._audit.checks[c.id || c];
			var option = axe.utils.getCheckOption(check, self.id, options);
			checkQueue.defer(function(res, rej) {
				check.run(node, option, context, res, rej);
			});
		});
		checkQueue
			.then(function(results) {
				results = results.filter(function(check) {
					return check;
				});
				resolve({
					type: type,
					results: results
				});
			})
			['catch'](reject);
	};
	/**
	 * Run a check for a rule synchronously.
	 */

	Rule.prototype.runChecksSync = function(type, node, options, context) {
		'use strict';

		var self = this;
		var results = [];
		this[type].forEach(function(c) {
			var check = self._audit.checks[c.id || c];
			var option = axe.utils.getCheckOption(check, self.id, options);
			results.push(check.runSync(node, option, context));
		});
		results = results.filter(function(check) {
			return check;
		});
		return {
			type: type,
			results: results
		};
	};
	/**
	 * Runs the Rule's `evaluate` function
	 * @param  {Context}   context  The resolved Context object
	 * @param  {Mixed}   options  Options specific to this rule
	 * @param  {Function} callback Function to call when evaluate is complete; receives a RuleResult instance
	 */

	Rule.prototype.run = function(context) {
		var _this = this;

		var options =
			arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		var resolve = arguments.length > 2 ? arguments[2] : undefined;
		var reject = arguments.length > 3 ? arguments[3] : undefined;

		if (options.performanceTimer) {
			this._trackPerformance();
		}

		var q = axe.utils.queue();
		var ruleResult = new RuleResult(this);
		var nodes;

		try {
			// Matches throws an error when it lacks support for document methods
			nodes = this.gatherAndMatchNodes(context, options);
		} catch (error) {
			// Exit the rule execution if matches fails
			reject(
				new SupportError({
					cause: error,
					ruleId: this.id
				})
			);
			return;
		}

		if (options.performanceTimer) {
			this._logGatherPerformance(nodes);
		}

		nodes.forEach(function(node) {
			q.defer(function(resolveNode, rejectNode) {
				var checkQueue = axe.utils.queue();
				['any', 'all', 'none'].forEach(function(type) {
					checkQueue.defer(function(res, rej) {
						_this.runChecks(type, node, options, context, res, rej);
					});
				});
				checkQueue
					.then(function(results) {
						var result = getResult(results);

						if (result) {
							result.node = new axe.utils.DqElement(node.actualNode, options);
							ruleResult.nodes.push(result);
						}

						resolveNode();
					})
					['catch'](function(err) {
						return rejectNode(err);
					});
			});
		}); // Defer the rule's execution to prevent "unresponsive script" warnings.
		// See https://github.com/dequelabs/axe-core/pull/1172 for discussion and details.

		q.defer(function(resolve) {
			return setTimeout(resolve, 0);
		});

		if (options.performanceTimer) {
			this._logRulePerformance();
		}

		q.then(function() {
			return resolve(ruleResult);
		})['catch'](function(error) {
			return reject(error);
		});
	};
	/**
	 * Runs the Rule's `evaluate` function synchronously
	 * @param  {Context}   context  The resolved Context object
	 * @param  {Mixed}   options  Options specific to this rule
	 */

	Rule.prototype.runSync = function(context) {
		var _this2 = this;

		var options =
			arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		if (options.performanceTimer) {
			this._trackPerformance();
		}

		var ruleResult = new RuleResult(this);
		var nodes;

		try {
			nodes = this.gatherAndMatchNodes(context, options);
		} catch (error) {
			// Exit the rule execution if matches fails
			throw new SupportError({
				cause: error,
				ruleId: this.id
			});
		}

		if (options.performanceTimer) {
			this._logGatherPerformance(nodes);
		}

		nodes.forEach(function(node) {
			var results = [];
			['any', 'all', 'none'].forEach(function(type) {
				results.push(_this2.runChecksSync(type, node, options, context));
			});
			var result = getResult(results);

			if (result) {
				result.node = node.actualNode
					? new axe.utils.DqElement(node.actualNode, options)
					: null;
				ruleResult.nodes.push(result);
			}
		});

		if (options.performanceTimer) {
			this._logRulePerformance();
		}

		return ruleResult;
	};
	/**
	 * Add performance tracking properties to the rule
	 * @private
	 */

	Rule.prototype._trackPerformance = function() {
		this._markStart = 'mark_rule_start_' + this.id;
		this._markEnd = 'mark_rule_end_' + this.id;
		this._markChecksStart = 'mark_runchecks_start_' + this.id;
		this._markChecksEnd = 'mark_runchecks_end_' + this.id;
	};
	/**
	 * Log performance of rule.gather
	 * @private
	 * @param {Rule} rule The rule to log
	 * @param {Array} nodes Result of rule.gather
	 */

	Rule.prototype._logGatherPerformance = function(nodes) {
		axe.log(
			'gather (',
			nodes.length,
			'):',
			axe.utils.performanceTimer.timeElapsed() + 'ms'
		);
		axe.utils.performanceTimer.mark(this._markChecksStart);
	};
	/**
	 * Log performance of the rule
	 * @private
	 * @param {Rule} rule The rule to log
	 */

	Rule.prototype._logRulePerformance = function() {
		axe.utils.performanceTimer.mark(this._markChecksEnd);
		axe.utils.performanceTimer.mark(this._markEnd);
		axe.utils.performanceTimer.measure(
			'runchecks_' + this.id,
			this._markChecksStart,
			this._markChecksEnd
		);
		axe.utils.performanceTimer.measure(
			'rule_' + this.id,
			this._markStart,
			this._markEnd
		);
	};
	/**
	 * Process the results of each check and return the result if a check
	 * has a result
	 * @private
	 * @param {Array} results  Array of each check result
	 * @returns {Object|null}
	 */

	function getResult(results) {
		if (results.length) {
			var hasResults = false,
				result = {};
			results.forEach(function(r) {
				var res = r.results.filter(function(result) {
					return result;
				});
				result[r.type] = res;

				if (res.length) {
					hasResults = true;
				}
			});

			if (hasResults) {
				return result;
			}

			return null;
		}
	}
	/**
	 * Selects `HTMLElement`s based on configured selector and filters them based on
	 * the rules matches function
	 * @param  {Rule} rule The rule to check for after checks
	 * @param  {Context} context The resolved Context object
	 * @param  {Mixed}   options Options specific to this rule
	 * @return {Array}           All matching `HTMLElement`s
	 */

	Rule.prototype.gatherAndMatchNodes = function(context, options) {
		var _this3 = this;

		var markMatchesStart = 'mark_matches_start_' + this.id;
		var markMatchesEnd = 'mark_matches_end_' + this.id;
		var nodes = this.gather(context, options);

		if (options.performanceTimer) {
			axe.utils.performanceTimer.mark(markMatchesStart);
		}

		nodes = nodes.filter(function(node) {
			return _this3.matches(node.actualNode, node, context);
		});

		if (options.performanceTimer) {
			axe.utils.performanceTimer.mark(markMatchesEnd);
			axe.utils.performanceTimer.measure(
				'rule_' + this.id + '#matches',
				markMatchesStart,
				markMatchesEnd
			);
		}

		return nodes;
	};
	/**
	 * Iterates the rule's Checks looking for ones that have an after function
	 * @private
	 * @param  {Rule} rule The rule to check for after checks
	 * @return {Array}      Checks that have an after function
	 */

	function findAfterChecks(rule) {
		'use strict';

		return axe.utils
			.getAllChecks(rule)
			.map(function(c) {
				var check = rule._audit.checks[c.id || c];
				return check && typeof check.after === 'function' ? check : null;
			})
			.filter(Boolean);
	}
	/**
	 * Finds and collates all results for a given Check on a specific Rule
	 * @private
	 * @param  {Array} nodes RuleResult#nodes; array of 'detail' objects
	 * @param  {String} checkID The ID of the Check to find
	 * @return {Array}         Matching CheckResults
	 */

	function findCheckResults(nodes, checkID) {
		'use strict';

		var checkResults = [];
		nodes.forEach(function(nodeResult) {
			var checks = axe.utils.getAllChecks(nodeResult);
			checks.forEach(function(checkResult) {
				if (checkResult.id === checkID) {
					checkResults.push(checkResult);
				}
			});
		});
		return checkResults;
	}

	function filterChecks(checks) {
		'use strict';

		return checks.filter(function(check) {
			return check.filtered !== true;
		});
	}

	function sanitizeNodes(result) {
		'use strict';

		var checkTypes = ['any', 'all', 'none'];
		var nodes = result.nodes.filter(function(detail) {
			var length = 0;
			checkTypes.forEach(function(type) {
				detail[type] = filterChecks(detail[type]);
				length += detail[type].length;
			});
			return length > 0;
		});

		if (result.pageLevel && nodes.length) {
			nodes = [
				nodes.reduce(function(a, b) {
					if (a) {
						checkTypes.forEach(function(type) {
							a[type].push.apply(a[type], b[type]);
						});
						return a;
					}
				})
			];
		}

		return nodes;
	}
	/**
	 * Runs all of the Rule's Check#after methods
	 * @param  {RuleResult} result  The "pre-after" RuleResult
	 * @param  {Mixed} options Options specific to the rule
	 * @return {RuleResult}         The RuleResult as filtered by after functions
	 */

	Rule.prototype.after = function(result, options) {
		'use strict';

		var afterChecks = findAfterChecks(this);
		var ruleID = this.id;
		afterChecks.forEach(function(check) {
			var beforeResults = findCheckResults(result.nodes, check.id);
			var option = axe.utils.getCheckOption(check, ruleID, options);
			var afterResults = check.after(beforeResults, option);
			beforeResults.forEach(function(item) {
				if (afterResults.indexOf(item) === -1) {
					item.filtered = true;
				}
			});
		});
		result.nodes = sanitizeNodes(result);
		return result;
	};
	/**
	 * Reconfigure a rule after it has been added
	 * @param {Object} spec - the attributes to be reconfigured
	 */

	Rule.prototype.configure = function(spec) {
		/*eslint no-eval:0 */
		'use strict';

		if (spec.hasOwnProperty('selector')) {
			this.selector = spec.selector;
		}

		if (spec.hasOwnProperty('excludeHidden')) {
			this.excludeHidden =
				typeof spec.excludeHidden === 'boolean' ? spec.excludeHidden : true;
		}

		if (spec.hasOwnProperty('enabled')) {
			this.enabled = typeof spec.enabled === 'boolean' ? spec.enabled : true;
		}

		if (spec.hasOwnProperty('pageLevel')) {
			this.pageLevel =
				typeof spec.pageLevel === 'boolean' ? spec.pageLevel : false;
		}

		if (spec.hasOwnProperty('any')) {
			this.any = spec.any;
		}

		if (spec.hasOwnProperty('all')) {
			this.all = spec.all;
		}

		if (spec.hasOwnProperty('none')) {
			this.none = spec.none;
		}

		if (spec.hasOwnProperty('tags')) {
			this.tags = spec.tags;
		}

		if (spec.hasOwnProperty('matches')) {
			if (typeof spec.matches === 'string') {
				this.matches = new Function('return ' + spec.matches + ';')();
			} else {
				this.matches = spec.matches;
			}
		}
	};

	('use strict');

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError('Cannot call a class as a function');
		}
	}

	function _defineProperties(target, props) {
		for (var i = 0; i < props.length; i++) {
			var descriptor = props[i];
			descriptor.enumerable = descriptor.enumerable || false;
			descriptor.configurable = true;
			if ('value' in descriptor) descriptor.writable = true;
			Object.defineProperty(target, descriptor.key, descriptor);
		}
	}

	function _createClass(Constructor, protoProps, staticProps) {
		if (protoProps) _defineProperties(Constructor.prototype, protoProps);
		if (staticProps) _defineProperties(Constructor, staticProps);
		return Constructor;
	}

	var whitespaceRegex = /[\t\r\n\f]/g;

	var AbstractVirtualNode =
		/*#__PURE__*/
		(function() {
			function AbstractVirtualNode() {
				_classCallCheck(this, AbstractVirtualNode);

				this.children = [];
				this.parent = null;
			}

			_createClass(AbstractVirtualNode, [
				{
					key: 'attr',
					value: function attr() {
						throw new Error('VirtualNode class must have a "attr" function');
					}
				},
				{
					key: 'hasAttr',
					value: function hasAttr() {
						throw new Error('VirtualNode class must have a "hasAttr" function');
					}
				},
				{
					key: 'hasClass',
					value: function hasClass(className) {
						// get the value of the class attribute as svgs return a SVGAnimatedString
						// if you access the className property
						var classAttr = this.attr('class');

						if (!classAttr) {
							return false;
						}

						var selector = ' ' + className + ' ';
						return (
							(' ' + classAttr + ' ')
								.replace(whitespaceRegex, ' ')
								.indexOf(selector) >= 0
						);
					}
				},
				{
					key: 'props',
					get: function get() {
						throw new Error(
							'VirtualNode class must have a "props" object consisting ' +
								'of "nodeType" and "nodeName" properties'
						);
					}
				}
			]);

			return AbstractVirtualNode;
		})();

	axe.AbstractVirtualNode = AbstractVirtualNode;

	('use strict');

	function _extends() {
		_extends =
			Object.assign ||
			function(target) {
				for (var i = 1; i < arguments.length; i++) {
					var source = arguments[i];
					for (var key in source) {
						if (Object.prototype.hasOwnProperty.call(source, key)) {
							target[key] = source[key];
						}
					}
				}
				return target;
			};
		return _extends.apply(this, arguments);
	}

	function _typeof(obj) {
		if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
			_typeof = function _typeof(obj) {
				return typeof obj;
			};
		} else {
			_typeof = function _typeof(obj) {
				return obj &&
					typeof Symbol === 'function' &&
					obj.constructor === Symbol &&
					obj !== Symbol.prototype
					? 'symbol'
					: typeof obj;
			};
		}
		return _typeof(obj);
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError('Cannot call a class as a function');
		}
	}

	function _defineProperties(target, props) {
		for (var i = 0; i < props.length; i++) {
			var descriptor = props[i];
			descriptor.enumerable = descriptor.enumerable || false;
			descriptor.configurable = true;
			if ('value' in descriptor) descriptor.writable = true;
			Object.defineProperty(target, descriptor.key, descriptor);
		}
	}

	function _createClass(Constructor, protoProps, staticProps) {
		if (protoProps) _defineProperties(Constructor.prototype, protoProps);
		if (staticProps) _defineProperties(Constructor, staticProps);
		return Constructor;
	}

	function _possibleConstructorReturn(self, call) {
		if (call && (_typeof(call) === 'object' || typeof call === 'function')) {
			return call;
		}
		return _assertThisInitialized(self);
	}

	function _assertThisInitialized(self) {
		if (self === void 0) {
			throw new ReferenceError(
				"this hasn't been initialised - super() hasn't been called"
			);
		}
		return self;
	}

	function _getPrototypeOf(o) {
		_getPrototypeOf = Object.setPrototypeOf
			? Object.getPrototypeOf
			: function _getPrototypeOf(o) {
					return o.__proto__ || Object.getPrototypeOf(o);
			  };
		return _getPrototypeOf(o);
	}

	function _inherits(subClass, superClass) {
		if (typeof superClass !== 'function' && superClass !== null) {
			throw new TypeError('Super expression must either be null or a function');
		}
		subClass.prototype = Object.create(superClass && superClass.prototype, {
			constructor: { value: subClass, writable: true, configurable: true }
		});
		if (superClass) _setPrototypeOf(subClass, superClass);
	}

	function _setPrototypeOf(o, p) {
		_setPrototypeOf =
			Object.setPrototypeOf ||
			function _setPrototypeOf(o, p) {
				o.__proto__ = p;
				return o;
			};
		return _setPrototypeOf(o, p);
	}

	// eslint-disable-next-line no-unused-vars
	var SerialVirtualNode =
		/*#__PURE__*/
		(function(_axe$AbstractVirtualN) {
			_inherits(SerialVirtualNode, _axe$AbstractVirtualN);

			/**
			 * Convert a serialised node into a VirtualNode object
			 * @param {Object} node Serialised node
			 */
			function SerialVirtualNode(serialNode) {
				var _this;

				_classCallCheck(this, SerialVirtualNode);

				_this = _possibleConstructorReturn(
					this,
					_getPrototypeOf(SerialVirtualNode).call(this)
				);
				_this._props = normaliseProps(serialNode);
				_this._attrs = normaliseAttrs(serialNode);
				return _this;
			} // Accessof for DOM node properties

			_createClass(SerialVirtualNode, [
				{
					key: 'attr',

					/**
					 * Get the value of the given attribute name.
					 * @param {String} attrName The name of the attribute.
					 * @return {String|null} The value of the attribute or null if the attribute does not exist
					 */
					value: function attr(attrName) {
						return this._attrs[attrName] || null;
					}
					/**
					 * Determine if the element has the given attribute.
					 * @param {String} attrName The name of the attribute
					 * @return {Boolean} True if the element has the attribute, false otherwise.
					 */
				},
				{
					key: 'hasAttr',
					value: function hasAttr(attrName) {
						return this._attrs[attrName] !== undefined;
					}
				},
				{
					key: 'props',
					get: function get() {
						return this._props;
					}
				}
			]);

			return SerialVirtualNode;
		})(axe.AbstractVirtualNode);
	/**
	 * Convert between serialised props and DOM-like properties
	 * @param {Object} serialNode
	 * @return {Object} normalProperties
	 */

	function normaliseProps(serialNode) {
		var nodeName = serialNode.nodeName,
			_serialNode$nodeType = serialNode.nodeType,
			nodeType = _serialNode$nodeType === void 0 ? 1 : _serialNode$nodeType;
		axe.utils.assert(
			nodeType === 1,
			"nodeType has to be undefined or 1, got '".concat(nodeType, "'")
		);
		axe.utils.assert(
			typeof nodeName === 'string',
			"nodeName has to be a string, got '".concat(nodeName, "'")
		);

		var props = _extends({}, serialNode, {
			nodeType: nodeType,
			nodeName: nodeName.toLowerCase()
		});

		delete props.attributes;
		return Object.freeze(props);
	}
	/**
	 * Convert between serialised attributes and DOM-like attributes
	 * @param {Object} serialNode
	 * @return {Object} normalAttributes
	 */

	function normaliseAttrs(_ref) {
		var _ref$attributes = _ref.attributes,
			attributes = _ref$attributes === void 0 ? {} : _ref$attributes;
		var attrMap = {
			htmlFor: 'for',
			className: 'class'
		};
		return Object.keys(attributes).reduce(function(attrs, attrName) {
			var value = attributes[attrName];
			axe.utils.assert(
				_typeof(value) !== 'object' || value === null,
				"expects attributes not to be an object, '".concat(attrName, "' was")
			);

			if (value !== undefined) {
				var mappedName = attrMap[attrName] || attrName;
				attrs[mappedName] = value !== null ? String(value) : null;
			}

			return attrs;
		}, {});
	}

	axe.SerialVirtualNode = SerialVirtualNode;

	('use strict');

	function _typeof(obj) {
		if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
			_typeof = function _typeof(obj) {
				return typeof obj;
			};
		} else {
			_typeof = function _typeof(obj) {
				return obj &&
					typeof Symbol === 'function' &&
					obj.constructor === Symbol &&
					obj !== Symbol.prototype
					? 'symbol'
					: typeof obj;
			};
		}
		return _typeof(obj);
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError('Cannot call a class as a function');
		}
	}

	function _defineProperties(target, props) {
		for (var i = 0; i < props.length; i++) {
			var descriptor = props[i];
			descriptor.enumerable = descriptor.enumerable || false;
			descriptor.configurable = true;
			if ('value' in descriptor) descriptor.writable = true;
			Object.defineProperty(target, descriptor.key, descriptor);
		}
	}

	function _createClass(Constructor, protoProps, staticProps) {
		if (protoProps) _defineProperties(Constructor.prototype, protoProps);
		if (staticProps) _defineProperties(Constructor, staticProps);
		return Constructor;
	}

	function _possibleConstructorReturn(self, call) {
		if (call && (_typeof(call) === 'object' || typeof call === 'function')) {
			return call;
		}
		return _assertThisInitialized(self);
	}

	function _getPrototypeOf(o) {
		_getPrototypeOf = Object.setPrototypeOf
			? Object.getPrototypeOf
			: function _getPrototypeOf(o) {
					return o.__proto__ || Object.getPrototypeOf(o);
			  };
		return _getPrototypeOf(o);
	}

	function _assertThisInitialized(self) {
		if (self === void 0) {
			throw new ReferenceError(
				"this hasn't been initialised - super() hasn't been called"
			);
		}
		return self;
	}

	function _inherits(subClass, superClass) {
		if (typeof superClass !== 'function' && superClass !== null) {
			throw new TypeError('Super expression must either be null or a function');
		}
		subClass.prototype = Object.create(superClass && superClass.prototype, {
			constructor: { value: subClass, writable: true, configurable: true }
		});
		if (superClass) _setPrototypeOf(subClass, superClass);
	}

	function _setPrototypeOf(o, p) {
		_setPrototypeOf =
			Object.setPrototypeOf ||
			function _setPrototypeOf(o, p) {
				o.__proto__ = p;
				return o;
			};
		return _setPrototypeOf(o, p);
	}

	// class is unused in the file...
	// eslint-disable-next-line no-unused-vars
	var VirtualNode =
		/*#__PURE__*/
		(function(_axe$AbstractVirtualN) {
			_inherits(VirtualNode, _axe$AbstractVirtualN);

			/**
			 * Wrap the real node and provide list of the flattened children
			 * @param {Node} node the node in question
			 * @param {VirtualNode} parent The parent VirtualNode
			 * @param {String} shadowId the ID of the shadow DOM to which this node belongs
			 */
			function VirtualNode(node, parent, shadowId) {
				var _this;

				_classCallCheck(this, VirtualNode);

				_this = _possibleConstructorReturn(
					this,
					_getPrototypeOf(VirtualNode).call(this)
				);
				_this.shadowId = shadowId;
				_this.children = [];
				_this.actualNode = node;
				_this.parent = parent;
				_this._isHidden = null; // will be populated by axe.utils.isHidden

				_this._cache = {};

				if (axe._cache.get('nodeMap')) {
					axe._cache.get('nodeMap').set(node, _assertThisInitialized(_this));
				}

				return _this;
			} // abstract Node properties so we can run axe in DOM-less environments.
			// add to the prototype so memory is shared across all virtual nodes

			_createClass(VirtualNode, [
				{
					key: 'attr',

					/**
					 * Get the value of the given attribute name.
					 * @param {String} attrName The name of the attribute.
					 * @return {String|null} The value of the attribute or null if the attribute does not exist
					 */
					value: function attr(attrName) {
						if (typeof this.actualNode.getAttribute !== 'function') {
							return null;
						}

						return this.actualNode.getAttribute(attrName);
					}
					/**
					 * Determine if the element has the given attribute.
					 * @param {String} attrName The name of the attribute
					 * @return {Boolean} True if the element has the attribute, false otherwise.
					 */
				},
				{
					key: 'hasAttr',
					value: function hasAttr(attrName) {
						if (typeof this.actualNode.hasAttribute !== 'function') {
							return false;
						}

						return this.actualNode.hasAttribute(attrName);
					}
					/**
					 * Return a property of the computed style for this element and cache the result. This is much faster than called `getPropteryValue` every time.
					 * @see https://jsperf.com/get-property-value
					 * @return {String}
					 */
				},
				{
					key: 'getComputedStylePropertyValue',
					value: function getComputedStylePropertyValue(property) {
						var key = 'computedStyle_' + property;

						if (!this._cache.hasOwnProperty(key)) {
							if (!this._cache.hasOwnProperty('computedStyle')) {
								this._cache.computedStyle = window.getComputedStyle(
									this.actualNode
								);
							}

							this._cache[key] = this._cache.computedStyle.getPropertyValue(
								property
							);
						}

						return this._cache[key];
					}
					/**
					 * Determine if the element is focusable and cache the result.
					 * @return {Boolean} True if the element is focusable, false otherwise.
					 */
				},
				{
					key: 'props',
					get: function get() {
						var _this$actualNode = this.actualNode,
							nodeType = _this$actualNode.nodeType,
							nodeName = _this$actualNode.nodeName,
							id = _this$actualNode.id,
							type = _this$actualNode.type;
						return {
							nodeType: nodeType,
							nodeName: nodeName.toLowerCase(),
							id: id,
							type: type
						};
					}
				},
				{
					key: 'isFocusable',
					get: function get() {
						if (!this._cache.hasOwnProperty('isFocusable')) {
							this._cache.isFocusable = axe.commons.dom.isFocusable(
								this.actualNode
							);
						}

						return this._cache.isFocusable;
					}
					/**
					 * Return the list of tabbable elements for this element and cache the result.
					 * @return {VirtualNode[]}
					 */
				},
				{
					key: 'tabbableElements',
					get: function get() {
						if (!this._cache.hasOwnProperty('tabbableElements')) {
							this._cache.tabbableElements = axe.commons.dom.getTabbableElements(
								this
							);
						}

						return this._cache.tabbableElements;
					}
					/**
					 * Return the client rects for this element and cache the result.
					 * @return {DOMRect[]}
					 */
				},
				{
					key: 'clientRects',
					get: function get() {
						if (!this._cache.hasOwnProperty('clientRects')) {
							this._cache.clientRects = Array.from(
								this.actualNode.getClientRects()
							).filter(function(rect) {
								return rect.width > 0;
							});
						}

						return this._cache.clientRects;
					}
					/**
					 * Return the bounding rect for this element and cache the result.
					 * @return {DOMRect}
					 */
				},
				{
					key: 'boundingClientRect',
					get: function get() {
						if (!this._cache.hasOwnProperty('boundingClientRect')) {
							this._cache.boundingClientRect = this.actualNode.getBoundingClientRect();
						}

						return this._cache.boundingClientRect;
					}
				}
			]);

			return VirtualNode;
		})(axe.AbstractVirtualNode);

	axe.VirtualNode = VirtualNode;

	('use strict');

	(function(axe) {
		var definitions = [
			{
				name: 'NA',
				value: 'inapplicable',
				priority: 0,
				group: 'inapplicable'
			},
			{
				name: 'PASS',
				value: 'passed',
				priority: 1,
				group: 'passes'
			},
			{
				name: 'CANTTELL',
				value: 'cantTell',
				priority: 2,
				group: 'incomplete'
			},
			{
				name: 'FAIL',
				value: 'failed',
				priority: 3,
				group: 'violations'
			}
		];
		var constants = {
			helpUrlBase: 'https://dequeuniversity.com/rules/',
			results: [],
			resultGroups: [],
			resultGroupMap: {},
			impact: Object.freeze(['minor', 'moderate', 'serious', 'critical']),
			preload: Object.freeze({
				/**
				 * array of supported & preload(able) asset types.
				 */
				assets: ['cssom', 'media'],

				/**
				 * timeout value when resolving preload(able) assets
				 */
				timeout: 10000
			})
		};
		definitions.forEach(function(definition) {
			var name = definition.name;
			var value = definition.value;
			var priority = definition.priority;
			var group = definition.group;
			constants[name] = value;
			constants[name + '_PRIO'] = priority;
			constants[name + '_GROUP'] = group;
			constants.results[priority] = value;
			constants.resultGroups[priority] = group;
			constants.resultGroupMap[value] = group;
		}); // Freeze everything

		Object.freeze(constants.results);
		Object.freeze(constants.resultGroups);
		Object.freeze(constants.resultGroupMap);
		Object.freeze(constants); // Ensure that constants can not be changed

		Object.defineProperty(axe, 'constants', {
			value: constants,
			enumerable: true,
			configurable: false,
			writable: false
		});
	})(axe);

	('use strict');

	function _typeof(obj) {
		if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
			_typeof = function _typeof(obj) {
				return typeof obj;
			};
		} else {
			_typeof = function _typeof(obj) {
				return obj &&
					typeof Symbol === 'function' &&
					obj.constructor === Symbol &&
					obj !== Symbol.prototype
					? 'symbol'
					: typeof obj;
			};
		}
		return _typeof(obj);
	}

	/*eslint no-console: 0 */

	/**
	 * Logs a message to the developer console (if it exists and is active).
	 */
	axe.log = function() {
		'use strict';

		if (
			(typeof console === 'undefined' ? 'undefined' : _typeof(console)) ===
				'object' &&
			console.log
		) {
			// IE does not support console.log.apply
			Function.prototype.apply.call(console.log, console, arguments);
		}
	};

	('use strict');

	function cleanupPlugins(resolve, reject) {
		'use strict';

		resolve = resolve || function() {};

		reject = reject || axe.log;

		if (!axe._audit) {
			throw new Error('No audit configured');
		}

		var q = axe.utils.queue(); // If a plugin fails it's cleanup, we still want the others to run

		var cleanupErrors = [];
		Object.keys(axe.plugins).forEach(function(key) {
			q.defer(function(res) {
				var rej = function rej(err) {
					cleanupErrors.push(err);
					res();
				};

				try {
					axe.plugins[key].cleanup(res, rej);
				} catch (err) {
					rej(err);
				}
			});
		});
		var flattenedTree = axe.utils.getFlattenedTree(document.body);
		axe.utils
			.querySelectorAll(flattenedTree, 'iframe, frame')
			.forEach(function(node) {
				q.defer(function(res, rej) {
					return axe.utils.sendCommandToFrame(
						node.actualNode,
						{
							command: 'cleanup-plugin'
						},
						res,
						rej
					);
				});
			});
		q.then(function(results) {
			if (cleanupErrors.length === 0) {
				resolve(results);
			} else {
				reject(cleanupErrors);
			}
		})['catch'](reject);
	}

	axe.cleanup = cleanupPlugins;

	('use strict');

	function _slicedToArray(arr, i) {
		return (
			_arrayWithHoles(arr) ||
			_iterableToArrayLimit(arr, i) ||
			_nonIterableRest()
		);
	}

	function _nonIterableRest() {
		throw new TypeError('Invalid attempt to destructure non-iterable instance');
	}

	function _iterableToArrayLimit(arr, i) {
		if (
			!(
				Symbol.iterator in Object(arr) ||
				Object.prototype.toString.call(arr) === '[object Arguments]'
			)
		) {
			return;
		}
		var _arr = [];
		var _n = true;
		var _d = false;
		var _e = undefined;
		try {
			for (
				var _i = arr[Symbol.iterator](), _s;
				!(_n = (_s = _i.next()).done);
				_n = true
			) {
				_arr.push(_s.value);
				if (i && _arr.length === i) break;
			}
		} catch (err) {
			_d = true;
			_e = err;
		} finally {
			try {
				if (!_n && _i['return'] != null) _i['return']();
			} finally {
				if (_d) throw _e;
			}
		}
		return _arr;
	}

	function _arrayWithHoles(arr) {
		if (Array.isArray(arr)) return arr;
	}

	/* global reporters */
	function configureChecksRulesAndBranding(spec) {
		'use strict';

		var audit;
		audit = axe._audit;

		if (!audit) {
			throw new Error('No audit configured');
		}

		if (spec.axeVersion || spec.ver) {
			var specVersion = spec.axeVersion || spec.ver;

			if (!/^\d+\.\d+\.\d+(-canary)?/.test(specVersion)) {
				throw new Error('Invalid configured version '.concat(specVersion));
			}

			var _specVersion$split = specVersion.split('-'),
				_specVersion$split2 = _slicedToArray(_specVersion$split, 2),
				version = _specVersion$split2[0],
				canary = _specVersion$split2[1];

			var _version$split$map = version.split('.').map(Number),
				_version$split$map2 = _slicedToArray(_version$split$map, 3),
				major = _version$split$map2[0],
				minor = _version$split$map2[1],
				patch = _version$split$map2[2];

			var _axe$version$split = axe.version.split('-'),
				_axe$version$split2 = _slicedToArray(_axe$version$split, 2),
				axeVersion = _axe$version$split2[0],
				axeCanary = _axe$version$split2[1];

			var _axeVersion$split$map = axeVersion.split('.').map(Number),
				_axeVersion$split$map2 = _slicedToArray(_axeVersion$split$map, 3),
				axeMajor = _axeVersion$split$map2[0],
				axeMinor = _axeVersion$split$map2[1],
				axePatch = _axeVersion$split$map2[2];

			if (
				major !== axeMajor ||
				axeMinor < minor ||
				(axeMinor === minor && axePatch < patch) ||
				(major === axeMajor &&
					minor === axeMinor &&
					patch === axePatch &&
					canary &&
					canary !== axeCanary)
			) {
				throw new Error(
					'Configured version '
						.concat(specVersion, ' is not compatible with current axe version ')
						.concat(axe.version)
				);
			}
		}

		if (
			spec.reporter &&
			(typeof spec.reporter === 'function' || reporters[spec.reporter])
		) {
			audit.reporter = spec.reporter;
		}

		if (spec.checks) {
			spec.checks.forEach(function(check) {
				audit.addCheck(check);
			});
		}

		var modifiedRules = [];

		if (spec.rules) {
			spec.rules.forEach(function(rule) {
				modifiedRules.push(rule.id);
				audit.addRule(rule);
			});
		}

		if (spec.disableOtherRules) {
			audit.rules.forEach(function(rule) {
				if (modifiedRules.includes(rule.id) === false) {
					rule.enabled = false;
				}
			});
		}

		if (typeof spec.branding !== 'undefined') {
			audit.setBranding(spec.branding);
		} else {
			audit._constructHelpUrls();
		}

		if (spec.tagExclude) {
			audit.tagExclude = spec.tagExclude;
		} // Support runtime localization

		if (spec.locale) {
			audit.applyLocale(spec.locale);
		}
	}

	axe.configure = configureChecksRulesAndBranding;

	('use strict');

	/**
	 * Searches and returns rules that contain a tag in the list of tags.
	 * @param  {Array}   tags  Optional array of tags
	 * @return {Array}  Array of rules
	 */
	axe.getRules = function(tags) {
		'use strict';

		tags = tags || [];
		var matchingRules = !tags.length
			? axe._audit.rules
			: axe._audit.rules.filter(function(item) {
					return !!tags.filter(function(tag) {
						return item.tags.indexOf(tag) !== -1;
					}).length;
			  });
		var ruleData = axe._audit.data.rules || {};
		return matchingRules.map(function(matchingRule) {
			var rd = ruleData[matchingRule.id] || {};
			return {
				ruleId: matchingRule.id,
				description: rd.description,
				help: rd.help,
				helpUrl: rd.helpUrl,
				tags: matchingRule.tags
			};
		});
	};

	('use strict');

	/*global Audit, runRules, cleanupPlugins */

	/*eslint indent: 0*/
	function runCommand(data, keepalive, callback) {
		'use strict';

		var resolve = callback;

		var reject = function reject(err) {
			if (err instanceof Error === false) {
				err = new Error(err);
			}

			callback(err);
		};

		var context = (data && data.context) || {};

		if (context.hasOwnProperty('include') && !context.include.length) {
			context.include = [document];
		}

		var options = (data && data.options) || {};

		switch (data.command) {
			case 'rules':
				return runRules(
					context,
					options,
					function(results, cleanup) {
						resolve(results); // Cleanup AFTER resolve so that selectors can be generated

						cleanup();
					},
					reject
				);

			case 'cleanup-plugin':
				return cleanupPlugins(resolve, reject);

			default:
				// go through the registered commands
				if (
					axe._audit &&
					axe._audit.commands &&
					axe._audit.commands[data.command]
				) {
					return axe._audit.commands[data.command](data, callback);
				}
		}
	}
	/**
	 * Sets up Rules, Messages and default options for Checks, must be invoked before attempting analysis
	 * @param  {Object} audit The "audit specification" object
	 * @private
	 */

	axe._load = function(audit) {
		'use strict';

		axe.utils.respondable.subscribe('axe.ping', function(
			data,
			keepalive,
			respond
		) {
			respond({
				axe: true
			});
		});
		axe.utils.respondable.subscribe('axe.start', runCommand);
		axe._audit = new Audit(audit);
	};

	('use strict');

	/*eslint no-use-before-define:0 */
	var axe = axe || {};
	axe.plugins = {};

	function Plugin(spec) {
		'use strict';

		this._run = spec.run;
		this._collect = spec.collect;
		this._registry = {};
		spec.commands.forEach(function(command) {
			axe._audit.registerCommand(command);
		});
	}

	Plugin.prototype.run = function() {
		'use strict';

		return this._run.apply(this, arguments);
	};

	Plugin.prototype.collect = function() {
		'use strict';

		return this._collect.apply(this, arguments);
	};

	Plugin.prototype.cleanup = function(done) {
		'use strict';

		var q = axe.utils.queue();
		var that = this;
		Object.keys(this._registry).forEach(function(key) {
			q.defer(function(done) {
				that._registry[key].cleanup(done);
			});
		});
		q.then(function() {
			done();
		});
	};

	Plugin.prototype.add = function(impl) {
		'use strict';

		this._registry[impl.id] = impl;
	};

	axe.registerPlugin = function(plugin) {
		'use strict';

		axe.plugins[plugin.id] = new Plugin(plugin);
	};

	('use strict');

	var reporters = {};
	var defaultReporter;

	axe.getReporter = function(reporter) {
		'use strict';

		if (typeof reporter === 'string' && reporters[reporter]) {
			return reporters[reporter];
		}

		if (typeof reporter === 'function') {
			return reporter;
		}

		return defaultReporter;
	};

	axe.addReporter = function registerReporter(name, cb, isDefault) {
		'use strict';

		reporters[name] = cb;

		if (isDefault) {
			defaultReporter = cb;
		}
	};

	('use strict');

	/*global axe */
	function resetConfiguration() {
		'use strict';

		var audit = axe._audit;

		if (!audit) {
			throw new Error('No audit configured');
		}

		audit.resetRulesAndChecks();
	}

	axe.reset = resetConfiguration;

	('use strict');

	/*global Context */

	/*exported runRules */
	// Clean up after resolve / reject
	function cleanup() {
		axe._memoizedFns.forEach(function(fn) {
			return fn.clear();
		});

		axe._cache.clear();

		axe._tree = undefined;
		axe._selectorData = undefined;
	}
	/**
	 * Starts analysis on the current document and its subframes
	 * @private
	 * @param  {Object}   context  The `Context` specification object @see Context
	 * @param  {Array}    options  Optional RuleOptions
	 * @param  {Function} resolve  Called when done running rules, receives ([results : Object], cleanup : Function)
	 * @param  {Function} reject   Called when execution failed, receives (err : Error)
	 */

	function runRules(context, options, resolve, reject) {
		'use strict';

		try {
			context = new Context(context);
			axe._tree = context.flatTree;
			axe._selectorData = axe.utils.getSelectorData(context.flatTree);
		} catch (e) {
			cleanup();
			return reject(e);
		}

		var q = axe.utils.queue();
		var audit = axe._audit;

		if (options.performanceTimer) {
			axe.utils.performanceTimer.auditStart();
		}

		if (context.frames.length && options.iframes !== false) {
			q.defer(function(res, rej) {
				axe.utils.collectResultsFromFrames(
					context,
					options,
					'rules',
					null,
					res,
					rej
				);
			});
		}

		var scrollState;
		q.defer(function(res, rej) {
			if (options.restoreScroll) {
				scrollState = axe.utils.getScrollState();
			}

			audit.run(context, options, res, rej);
		});
		q.then(function(data) {
			try {
				if (scrollState) {
					axe.utils.setScrollState(scrollState);
				}

				if (options.performanceTimer) {
					axe.utils.performanceTimer.auditEnd();
				} // Add wrapper object so that we may use the same "merge" function for results from inside and outside frames

				var results = axe.utils.mergeResults(
					data.map(function(results) {
						return {
							results: results
						};
					})
				); // after should only run once, so ensure we are in the top level window

				if (context.initiator) {
					results = audit.after(results, options);
					results.forEach(axe.utils.publishMetaData);
					results = results.map(axe.utils.finalizeRuleResult);
				}

				try {
					resolve(results, cleanup);
				} catch (e) {
					cleanup();
					axe.log(e);
				}
			} catch (e) {
				cleanup();
				reject(e);
			}
		})['catch'](function(e) {
			cleanup();
			reject(e);
		});
	}

	axe._runRules = runRules;

	('use strict');

	function _extends() {
		_extends =
			Object.assign ||
			function(target) {
				for (var i = 1; i < arguments.length; i++) {
					var source = arguments[i];
					for (var key in source) {
						if (Object.prototype.hasOwnProperty.call(source, key)) {
							target[key] = source[key];
						}
					}
				}
				return target;
			};
		return _extends.apply(this, arguments);
	}

	/* global helpers, SerialVirtualNode */

	/**
	 * Run a rule in a non-browser environment
	 * @param {String} ruleId  Id of the rule
	 * @param {VirtualNode} vNode  The virtual node to run the rule against
	 * @param {Object} options  (optional) Set of options passed into rules or checks
	 * @return {Object} axe results for the rule run
	 */
	axe.runVirtualRule = function(ruleId, vNode) {
		var options =
			arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
		options.reporter = options.reporter || axe._audit.reporter || 'v1';
		axe._selectorData = {};

		if (vNode instanceof axe.AbstractVirtualNode === false) {
			vNode = new SerialVirtualNode(vNode);
		}

		var rule = axe._audit.rules.find(function(rule) {
			return rule.id === ruleId;
		});

		if (!rule) {
			throw new Error('unknown rule `' + ruleId + '`');
		} // rule.prototype.gather calls axe.utils.isHidden which in turn calls
		// window.getComputedStyle if the rule excludes hidden elements. we
		// can avoid this call by forcing the rule to not exclude hidden
		// elements

		rule = Object.create(rule, {
			excludeHidden: {
				value: false
			}
		});
		var context = {
			include: [vNode]
		};
		var rawResults = rule.runSync(context, options);
		axe.utils.publishMetaData(rawResults);
		axe.utils.finalizeRuleResult(rawResults);
		var results = axe.utils.aggregateResult([rawResults]);
		results.violations.forEach(function(result) {
			return result.nodes.forEach(function(nodeResult) {
				nodeResult.failureSummary = helpers.failureSummary(nodeResult);
			});
		});
		return _extends({}, helpers.getEnvironmentData(), {}, results, {
			toolOptions: options
		});
	};

	('use strict');

	function _typeof(obj) {
		if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
			_typeof = function _typeof(obj) {
				return typeof obj;
			};
		} else {
			_typeof = function _typeof(obj) {
				return obj &&
					typeof Symbol === 'function' &&
					obj.constructor === Symbol &&
					obj !== Symbol.prototype
					? 'symbol'
					: typeof obj;
			};
		}
		return _typeof(obj);
	}

	function isContext(potential) {
		'use strict';

		switch (true) {
			case typeof potential === 'string':
			case Array.isArray(potential):
			case Node && potential instanceof Node:
			case NodeList && potential instanceof NodeList:
				return true;

			case _typeof(potential) !== 'object':
				return false;

			case potential.include !== undefined:
			case potential.exclude !== undefined:
			case typeof potential.length === 'number':
				return true;

			default:
				return false;
		}
	}

	var noop = function noop() {};
	/**
	 * Normalize the optional params of axe.run()
	 * @param  {object}   context
	 * @param  {object}   options
	 * @param  {Function} callback
	 * @return {object}            With 3 keys: context, options, callback
	 */

	function normalizeRunParams(context, options, callback) {
		'use strict';

		var typeErr = new TypeError('axe.run arguments are invalid'); // Determine the context

		if (!isContext(context)) {
			if (callback !== undefined) {
				// Either context is invalid or there are too many params
				throw typeErr;
			} // Set default and shift one over

			callback = options;
			options = context;
			context = document;
		} // Determine the options

		if (_typeof(options) !== 'object') {
			if (callback !== undefined) {
				// Either options is invalid or there are too many params
				throw typeErr;
			} // Set default and shift one over

			callback = options;
			options = {};
		} // Set the callback or noop;

		if (typeof callback !== 'function' && callback !== undefined) {
			throw typeErr;
		}

		return {
			context: context,
			options: options,
			callback: callback || noop
		};
	}
	/**
	 * Runs a number of rules against the provided HTML page and returns the
	 * resulting issue list
	 *
	 * @param  {Object}   context  (optional) Defines the scope of the analysis
	 * @param  {Object}   options  (optional) Set of options passed into rules or checks
	 * @param  {Function} callback (optional) The callback when axe is done, given 2 params:
	 *                             - Error    If any errors occured, otherwise null
	 *                             - Results  The results object / array, or undefined on error
	 * @return {Promise}           Resolves with the axe results. Only available when natively supported
	 */

	axe.run = function(context, options, callback) {
		'use strict';

		if (!axe._audit) {
			throw new Error('No audit configured');
		}

		var args = normalizeRunParams(context, options, callback);
		context = args.context;
		options = args.options;
		callback = args.callback; // set defaults:

		options.reporter = options.reporter || axe._audit.reporter || 'v1';

		if (options.performanceTimer) {
			axe.utils.performanceTimer.start();
		}

		var p;
		var reject = noop;
		var resolve = noop;

		if (typeof Promise === 'function' && callback === noop) {
			p = new Promise(function(_resolve, _reject) {
				reject = _reject;
				resolve = _resolve;
			});
		}

		if (axe._running) {
			var err =
				'Axe is already running. Use `await axe.run()` to wait ' +
				'for the previous run to finish before starting a new run.';
			callback(err);
			reject(err);
			return p;
		}

		axe._running = true;

		axe._runRules(
			context,
			options,
			function(rawResults, cleanup) {
				var respond = function respond(results) {
					axe._running = false;
					cleanup();

					try {
						callback(null, results);
					} catch (e) {
						axe.log(e);
					}

					resolve(results);
				};

				if (options.performanceTimer) {
					axe.utils.performanceTimer.end();
				}

				try {
					var reporter = axe.getReporter(options.reporter);
					var results = reporter(rawResults, options, respond);

					if (results !== undefined) {
						respond(results);
					}
				} catch (err) {
					axe._running = false;
					cleanup();
					callback(err);
					reject(err);
				}
			},
			function(err) {
				axe._running = false;
				callback(err);
				reject(err);
			}
		);

		return p;
	};

	('use strict');

	/*global helpers */

	/**
	 * Finds failing Checks and combines each help message into an array
	 * @param  {Object} nodeData Individual "detail" object to generate help messages for
	 * @return {String}          failure messages
	 */
	helpers.failureSummary = function failureSummary(nodeData) {
		'use strict';

		var failingChecks = {}; // combine "all" and "none" as messaging is the same

		failingChecks.none = nodeData.none.concat(nodeData.all);
		failingChecks.any = nodeData.any;
		return Object.keys(failingChecks)
			.map(function(key) {
				if (!failingChecks[key].length) {
					return;
				}

				var sum = axe._audit.data.failureSummaries[key];

				if (sum && typeof sum.failureMessage === 'function') {
					return sum.failureMessage(
						failingChecks[key].map(function(check) {
							return check.message || '';
						})
					);
				}
			})
			.filter(function(i) {
				return i !== undefined;
			})
			.join('\n\n');
	};

	('use strict');

	/*global helpers */

	/**
	 * Add information about the environment axe was run in.
	 * @return {Object}
	 */
	helpers.getEnvironmentData = function getEnvironmentData() {
		var win =
			arguments.length > 0 && arguments[0] !== undefined
				? arguments[0]
				: window;
		// TODO: remove parameter once we are testing axe-core in jsdom and other
		// supported environments
		var _win$screen = win.screen,
			screen = _win$screen === void 0 ? {} : _win$screen,
			_win$navigator = win.navigator,
			navigator = _win$navigator === void 0 ? {} : _win$navigator,
			_win$location = win.location,
			location = _win$location === void 0 ? {} : _win$location,
			innerHeight = win.innerHeight,
			innerWidth = win.innerWidth;
		var orientation =
			screen.msOrientation || screen.orientation || screen.mozOrientation || {};
		return {
			testEngine: {
				name: 'axe-core',
				version: axe.version
			},
			testRunner: {
				name: axe._audit.brand
			},
			testEnvironment: {
				userAgent: navigator.userAgent,
				windowWidth: innerWidth,
				windowHeight: innerHeight,
				orientationAngle: orientation.angle,
				orientationType: orientation.type
			},
			timestamp: new Date().toISOString(),
			url: location.href
		};
	};

	('use strict');

	/*global helpers */

	/**
	 * Provides a fallback message in case incomplete checks don't provide one
	 * This mechanism allows the string to be localized.
	 * @return {String}
	 */
	helpers.incompleteFallbackMessage = function incompleteFallbackMessage() {
		'use strict';

		return typeof axe._audit.data.incompleteFallbackMessage === 'function'
			? axe._audit.data.incompleteFallbackMessage()
			: axe._audit.data.incompleteFallbackMessage;
	};

	('use strict');

	function _typeof(obj) {
		if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
			_typeof = function _typeof(obj) {
				return typeof obj;
			};
		} else {
			_typeof = function _typeof(obj) {
				return obj &&
					typeof Symbol === 'function' &&
					obj.constructor === Symbol &&
					obj !== Symbol.prototype
					? 'symbol'
					: typeof obj;
			};
		}
		return _typeof(obj);
	}

	/*global helpers */
	function normalizeRelatedNodes(node, options) {
		'use strict';

		['any', 'all', 'none'].forEach(function(type) {
			if (!Array.isArray(node[type])) {
				return;
			}

			node[type]
				.filter(function(checkRes) {
					return Array.isArray(checkRes.relatedNodes);
				})
				.forEach(function(checkRes) {
					checkRes.relatedNodes = checkRes.relatedNodes.map(function(
						relatedNode
					) {
						var res = {
							html: relatedNode.source
						};

						if (options.elementRef && !relatedNode.fromFrame) {
							res.element = relatedNode.element;
						}

						if (options.selectors !== false || relatedNode.fromFrame) {
							res.target = relatedNode.selector;
						}

						if (options.xpath) {
							res.xpath = relatedNode.xpath;
						}

						return res;
					});
				});
		});
	}

	var resultKeys = axe.constants.resultGroups;
	/**
	 * Configures the processing of axe results.
	 *
	 * @typedef ProcessOptions
	 * @property {Array} resultsTypes limit the types of results to process ('passes', 'violations', etc.)
	 * @property {Boolean} elementRef display node's element references
	 * @property {Boolean} selectors display node's selectors
	 * @property {Boolean} xpath display node's xpaths
	 */

	/**
	 * Aggregrate and process the axe results,
	 * adding desired data to nodes and relatedNodes in each rule result.
	 *
	 * Prepares result data for reporters.
	 *
	 * @method processAggregate
	 * @memberof helpers
	 * @param	{Array} results
	 * @param	{ProcessOptions} options
	 * @return {Object}
	 *
	 */

	helpers.processAggregate = function(results, options) {
		var resultObject = axe.utils.aggregateResult(results);
		resultKeys.forEach(function(key) {
			if (options.resultTypes && !options.resultTypes.includes(key)) {
				// If the user asks us to, truncate certain finding types to maximum one finding
				(resultObject[key] || []).forEach(function(ruleResult) {
					if (Array.isArray(ruleResult.nodes) && ruleResult.nodes.length > 0) {
						ruleResult.nodes = [ruleResult.nodes[0]];
					}
				});
			}

			resultObject[key] = (resultObject[key] || []).map(function(ruleResult) {
				ruleResult = Object.assign({}, ruleResult);

				if (Array.isArray(ruleResult.nodes) && ruleResult.nodes.length > 0) {
					ruleResult.nodes = ruleResult.nodes.map(function(subResult) {
						if (_typeof(subResult.node) === 'object') {
							subResult.html = subResult.node.source;

							if (options.elementRef && !subResult.node.fromFrame) {
								subResult.element = subResult.node.element;
							}

							if (options.selectors !== false || subResult.node.fromFrame) {
								subResult.target = subResult.node.selector;
							}

							if (options.xpath) {
								subResult.xpath = subResult.node.xpath;
							}
						}

						delete subResult.result;
						delete subResult.node;
						normalizeRelatedNodes(subResult, options);
						return subResult;
					});
				}

				resultKeys.forEach(function(key) {
					return delete ruleResult[key];
				});
				delete ruleResult.pageLevel;
				delete ruleResult.result;
				return ruleResult;
			});
		});
		return resultObject;
	};

	('use strict');

	function _extends() {
		_extends =
			Object.assign ||
			function(target) {
				for (var i = 1; i < arguments.length; i++) {
					var source = arguments[i];
					for (var key in source) {
						if (Object.prototype.hasOwnProperty.call(source, key)) {
							target[key] = source[key];
						}
					}
				}
				return target;
			};
		return _extends.apply(this, arguments);
	}

	/*global helpers */
	axe.addReporter('na', function(results, options, callback) {
		'use strict';

		console.warn(
			'"na" reporter will be deprecated in axe v4.0. Use the "v2" reporter instead.'
		);

		if (typeof options === 'function') {
			callback = options;
			options = {};
		}

		var out = helpers.processAggregate(results, options);
		callback(
			_extends({}, helpers.getEnvironmentData(), {
				toolOptions: options,
				violations: out.violations,
				passes: out.passes,
				incomplete: out.incomplete,
				inapplicable: out.inapplicable
			})
		);
	});

	('use strict');

	function _extends() {
		_extends =
			Object.assign ||
			function(target) {
				for (var i = 1; i < arguments.length; i++) {
					var source = arguments[i];
					for (var key in source) {
						if (Object.prototype.hasOwnProperty.call(source, key)) {
							target[key] = source[key];
						}
					}
				}
				return target;
			};
		return _extends.apply(this, arguments);
	}

	/*global helpers */
	axe.addReporter('no-passes', function(results, options, callback) {
		'use strict';

		if (typeof options === 'function') {
			callback = options;
			options = {};
		} // limit result processing to types we want to include in the output

		options.resultTypes = ['violations'];
		var out = helpers.processAggregate(results, options);
		callback(
			_extends({}, helpers.getEnvironmentData(), {
				toolOptions: options,
				violations: out.violations
			})
		);
	});

	('use strict');

	/*global helpers */
	axe.addReporter('rawEnv', function(results, options, callback) {
		if (typeof options === 'function') {
			callback = options;
			options = {};
		}

		function rawCallback(raw) {
			var env = helpers.getEnvironmentData();
			callback({
				raw: raw,
				env: env
			});
		}

		axe.getReporter('raw')(results, options, rawCallback);
	});

	('use strict');

	function _extends() {
		_extends =
			Object.assign ||
			function(target) {
				for (var i = 1; i < arguments.length; i++) {
					var source = arguments[i];
					for (var key in source) {
						if (Object.prototype.hasOwnProperty.call(source, key)) {
							target[key] = source[key];
						}
					}
				}
				return target;
			};
		return _extends.apply(this, arguments);
	}

	axe.addReporter('raw', function(results, options, callback) {
		'use strict';

		if (typeof options === 'function') {
			callback = options;
			options = {};
		} // Guard against tests which don't pass an array as the first param here.

		if (!results || !Array.isArray(results)) {
			return callback(results);
		}

		var transformedResults = results.map(function(result) {
			var transformedResult = _extends({}, result);

			var types = ['passes', 'violations', 'incomplete', 'inapplicable'];

			for (var _i = 0, _types = types; _i < _types.length; _i++) {
				var type = _types[_i];

				// Some tests don't include all of the types, so we have to guard against that here.
				// TODO: ensure tests always use "proper" results to avoid having these hacks in production code paths.
				if (transformedResult[type] && Array.isArray(transformedResult[type])) {
					transformedResult[type] = transformedResult[type].map(function(
						typeResult
					) {
						return _extends({}, typeResult, {
							node: typeResult.node.toJSON()
						});
					});
				}
			}

			return transformedResult;
		});
		callback(transformedResults);
	});

	('use strict');

	function _extends() {
		_extends =
			Object.assign ||
			function(target) {
				for (var i = 1; i < arguments.length; i++) {
					var source = arguments[i];
					for (var key in source) {
						if (Object.prototype.hasOwnProperty.call(source, key)) {
							target[key] = source[key];
						}
					}
				}
				return target;
			};
		return _extends.apply(this, arguments);
	}

	/*global helpers */
	axe.addReporter('v1', function(results, options, callback) {
		'use strict';

		if (typeof options === 'function') {
			callback = options;
			options = {};
		}

		var out = helpers.processAggregate(results, options);
		out.violations.forEach(function(result) {
			return result.nodes.forEach(function(nodeResult) {
				nodeResult.failureSummary = helpers.failureSummary(nodeResult);
			});
		});
		callback(
			_extends({}, helpers.getEnvironmentData(), {
				toolOptions: options,
				violations: out.violations,
				passes: out.passes,
				incomplete: out.incomplete,
				inapplicable: out.inapplicable
			})
		);
	});

	('use strict');

	function _extends() {
		_extends =
			Object.assign ||
			function(target) {
				for (var i = 1; i < arguments.length; i++) {
					var source = arguments[i];
					for (var key in source) {
						if (Object.prototype.hasOwnProperty.call(source, key)) {
							target[key] = source[key];
						}
					}
				}
				return target;
			};
		return _extends.apply(this, arguments);
	}

	/*global helpers */
	axe.addReporter(
		'v2',
		function(results, options, callback) {
			'use strict';

			if (typeof options === 'function') {
				callback = options;
				options = {};
			}

			var out = helpers.processAggregate(results, options);
			callback(
				_extends({}, helpers.getEnvironmentData(), {
					toolOptions: options,
					violations: out.violations,
					passes: out.passes,
					incomplete: out.incomplete,
					inapplicable: out.inapplicable
				})
			);
		},
		true
	);

	('use strict');

	/**
	 * From a list of values, find the one with the greatest weight according to
	 * the supplied map
	 * @param  {object} params Contains 3 properties:
	 * - map: a map indicating the order of values to run in
	 *        example: ['small', 'medium', 'large']
	 * - values: Array of values to take the highest from
	 * - initial: optional starting value
	 */
	axe.utils.aggregate = function(map, values, initial) {
		values = values.slice();

		if (initial) {
			values.push(initial);
		}

		var sorting = values
			.map(function(val) {
				return map.indexOf(val);
			})
			.sort(); // Stupid NodeJS array.sort functor doesn't work!!

		return map[sorting.pop()];
	};

	('use strict');

	var _axe$constants = axe.constants,
		CANTTELL_PRIO = _axe$constants.CANTTELL_PRIO,
		FAIL_PRIO = _axe$constants.FAIL_PRIO;
	var checkMap = [];
	checkMap[axe.constants.PASS_PRIO] = true;
	checkMap[axe.constants.CANTTELL_PRIO] = null;
	checkMap[axe.constants.FAIL_PRIO] = false;
	/**
	 * Map over the any / all / none properties
	 */

	var checkTypes = ['any', 'all', 'none'];

	function anyAllNone(obj, functor) {
		return checkTypes.reduce(function(out, type) {
			out[type] = (obj[type] || []).map(function(val) {
				return functor(val, type);
			});
			return out;
		}, {});
	}

	axe.utils.aggregateChecks = function(nodeResOriginal) {
		// Create a copy
		var nodeResult = Object.assign({}, nodeResOriginal); // map each result value to a priority

		anyAllNone(nodeResult, function(check, type) {
			var i =
				typeof check.result === 'undefined'
					? -1
					: checkMap.indexOf(check.result); // default to cantTell

			check.priority = i !== -1 ? i : axe.constants.CANTTELL_PRIO;

			if (type === 'none') {
				// For none, swap pass and fail outcomes.
				// none-type checks should pass when result is false rather than true.
				if (check.priority === axe.constants.PASS_PRIO) {
					check.priority = axe.constants.FAIL_PRIO;
				} else if (check.priority === axe.constants.FAIL_PRIO) {
					check.priority = axe.constants.PASS_PRIO;
				}
			}
		}); // Find the result with the highest priority

		var priorities = {
			all: nodeResult.all.reduce(function(a, b) {
				return Math.max(a, b.priority);
			}, 0),
			none: nodeResult.none.reduce(function(a, b) {
				return Math.max(a, b.priority);
			}, 0),
			// get the lowest passing of 'any' defaulting
			// to 0 by wrapping around 4 to 0 (inapplicable)
			any:
				nodeResult.any.reduce(function(a, b) {
					return Math.min(a, b.priority);
				}, 4) % 4
		};
		nodeResult.priority = Math.max(
			priorities.all,
			priorities.none,
			priorities.any
		); // Of each type, filter out all results not matching the final priority

		var impacts = [];
		checkTypes.forEach(function(type) {
			nodeResult[type] = nodeResult[type].filter(function(check) {
				return (
					check.priority === nodeResult.priority &&
					check.priority === priorities[type]
				);
			});
			nodeResult[type].forEach(function(check) {
				return impacts.push(check.impact);
			});
		}); // for failed nodes, define the impact

		if ([CANTTELL_PRIO, FAIL_PRIO].includes(nodeResult.priority)) {
			nodeResult.impact = axe.utils.aggregate(axe.constants.impact, impacts);
		} else {
			nodeResult.impact = null;
		} // Delete the old result and priority properties

		anyAllNone(nodeResult, function(c) {
			delete c.result;
			delete c.priority;
		}); // Convert the index to a result string value

		nodeResult.result = axe.constants.results[nodeResult.priority];
		delete nodeResult.priority;
		return nodeResult;
	};

	('use strict');

	(function() {
		/**
		 * Calculates the result of a Rule based on its types and the result of its child Checks
		 * @param	{Array} nodeResults The array of nodes tested by the Rule
		 */
		axe.utils.aggregateNodeResults = function(nodeResults) {
			var ruleResult = {}; // For each node, retrieve the result and impact

			nodeResults = nodeResults.map(function(nodeResult) {
				// Known result
				if (nodeResult.any && nodeResult.all && nodeResult.none) {
					return axe.utils.aggregateChecks(nodeResult);
				} else if (Array.isArray(nodeResult.node)) {
					return axe.utils.finalizeRuleResult(nodeResult);
				} else {
					throw new TypeError('Invalid Result type');
				}
			}); // Aggregate the result
			// If there were no nodes passed in, mark the test as inapplicable

			if (nodeResults && nodeResults.length) {
				var resultList = nodeResults.map(function(node) {
					return node.result;
				});
				ruleResult.result = axe.utils.aggregate(
					axe.constants.results,
					resultList,
					ruleResult.result
				);
			} else {
				ruleResult.result = 'inapplicable';
			} // Create an array for each type

			axe.constants.resultGroups.forEach(function(group) {
				return (ruleResult[group] = []);
			}); // Fill the array with nodes

			nodeResults.forEach(function(nodeResult) {
				var groupName = axe.constants.resultGroupMap[nodeResult.result];
				ruleResult[groupName].push(nodeResult);
			}); // Take the highest impact of failed or canttell rules

			var impactGroup = axe.constants.FAIL_GROUP;

			if (ruleResult[impactGroup].length === 0) {
				impactGroup = axe.constants.CANTTELL_GROUP;
			}

			if (ruleResult[impactGroup].length > 0) {
				// Get the impact of all issues
				var impactList = ruleResult[impactGroup].map(function(failure) {
					return failure.impact;
				});
				ruleResult.impact =
					axe.utils.aggregate(axe.constants.impact, impactList) || null;
			} else {
				ruleResult.impact = null;
			}

			return ruleResult;
		};
	})();

	('use strict');

	function copyToGroup(resultObject, subResult, group) {
		var resultCopy = Object.assign({}, subResult);
		resultCopy.nodes = (resultCopy[group] || []).concat();
		axe.constants.resultGroups.forEach(function(group) {
			delete resultCopy[group];
		});
		resultObject[group].push(resultCopy);
	}
	/**
	 * Calculates the result of a Rule based on its types and the result of its child Checks
	 * @param  {RuleResult} ruleResult The RuleResult to calculate the result of
	 */

	axe.utils.aggregateResult = function(results) {
		var resultObject = {}; // Create an array for each type

		axe.constants.resultGroups.forEach(function(groupName) {
			return (resultObject[groupName] = []);
		}); // Fill the array with nodes

		results.forEach(function(subResult) {
			if (subResult.error) {
				copyToGroup(resultObject, subResult, axe.constants.CANTTELL_GROUP);
			} else if (subResult.result === axe.constants.NA) {
				copyToGroup(resultObject, subResult, axe.constants.NA_GROUP);
			} else {
				axe.constants.resultGroups.forEach(function(group) {
					if (Array.isArray(subResult[group]) && subResult[group].length > 0) {
						copyToGroup(resultObject, subResult, group);
					}
				});
			}
		});
		return resultObject;
	};

	('use strict');

	/* global axe*/
	function areStylesSet(el, styles, stopAt) {
		'use strict';

		var styl = window.getComputedStyle(el, null);

		if (!styl) {
			return false;
		}

		for (var i = 0; i < styles.length; ++i) {
			var att = styles[i];

			if (styl.getPropertyValue(att.property) === att.value) {
				return true;
			}
		}

		if (!el.parentNode || el.nodeName.toUpperCase() === stopAt.toUpperCase()) {
			return false;
		}

		return areStylesSet(el.parentNode, styles, stopAt);
	}

	axe.utils.areStylesSet = areStylesSet;

	('use strict');

	/* global axe*/

	/**
	 * If the first argument is falsey, throw an error using the second argument as a message.
	 * @param {boolean} bool
	 * @param {string} message
	 */
	axe.utils.assert = function assert(bool, message) {
		if (!bool) {
			throw new Error(message);
		}
	};

	('use strict');

	/**
	 * Helper to denote which checks are asyncronous and provide callbacks and pass data back to the CheckResult
	 * @param  {CheckResult}   checkResult The target object
	 * @param  {Function} callback    The callback to expose when `this.async()` is called
	 * @return {Object}               Bound to `this` for a check's fn
	 */
	axe.utils.checkHelper = function checkHelper(
		checkResult,
		options,
		resolve,
		reject
	) {
		'use strict';

		return {
			isAsync: false,
			async: function async() {
				this.isAsync = true;
				return function(result) {
					if (result instanceof Error === false) {
						checkResult.result = result;
						resolve(checkResult);
					} else {
						reject(result);
					}
				};
			},
			data: function data(_data) {
				checkResult.data = _data;
			},
			relatedNodes: function relatedNodes(nodes) {
				nodes = nodes instanceof Node ? [nodes] : axe.utils.toArray(nodes);
				checkResult.relatedNodes = nodes.map(function(element) {
					return new axe.utils.DqElement(element, options);
				});
			}
		};
	};

	('use strict');

	function _typeof(obj) {
		if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
			_typeof = function _typeof(obj) {
				return typeof obj;
			};
		} else {
			_typeof = function _typeof(obj) {
				return obj &&
					typeof Symbol === 'function' &&
					obj.constructor === Symbol &&
					obj !== Symbol.prototype
					? 'symbol'
					: typeof obj;
			};
		}
		return _typeof(obj);
	}

	/**
	 * Deeply clones an object or array
	 * @param  {Mixed} obj The object/array to clone
	 * @return {Mixed}     A clone of the initial object or array
	 */
	axe.utils.clone = function(obj) {
		/* eslint guard-for-in: 0*/
		'use strict';

		var index,
			length,
			out = obj;

		if (obj !== null && _typeof(obj) === 'object') {
			if (Array.isArray(obj)) {
				out = [];

				for (index = 0, length = obj.length; index < length; index++) {
					out[index] = axe.utils.clone(obj[index]);
				}
			} else {
				out = {};

				for (index in obj) {
					out[index] = axe.utils.clone(obj[index]);
				}
			}
		}

		return out;
	};

	('use strict');

	function err(message, node) {
		'use strict';

		var selector;

		if (axe._tree) {
			selector = axe.utils.getSelector(node);
		}

		return new Error(message + ': ' + (selector || node));
	}
	/**
	 * Sends a command to an instance of axe in the specified frame
	 * @param  {Element}  node       The frame element to send the message to
	 * @param  {Object}   parameters Parameters to pass to the frame
	 * @param  {Function} callback   Function to call when results from the frame has returned
	 */

	axe.utils.sendCommandToFrame = function(node, parameters, resolve, reject) {
		'use strict';

		var win = node.contentWindow;

		if (!win) {
			axe.log('Frame does not have a content window', node);
			resolve(null);
			return;
		} // give the frame .5s to respond to 'axe.ping', else log failed response

		var timeout = setTimeout(function() {
			// This double timeout is important for allowing iframes to respond
			// DO NOT REMOVE
			timeout = setTimeout(function() {
				if (!parameters.debug) {
					resolve(null);
				} else {
					reject(err('No response from frame', node));
				}
			}, 0);
		}, 500); // send 'axe.ping' to the frame

		axe.utils.respondable(win, 'axe.ping', null, undefined, function() {
			clearTimeout(timeout); // Give axe 60s (or user-supplied value) to respond to 'axe.start'

			var frameWaitTime =
				(parameters.options && parameters.options.frameWaitTime) || 60000;
			timeout = setTimeout(function collectResultFramesTimeout() {
				reject(err('Axe in frame timed out', node));
			}, frameWaitTime); // send 'axe.start' and send the callback if it responded

			axe.utils.respondable(win, 'axe.start', parameters, undefined, function(
				data
			) {
				clearTimeout(timeout);

				if (data instanceof Error === false) {
					resolve(data);
				} else {
					reject(data);
				}
			});
		});
	};
	/**
	 * Sends a message to axe running in frames to start analysis and collate results (via `mergeResults`)
	 * @private
	 * @param  {Context}  context   The resolved Context object
	 * @param  {Object}   options   Options object (as passed to `runRules`)
	 * @param  {string}   command   Command sent to all frames
	 * @param  {Array}    parameter Array of values to be passed along side the command
	 * @param  {Function} callback  Function to call when results from all frames have returned
	 */

	function collectResultsFromFrames(
		context,
		options,
		command,
		parameter,
		resolve,
		reject
	) {
		'use strict';

		var q = axe.utils.queue();
		var frames = context.frames; // Tell each axe running in each frame to collect results

		frames.forEach(function(frame) {
			var params = {
				options: options,
				command: command,
				parameter: parameter,
				context: {
					initiator: false,
					page: context.page,
					include: frame.include || [],
					exclude: frame.exclude || []
				}
			};
			q.defer(function(res, rej) {
				var node = frame.node;
				axe.utils.sendCommandToFrame(
					node,
					params,
					function(data) {
						if (data) {
							return res({
								results: data,
								frameElement: node,
								frame: axe.utils.getSelector(node)
							});
						}

						res(null);
					},
					rej
				);
			});
		}); // Combine results from all frames and give it back

		q.then(function(data) {
			resolve(axe.utils.mergeResults(data, options));
		})['catch'](reject);
	}

	axe.utils.collectResultsFromFrames = collectResultsFromFrames;

	('use strict');

	/**
	 * Wrapper for Node#contains; PhantomJS does not support Node#contains and erroneously reports that it does
	 * @method contains
	 * @memberof axe.utils
	 * @param  {VirtualNode} vNode     The candidate container VirtualNode
	 * @param  {VirtualNode} otherVNode The vNode to test is contained by `vNode`
	 * @return {Boolean}           Whether `vNode` contains `otherVNode`
	 */
	axe.utils.contains = function(vNode, otherVNode) {
		/*eslint no-bitwise: 0*/
		'use strict';

		function containsShadowChild(vNode, otherVNode) {
			if (vNode.shadowId === otherVNode.shadowId) {
				return true;
			}

			return !!vNode.children.find(function(child) {
				return containsShadowChild(child, otherVNode);
			});
		}

		if (vNode.shadowId || otherVNode.shadowId) {
			return containsShadowChild(vNode, otherVNode);
		}

		if (vNode.actualNode) {
			if (typeof vNode.actualNode.contains === 'function') {
				return vNode.actualNode.contains(otherVNode.actualNode);
			}

			return !!(
				vNode.actualNode.compareDocumentPosition(otherVNode.actualNode) & 16
			);
		} else {
			// fallback for virtualNode only contexts (e.g. linting)
			// @see https://github.com/Financial-Times/polyfill-service/pull/183/files
			do {
				if (otherVNode === vNode) {
					return true;
				}
			} while ((otherVNode = otherVNode && otherVNode.parent));
		}

		return false;
	};

	('use strict');

	(function(axe) {
		var parser = new axe.imports.CssSelectorParser();
		parser.registerSelectorPseudos('not');
		parser.registerNestingOperators('>');
		parser.registerAttrEqualityMods('^', '$', '*');
		axe.utils.cssParser = parser;
	})(axe);

	('use strict');

	/*exported DqElement */
	function truncate(str, maxLength) {
		maxLength = maxLength || 300;

		if (str.length > maxLength) {
			var index = str.indexOf('>');
			str = str.substring(0, index + 1);
		}

		return str;
	}

	function getSource(element) {
		var source = element.outerHTML;

		if (!source && typeof XMLSerializer === 'function') {
			source = new XMLSerializer().serializeToString(element);
		}

		return truncate(source || '');
	}
	/**
	 * "Serialized" `HTMLElement`. It will calculate the CSS selector,
	 * grab the source (outerHTML) and offer an array for storing frame paths
	 * @param {HTMLElement} element The element to serialize
	 * @param {Object} spec Properties to use in place of the element when instantiated on Elements from other frames
	 */

	function DqElement(element, options, spec) {
		this._fromFrame = !!spec;
		this.spec = spec || {};

		if (options && options.absolutePaths) {
			this._options = {
				toRoot: true
			};
		}
		/**
		 * The generated HTML source code of the element
		 * @type {String}
		 */

		this.source =
			this.spec.source !== undefined ? this.spec.source : getSource(element);
		/**
		 * The element which this object is based off or the containing frame, used for sorting.
		 * Excluded in toJSON method.
		 * @type {HTMLElement}
		 */

		this._element = element;
	}

	DqElement.prototype = {
		/**
		 * A unique CSS selector for the element
		 * @return {String}
		 */
		get selector() {
			return (
				this.spec.selector || [
					axe.utils.getSelector(this.element, this._options)
				]
			);
		},

		/**
		 * Xpath to the element
		 * @return {String}
		 */
		get xpath() {
			return this.spec.xpath || [axe.utils.getXpath(this.element)];
		},

		/**
		 * Direct reference to the `HTMLElement` wrapped by this `DQElement`.
		 */
		get element() {
			return this._element;
		},

		get fromFrame() {
			return this._fromFrame;
		},

		toJSON: function toJSON() {
			'use strict';

			return {
				selector: this.selector,
				source: this.source,
				xpath: this.xpath
			};
		}
	};

	DqElement.fromFrame = function(node, options, frame) {
		node.selector.unshift(frame.selector);
		node.xpath.unshift(frame.xpath);
		return new axe.utils.DqElement(frame.element, options, node);
	};

	axe.utils.DqElement = DqElement;

	('use strict');

	/**
	 * Polyfill for Element#matches
	 * @param {HTMLElement} node The element to test
	 * @param {String} selector The selector to test element against
	 * @return {Boolean}
	 */
	axe.utils.matchesSelector = (function() {
		'use strict';

		var method;

		function getMethod(node) {
			var index,
				candidate,
				candidates = [
					'matches',
					'matchesSelector',
					'mozMatchesSelector',
					'webkitMatchesSelector',
					'msMatchesSelector'
				],
				length = candidates.length;

			for (index = 0; index < length; index++) {
				candidate = candidates[index];

				if (node[candidate]) {
					return candidate;
				}
			}
		}

		return function(node, selector) {
			if (!method || !node[method]) {
				method = getMethod(node);
			}

			if (node[method]) {
				return node[method](selector);
			}

			return false;
		};
	})();

	('use strict');

	/**
	 * Escapes a property value of a CSS selector
	 * @see https://github.com/mathiasbynens/CSS.escape/
	 * @see http://dev.w3.org/csswg/cssom/#serialize-an-identifier
	 * @param  {String} value The piece of the selector to escape
	 * @return {String}        The escaped selector
	 */
	axe.utils.escapeSelector = function(value) {
		'use strict';
		/*eslint no-bitwise: 0, eqeqeq: 0, one-var: 0 */

		var string = String(value);
		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = '';
		var firstCodeUnit = string.charCodeAt(0);

		while (++index < length) {
			codeUnit = string.charCodeAt(index); // Note: theres no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.
			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).

			if (codeUnit == 0x0000) {
				result += '\uFFFD';
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, []
				(codeUnit >= 0x0001 && codeUnit <= 0x001f) ||
				codeUnit == 0x007f || // If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), []
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) || // If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), []
				(index == 1 &&
					codeUnit >= 0x0030 &&
					codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002d)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += '\\' + codeUnit.toString(16) + ' ';
				continue;
			} // If the character is the first character and is a `-` (U+002D), and
			// there is no second character, []

			if (index == 0 && length == 1 && codeUnit == 0x002d) {
				result += '\\' + string.charAt(index);
				continue;
			} // If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), []

			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002d ||
				codeUnit == 0x005f ||
				(codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				(codeUnit >= 0x0041 && codeUnit <= 0x005a) ||
				(codeUnit >= 0x0061 && codeUnit <= 0x007a)
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			} // Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character

			result += '\\' + string.charAt(index);
		}

		return result;
	};

	('use strict');

	/*eslint no-empty: 0*/

	/**
	 * Extends metadata onto result object and executes any functions
	 * @param  {Object} to   The target of the extend
	 * @param  {Object} from Metadata to extend
	 */
	axe.utils.extendMetaData = function(to, from) {
		Object.assign(to, from);
		Object.keys(from)
			.filter(function(prop) {
				return typeof from[prop] === 'function';
			})
			.forEach(function(prop) {
				to[prop] = null;

				try {
					to[prop] = from[prop](to);
				} catch (e) {}
			});
	};

	('use strict');

	/**
	 * Process rule results, grouping them by outcome
	 * @param ruleResult {object}
	 * @return {object}
	 */
	axe.utils.finalizeRuleResult = function(ruleResult) {
		Object.assign(ruleResult, axe.utils.aggregateNodeResults(ruleResult.nodes));
		delete ruleResult.nodes;
		return ruleResult;
	};

	('use strict');

	function _typeof(obj) {
		if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
			_typeof = function _typeof(obj) {
				return typeof obj;
			};
		} else {
			_typeof = function _typeof(obj) {
				return obj &&
					typeof Symbol === 'function' &&
					obj.constructor === Symbol &&
					obj !== Symbol.prototype
					? 'symbol'
					: typeof obj;
			};
		}
		return _typeof(obj);
	}

	/**
	 * Iterates an array of objects looking for a property with a specific value
	 * @method findBy
	 * @memberof axe.utils
	 * @param  {Array} array  The array of objects to iterate
	 * @param  {String} key   The property name to test against
	 * @param  {Mixed} value  The value to find
	 * @return {Object}       The first matching object or `undefined` if no match
	 */
	axe.utils.findBy = function(array, key, value) {
		if (Array.isArray(array)) {
			return array.find(function(obj) {
				return _typeof(obj) === 'object' && obj[key] === value;
			});
		}
	};

	('use strict');

	/* global VirtualNode */

	/*eslint no-use-before-define: 0*/
	var axe = axe || {
		utils: {}
	};
	/**
	 * This implemnts the flatten-tree algorithm specified:
	 * Originally here https://drafts.csswg.org/css-scoping/#flat-tree
	 * Hopefully soon published here: https://www.w3.org/TR/css-scoping-1/#flat-tree
	 *
	 * Some notable information:
	 ******* NOTE: as of Chrome 59, this is broken in Chrome so that tests fail completely
	 ******* removed functionality for now
	 * 1. <slot> elements do not have boxes by default (i.e. they do not get rendered and
	 *    their CSS properties are ignored)
	 * 2. <slot> elements can be made to have a box by overriding the display property
	 *    which is 'contents' by default
	 * 3. Even boxed <slot> elements do not show up in the accessibility tree until
	 *    they have a tabindex applied to them OR they have a role applied to them AND
	 *    they have a box (this is observed behavior in Safari on OS X, I cannot find
	 *    the spec for this)
	 */

	/**
	 * find all the fallback content for a <slot> and return these as an array
	 * this array will also include any #text nodes
	 *
	 * @param node {Node} - the slot Node
	 * @return Array{Nodes}
	 */

	function getSlotChildren(node) {
		var retVal = [];
		node = node.firstChild;

		while (node) {
			retVal.push(node);
			node = node.nextSibling;
		}

		return retVal;
	}
	/**
	 * Recursvely returns an array of the virtual DOM nodes at this level
	 * excluding comment nodes and the shadow DOM nodes <content> and <slot>
	 *
	 * @param {Node} node the current node
	 * @param {String} shadowId, optional ID of the shadow DOM that is the closest shadow
	 *                           ancestor of the node
	 * @param {VirtualNode} parent the parent VirtualNode
	 */

	function flattenTree(node, shadowId, parent) {
		// using a closure here and therefore cannot easily refactor toreduce the statements
		var retVal, realArray, nodeName;

		function reduceShadowDOM(res, child, parent) {
			var replacements = flattenTree(child, shadowId, parent);

			if (replacements) {
				res = res.concat(replacements);
			}

			return res;
		}

		if (node.documentElement) {
			// document
			node = node.documentElement;
		}

		nodeName = node.nodeName.toLowerCase();

		if (axe.utils.isShadowRoot(node)) {
			// generate an ID for this shadow root and overwrite the current
			// closure shadowId with this value so that it cascades down the tree
			retVal = new VirtualNode(node, parent, shadowId);
			shadowId =
				'a' +
				Math.random()
					.toString()
					.substring(2);
			realArray = Array.from(node.shadowRoot.childNodes);
			retVal.children = realArray.reduce(function(res, child) {
				return reduceShadowDOM(res, child, retVal);
			}, []);
			return [retVal];
		} else {
			if (
				nodeName === 'content' &&
				typeof node.getDistributedNodes === 'function'
			) {
				realArray = Array.from(node.getDistributedNodes());
				return realArray.reduce(function(res, child) {
					return reduceShadowDOM(res, child, parent);
				}, []);
			} else if (
				nodeName === 'slot' &&
				typeof node.assignedNodes === 'function'
			) {
				realArray = Array.from(node.assignedNodes());

				if (!realArray.length) {
					// fallback content
					realArray = getSlotChildren(node);
				}

				var styl = window.getComputedStyle(node); // check the display property

				if (false && styl.display !== 'contents') {
					// intentionally commented out
					// has a box
					retVal = new VirtualNode(node, parent, shadowId);
					retVal.children = realArray.reduce(function(res, child) {
						return reduceShadowDOM(res, child, retVal);
					}, []);
					return [retVal];
				} else {
					return realArray.reduce(function(res, child) {
						return reduceShadowDOM(res, child, parent);
					}, []);
				}
			} else {
				if (node.nodeType === 1) {
					retVal = new VirtualNode(node, parent, shadowId);
					realArray = Array.from(node.childNodes);
					retVal.children = realArray.reduce(function(res, child) {
						return reduceShadowDOM(res, child, retVal);
					}, []);
					return [retVal];
				} else if (node.nodeType === 3) {
					// text
					return [new VirtualNode(node, parent)];
				}

				return undefined;
			}
		}
	}
	/**
	 * Recursvely returns an array of the virtual DOM nodes at this level
	 * excluding comment nodes and the shadow DOM nodes <content> and <slot>
	 *
	 * @param {Node} node the current node
	 * @param {String} shadowId, optional ID of the shadow DOM that is the closest shadow
	 *                           ancestor of the node
	 */

	axe.utils.getFlattenedTree = function(node, shadowId) {
		axe._cache.set('nodeMap', new WeakMap());

		return flattenTree(node, shadowId);
	};
	/**
	 * Return a single node from the virtual dom tree
	 *
	 * @param {Object} vNode The flattened, virtual DOM tree
	 * @param {Node}   node  The HTML DOM node
	 */

	axe.utils.getNodeFromTree = function(vNode, node) {
		var el = node || vNode;
		return axe._cache.get('nodeMap') ? axe._cache.get('nodeMap').get(el) : null;
	};

	('use strict');

	/**
	 * Gets all Checks (or CheckResults) for a given Rule or RuleResult
	 * @param {RuleResult|Rule} rule
	 */
	axe.utils.getAllChecks = function getAllChecks(object) {
		'use strict';

		var result = [];
		return result
			.concat(object.any || [])
			.concat(object.all || [])
			.concat(object.none || []);
	};

	('use strict');

	/**
	 * Returns am array of source nodes containing `document` and `documentFragment` in a given `tree`.
	 *
	 * @param {Object} treeRoot tree
	 * @returns {Array<Object>} array of objects, which each object containing a root and an optional `shadowId`
	 */
	axe.utils.getAllRootNodesInTree = function getAllRootNodesInTree(tree) {
		var ids = [];
		var rootNodes = axe.utils
			.querySelectorAllFilter(tree, '*', function(node) {
				if (ids.includes(node.shadowId)) {
					return false;
				}

				ids.push(node.shadowId);
				return true;
			})
			.map(function(node) {
				return {
					shadowId: node.shadowId,
					rootNode: axe.utils.getRootNode(node.actualNode)
				};
			});
		return axe.utils.uniqueArray(rootNodes, []);
	};

	('use strict');

	/**
	 * Convenience function to extract primary language subtag from a given value
	 * @method getBaseLang
	 * @memberof axe.utils
	 * @param {String} value value specified as lang or xml:lang attribute
	 * @return {String}
	 */
	axe.utils.getBaseLang = function getBaseLang(lang) {
		if (!lang) {
			return '';
		}

		return lang
			.trim()
			.split('-')[0]
			.toLowerCase();
	};

	('use strict');

	/**
	 * Determines which CheckOption to use, either defined on the rule options, global check options or the check itself
	 * @param  {Check} check    The Check object
	 * @param  {String} ruleID  The ID of the rule
	 * @param  {Object} options Options object as passed to main API
	 * @return {Object}         The resolved object with `options` and `enabled` keys
	 */
	axe.utils.getCheckOption = function(check, ruleID, options) {
		var ruleCheckOption = (((options.rules && options.rules[ruleID]) || {})
			.checks || {})[check.id];
		var checkOption = (options.checks || {})[check.id];
		var enabled = check.enabled;
		var opts = check.options;

		if (checkOption) {
			if (checkOption.hasOwnProperty('enabled')) {
				enabled = checkOption.enabled;
			}

			if (checkOption.hasOwnProperty('options')) {
				opts = checkOption.options;
			}
		}

		if (ruleCheckOption) {
			if (ruleCheckOption.hasOwnProperty('enabled')) {
				enabled = ruleCheckOption.enabled;
			}

			if (ruleCheckOption.hasOwnProperty('options')) {
				opts = ruleCheckOption.options;
			}
		}

		return {
			enabled: enabled,
			options: opts,
			absolutePaths: options.absolutePaths
		};
	};

	('use strict');

	function _slicedToArray(arr, i) {
		return (
			_arrayWithHoles(arr) ||
			_iterableToArrayLimit(arr, i) ||
			_nonIterableRest()
		);
	}

	function _nonIterableRest() {
		throw new TypeError('Invalid attempt to destructure non-iterable instance');
	}

	function _iterableToArrayLimit(arr, i) {
		if (
			!(
				Symbol.iterator in Object(arr) ||
				Object.prototype.toString.call(arr) === '[object Arguments]'
			)
		) {
			return;
		}
		var _arr = [];
		var _n = true;
		var _d = false;
		var _e = undefined;
		try {
			for (
				var _i = arr[Symbol.iterator](), _s;
				!(_n = (_s = _i.next()).done);
				_n = true
			) {
				_arr.push(_s.value);
				if (i && _arr.length === i) break;
			}
		} catch (err) {
			_d = true;
			_e = err;
		} finally {
			try {
				if (!_n && _i['return'] != null) _i['return']();
			} finally {
				if (_d) throw _e;
			}
		}
		return _arr;
	}

	function _arrayWithHoles(arr) {
		if (Array.isArray(arr)) return arr;
	}

	/* eslint no-script-url:0 */

	/**
	 * Check if a string contains mostly numbers
	 */
	function isMostlyNumbers() {
		var str =
			arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
		return (
			str.length !== 0 && (str.match(/[0-9]/g) || '').length >= str.length / 2
		);
	}
	/**
	 * Spit a string into an array with two pieces, at a given index
	 * @param String	string to split
	 * @param Number	index at which to split
	 * @return Array
	 */

	function splitString(str, splitIndex) {
		return [str.substring(0, splitIndex), str.substring(splitIndex)];
	}

	function trimRight(str) {
		return str.replace(/\s+$/, '');
	}
	/**
	 * Take a relative or absolute URL and pull it into it's indivisual pieces
	 *
	 * @param url (string)
	 * @return urlPieces
	 *	 .protocol	The protocol used, e.g. 'https://'
	 *	 .domain		Domain name including sub domains and TLD, e.g. 'docs.deque.com'
	 *	 .port			The port number, e.g. ':8080'
	 *	 .path			Path after the domain, e.g. '/home.html'
	 *	 .query		 Query string, e.g. '?user=admin&password=pass'
	 *	 .hash			Hash / internal reference, e.g. '#footer'
	 */

	function uriParser(url) {
		var original = url;
		var protocol = '',
			domain = '',
			port = '',
			path = '',
			query = '',
			hash = '';

		if (url.includes('#')) {
			var _splitString = splitString(url, url.indexOf('#'));

			var _splitString2 = _slicedToArray(_splitString, 2);

			url = _splitString2[0];
			hash = _splitString2[1];
		}

		if (url.includes('?')) {
			var _splitString3 = splitString(url, url.indexOf('?'));

			var _splitString4 = _slicedToArray(_splitString3, 2);

			url = _splitString4[0];
			query = _splitString4[1];
		}

		if (url.includes('://')) {
			var _url$split = url.split('://');

			var _url$split2 = _slicedToArray(_url$split, 2);

			protocol = _url$split2[0];
			url = _url$split2[1];

			var _splitString5 = splitString(url, url.indexOf('/'));

			var _splitString6 = _slicedToArray(_splitString5, 2);

			domain = _splitString6[0];
			url = _splitString6[1];
		} else if (url.substr(0, 2) === '//') {
			url = url.substr(2);

			var _splitString7 = splitString(url, url.indexOf('/'));

			var _splitString8 = _slicedToArray(_splitString7, 2);

			domain = _splitString8[0];
			url = _splitString8[1];
		}

		if (domain.substr(0, 4) === 'www.') {
			domain = domain.substr(4);
		}

		if (domain && domain.includes(':')) {
			var _splitString9 = splitString(domain, domain.indexOf(':'));

			var _splitString10 = _slicedToArray(_splitString9, 2);

			domain = _splitString10[0];
			port = _splitString10[1];
		}

		path = url; // Whatever is left, must be the path

		return {
			original: original,
			protocol: protocol,
			domain: domain,
			port: port,
			path: path,
			query: query,
			hash: hash
		};
	}
	/**
	 * Try to, at the end of the URI, find a string that a user can identify the URI by
	 *
	 * @param uri			 The URI to use
	 * @param options
	 *	 .currentDomain	The current domain name (optional)
	 *	 .maxLength			Max length of the returned string (default: 25)
	 * @return string	 A portion at the end of the uri, no longer than maxLength
	 */

	axe.utils.getFriendlyUriEnd = function getFriendlyUriEnd() {
		var uri =
			arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
		var options =
			arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		if (
			// Skip certain URIs:
			uri.length <= 1 || // very short
			uri.substr(0, 5) === 'data:' || // data URIs are unreadable
			uri.substr(0, 11) === 'javascript:' || // JS isn't a URL
			uri.includes('?') // query strings aren't very readable either
		) {
			return;
		}

		var currentDomain = options.currentDomain,
			_options$maxLength = options.maxLength,
			maxLength = _options$maxLength === void 0 ? 25 : _options$maxLength;

		var _uriParser = uriParser(uri),
			path = _uriParser.path,
			domain = _uriParser.domain,
			hash = _uriParser.hash; // Split the path at the last / that has text after it

		var pathEnd = path.substr(
			path.substr(0, path.length - 2).lastIndexOf('/') + 1
		);

		if (hash) {
			if (pathEnd && (pathEnd + hash).length <= maxLength) {
				return trimRight(pathEnd + hash);
			} else if (
				pathEnd.length < 2 &&
				hash.length > 2 &&
				hash.length <= maxLength
			) {
				return trimRight(hash);
			} else {
				return;
			}
		} else if (domain && domain.length < maxLength && path.length <= 1) {
			// '' or '/'
			return trimRight(domain + path);
		} // See if the domain should be returned

		if (
			path === '/' + pathEnd &&
			domain &&
			currentDomain &&
			domain !== currentDomain &&
			(domain + path).length <= maxLength
		) {
			return trimRight(domain + path);
		}

		var lastDotIndex = pathEnd.lastIndexOf('.');

		if (
			// Exclude very short or very long string
			(lastDotIndex === -1 || lastDotIndex > 1) &&
			(lastDotIndex !== -1 || pathEnd.length > 2) &&
			pathEnd.length <= maxLength && // Exclude index files
			!pathEnd.match(/index(\.[a-zA-Z]{2-4})?/) && // Exclude files that are likely to be database IDs
			!isMostlyNumbers(pathEnd)
		) {
			return trimRight(pathEnd);
		}
	};

	('use strict');

	/* global axe */

	/**
	 * Return the list of attributes of a node.
	 * @method getNodeAttributes
	 * @memberof axe.utils
	 * @param {Element} node
	 * @returns {NamedNodeMap}
	 */
	axe.utils.getNodeAttributes = function getNodeAttributes(node) {
		// eslint-disable-next-line no-restricted-syntax
		if (node.attributes instanceof window.NamedNodeMap) {
			// eslint-disable-next-line no-restricted-syntax
			return node.attributes;
		} // if the attributes property is not of type NamedNodeMap then the DOM
		// has been clobbered. E.g. <form><input name="attributes"></form>.
		// We can clone the node to isolate it and then return the attributes

		return node.cloneNode(false).attributes;
	};

	('use strict');

	/* global axe */

	/**
	 * Return the document or document fragment (shadow DOM)
	 * @method getRootNode
	 * @memberof axe.utils
	 * @param {Element} node
	 * @returns {DocumentFragment|Document}
	 */
	axe.utils.getRootNode = function getRootNode(node) {
		var doc = (node.getRootNode && node.getRootNode()) || document; // this is for backwards compatibility

		if (doc === node) {
			// disconnected node
			doc = document;
		}

		return doc;
	};

	('use strict');

	/**
	 * Get the scroll position of given element
	 * @method getScroll
	 * @memberof axe.utils
	 * @param {Element} node
	 * @param {buffer} (Optional) allowed negligence in overflow
	 * @returns {Object | undefined}
	 */
	axe.utils.getScroll = function getScroll(elm) {
		var buffer =
			arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
		var overflowX = elm.scrollWidth > elm.clientWidth + buffer;
		var overflowY = elm.scrollHeight > elm.clientHeight + buffer;
		/**
		 * if there is neither `overflow-x` or `overflow-y`
		 * -> return
		 */

		if (!(overflowX || overflowY)) {
			return;
		}

		var style = window.getComputedStyle(elm);
		var overflowXStyle = style.getPropertyValue('overflow-x');
		var overflowYStyle = style.getPropertyValue('overflow-y');
		var scrollableX =
			overflowXStyle !== 'visible' && overflowXStyle !== 'hidden';
		var scrollableY =
			overflowYStyle !== 'visible' && overflowYStyle !== 'hidden';
		/**
		 * check direction of `overflow` and `scrollable`
		 */

		if ((overflowX && scrollableX) || (overflowY && scrollableY)) {
			return {
				elm: elm,
				top: elm.scrollTop,
				left: elm.scrollLeft
			};
		}
	};

	('use strict');

	var escapeSelector = axe.utils.escapeSelector;
	var isXHTML;
	var ignoredAttributes = [
		'class',
		'style',
		'id',
		'selected',
		'checked',
		'disabled',
		'tabindex',
		'aria-checked',
		'aria-selected',
		'aria-invalid',
		'aria-activedescendant',
		'aria-busy',
		'aria-disabled',
		'aria-expanded',
		'aria-grabbed',
		'aria-pressed',
		'aria-valuenow'
	];
	var MAXATTRIBUTELENGTH = 31;
	/**
	 * get the attribute name and value as a string
	 * @param {Element} node		The element that has the attribute
	 * @param {Attribute} at		The attribute
	 * @return {String}
	 */

	function getAttributeNameValue(node, at) {
		var name = at.name;
		var atnv;

		if (name.indexOf('href') !== -1 || name.indexOf('src') !== -1) {
			var friendly = axe.utils.getFriendlyUriEnd(node.getAttribute(name));

			if (friendly) {
				var value = encodeURI(friendly);

				if (value) {
					atnv = escapeSelector(at.name) + '$="' + escapeSelector(value) + '"';
				} else {
					return;
				}
			} else {
				atnv =
					escapeSelector(at.name) +
					'="' +
					escapeSelector(node.getAttribute(name)) +
					'"';
			}
		} else {
			atnv = escapeSelector(name) + '="' + escapeSelector(at.value) + '"';
		}

		return atnv;
	}

	function countSort(a, b) {
		return a.count < b.count ? -1 : a.count === b.count ? 0 : 1;
	}
	/**
	 * Filter the attributes
	 * @param {Attribute}		The potential attribute
	 * @return {Boolean}		 Whether to include or exclude
	 */

	function filterAttributes(at) {
		return (
			!ignoredAttributes.includes(at.name) &&
			at.name.indexOf(':') === -1 &&
			(!at.value || at.value.length < MAXATTRIBUTELENGTH)
		);
	}
	/**
	 * Calculate the statistics for the classes, attributes and tags on the page, using
	 * the virtual DOM tree
	 * @param {Object} domTree		The root node of the virtual DOM tree
	 * @returns {Object}					The statistics consisting of three maps, one for classes,
	 *														one for tags and one for attributes. The map values are
	 *														the counts for how many elements with that feature exist
	 */

	axe.utils.getSelectorData = function(domTree) {
		/* eslint no-loop-func:0*/
		// Initialize the return structure with the three maps
		var data = {
			classes: {},
			tags: {},
			attributes: {}
		};
		domTree = Array.isArray(domTree) ? domTree : [domTree];
		var currentLevel = domTree.slice();
		var stack = [];

		var _loop = function _loop() {
			var current = currentLevel.pop();
			var node = current.actualNode;

			if (!!node.querySelectorAll) {
				// ignore #text nodes
				// count the tag
				var tag = node.nodeName;

				if (data.tags[tag]) {
					data.tags[tag]++;
				} else {
					data.tags[tag] = 1;
				} // count all the classes

				if (node.classList) {
					Array.from(node.classList).forEach(function(cl) {
						var ind = escapeSelector(cl);

						if (data.classes[ind]) {
							data.classes[ind]++;
						} else {
							data.classes[ind] = 1;
						}
					});
				} // count all the filtered attributes

				if (node.hasAttributes()) {
					Array.from(axe.utils.getNodeAttributes(node))
						.filter(filterAttributes)
						.forEach(function(at) {
							var atnv = getAttributeNameValue(node, at);

							if (atnv) {
								if (data.attributes[atnv]) {
									data.attributes[atnv]++;
								} else {
									data.attributes[atnv] = 1;
								}
							}
						});
				}
			}

			if (current.children.length) {
				// "recurse"
				stack.push(currentLevel);
				currentLevel = current.children.slice();
			}

			while (!currentLevel.length && stack.length) {
				currentLevel = stack.pop();
			}
		};

		while (currentLevel.length) {
			_loop();
		}

		return data;
	};
	/**
	 * Given a node and the statistics on class frequency on the page,
	 * return all its uncommon class data sorted in order of decreasing uniqueness
	 * @param {Element} node			The node
	 * @param {Object} classData	The map of classes to counts
	 * @return {Array}						The sorted array of uncommon class data
	 */

	function uncommonClasses(node, selectorData) {
		// eslint no-loop-func:false
		var retVal = [];
		var classData = selectorData.classes;
		var tagData = selectorData.tags;

		if (node.classList) {
			Array.from(node.classList).forEach(function(cl) {
				var ind = escapeSelector(cl);

				if (classData[ind] < tagData[node.nodeName]) {
					retVal.push({
						name: ind,
						count: classData[ind],
						species: 'class'
					});
				}
			});
		}

		return retVal.sort(countSort);
	}
	/**
	 * Given an element and a selector that finds that element (but possibly other sibling elements)
	 * return the :nth-child(n) pseudo selector that uniquely finds the node within its siblings
	 * @param {Element} elm			 The Element
	 * @param {String} selector	 The selector
	 * @return {String}					 The nth-child selector
	 */

	function getNthChildString(elm, selector) {
		var siblings =
			(elm.parentNode && Array.from(elm.parentNode.children || '')) || [];
		var hasMatchingSiblings = siblings.find(function(sibling) {
			return sibling !== elm && axe.utils.matchesSelector(sibling, selector);
		});

		if (hasMatchingSiblings) {
			var nthChild = 1 + siblings.indexOf(elm);
			return ':nth-child(' + nthChild + ')';
		} else {
			return '';
		}
	}
	/**
	 * Get ID selector
	 */

	function getElmId(elm) {
		if (!elm.getAttribute('id')) {
			return;
		}

		var doc = (elm.getRootNode && elm.getRootNode()) || document;
		var id = '#' + escapeSelector(elm.getAttribute('id') || '');

		if (
			// Don't include youtube's uid values, they change	on reload
			!id.match(/player_uid_/) && // Don't include IDs that occur more then once on the page
			doc.querySelectorAll(id).length === 1
		) {
			return id;
		}
	}
	/**
	 * Return the base CSS selector for a given element
	 * @param	{HTMLElement} elm				 The element to get the selector for
	 * @return {String|Array<String>}	Base CSS selector for the node
	 */

	function getBaseSelector(elm) {
		if (typeof isXHTML === 'undefined') {
			isXHTML = axe.utils.isXHTML(document);
		}

		return escapeSelector(isXHTML ? elm.localName : elm.nodeName.toLowerCase());
	}
	/**
	 * Given a node and the statistics on attribute frequency on the page,
	 * return all its uncommon attribute data sorted in order of decreasing uniqueness
	 * @param {Element} node			The node
	 * @param {Object} attData		The map of attributes to counts
	 * @return {Array}						The sorted array of uncommon attribute data
	 */

	function uncommonAttributes(node, selectorData) {
		var retVal = [];
		var attData = selectorData.attributes;
		var tagData = selectorData.tags;

		if (node.hasAttributes()) {
			Array.from(axe.utils.getNodeAttributes(node))
				.filter(filterAttributes)
				.forEach(function(at) {
					var atnv = getAttributeNameValue(node, at);

					if (atnv && attData[atnv] < tagData[node.nodeName]) {
						retVal.push({
							name: atnv,
							count: attData[atnv],
							species: 'attribute'
						});
					}
				});
		}

		return retVal.sort(countSort);
	}
	/**
	 * generates a selector fragment for an element based on the statistics of the page in
	 * which the element exists. This function takes into account the fact that selectors that
	 * use classes and tags are much faster than universal selectors. It also tries to use a
	 * unique class selector before a unique attribute selector (with the tag), followed by
	 * a selector made up of the three least common features statistically. A feature will
	 * also only be used if it is less common than the tag of the element itself.
	 *
	 * @param {Element} elm			The element for which to generate a selector
	 * @param {Object} options	 Options for how to generate the selector
	 * @param {RootNode} doc		 The root node of the document or document fragment
	 * @returns {String}				 The selector
	 */

	function getThreeLeastCommonFeatures(elm, selectorData) {
		var selector = '';
		var features;
		var clss = uncommonClasses(elm, selectorData);
		var atts = uncommonAttributes(elm, selectorData);

		if (clss.length && clss[0].count === 1) {
			// only use the unique class
			features = [clss[0]];
		} else if (atts.length && atts[0].count === 1) {
			// only use the unique attribute value
			features = [atts[0]]; // if no class, add the tag

			selector = getBaseSelector(elm);
		} else {
			features = clss.concat(atts); // sort by least common

			features.sort(countSort); // select three least common features

			features = features.slice(0, 3); // if no class, add the tag

			if (
				!features.some(function(feat) {
					return feat.species === 'class';
				})
			) {
				// has no class
				selector = getBaseSelector(elm);
			} else {
				// put the classes at the front of the selector
				features.sort(function(a, b) {
					return a.species !== b.species && a.species === 'class'
						? -1
						: a.species === b.species
						? 0
						: 1;
				});
			}
		} // construct the return value

		return (selector += features.reduce(function(val, feat) {
			/*eslint indent: 0*/
			switch (feat.species) {
				case 'class':
					return val + '.' + feat.name;

				case 'attribute':
					return val + '[' + feat.name + ']';
			}

			return val; // should never happen
		}, ''));
	}
	/**
	 * generates a single selector for an element
	 * @param {Element} elm			The element for which to generate a selector
	 * @param {Object} options	 Options for how to generate the selector
	 * @param {RootNode} doc		 The root node of the document or document fragment
	 * @returns {String}				 The selector
	 */

	function generateSelector(elm, options, doc) {
		/*eslint no-loop-func:0*/
		if (!axe._selectorData) {
			throw new Error('Expect axe._selectorData to be set up');
		}

		var _options$toRoot = options.toRoot,
			toRoot = _options$toRoot === void 0 ? false : _options$toRoot;
		var selector;
		var similar;
		/**
		 * Try to find a unique selector by filtering out all the clashing
		 * nodes by adding ancestor selectors iteratively.
		 * This loop is much faster than recursing and using querySelectorAll
		 */

		do {
			var features = getElmId(elm);

			if (!features) {
				features = getThreeLeastCommonFeatures(elm, axe._selectorData);
				features += getNthChildString(elm, features);
			}

			if (selector) {
				selector = features + ' > ' + selector;
			} else {
				selector = features;
			}

			if (!similar) {
				similar = Array.from(doc.querySelectorAll(selector));
			} else {
				similar = similar.filter(function(item) {
					return axe.utils.matchesSelector(item, selector);
				});
			}

			elm = elm.parentElement;
		} while ((similar.length > 1 || toRoot) && elm && elm.nodeType !== 11);

		if (similar.length === 1) {
			return selector;
		} else if (selector.indexOf(' > ') !== -1) {
			// For the odd case that document doesn't have a unique selector
			return ':root' + selector.substring(selector.indexOf(' > '));
		}

		return ':root';
	}
	/**
	 * Gets a unique CSS selector
	 * @param {HTMLElement} node The element to get the selector for
	 * @param {Object} optional options
	 * @returns {String|Array<String>} Unique CSS selector for the node
	 */

	axe.utils.getSelector = function createUniqueSelector(elm) {
		var options =
			arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		if (!elm) {
			return '';
		}

		var doc = (elm.getRootNode && elm.getRootNode()) || document;

		if (doc.nodeType === 11) {
			// DOCUMENT_FRAGMENT
			var stack = [];

			while (doc.nodeType === 11) {
				if (!doc.host) {
					return '';
				}

				stack.push({
					elm: elm,
					doc: doc
				});
				elm = doc.host;
				doc = elm.getRootNode();
			}

			stack.push({
				elm: elm,
				doc: doc
			});
			return stack.reverse().map(function(comp) {
				return generateSelector(comp.elm, options, comp.doc);
			});
		} else {
			return generateSelector(elm, options, doc);
		}
	};

	('use strict');

	/**
	 * Function which converts given text to `CSSStyleSheet`
	 * - used in `CSSOM` computation.
	 * - factory (closure) function, initialized with `document.implementation.createHTMLDocument()`, which uses DOM API for creating `style` elements.
	 *
	 * @method axe.utils.getStyleSheetFactory
	 * @memberof axe.utils
	 * @param {Object} dynamicDoc `document.implementation.createHTMLDocument()
	 * @param {Object} options an object with properties to construct stylesheet
	 * @property {String} options.data text content of the stylesheet
	 * @property {Boolean} options.isCrossOrigin flag to notify if the resource was fetched from the network
	 * @property {String} options.shadowId (Optional) shadowId if shadowDOM
	 * @property {Object} options.root implementation document to create style elements
	 * @property {String} options.priority a number indicating the loaded priority of CSS, to denote specificity of styles contained in the sheet.
	 * @returns {Function}
	 */
	axe.utils.getStyleSheetFactory = function getStyleSheetFactory(dynamicDoc) {
		if (!dynamicDoc) {
			throw new Error(
				'axe.utils.getStyleSheetFactory should be invoked with an argument'
			);
		}

		return function(options) {
			var data = options.data,
				_options$isCrossOrigi = options.isCrossOrigin,
				isCrossOrigin =
					_options$isCrossOrigi === void 0 ? false : _options$isCrossOrigi,
				shadowId = options.shadowId,
				root = options.root,
				priority = options.priority,
				_options$isLink = options.isLink,
				isLink = _options$isLink === void 0 ? false : _options$isLink;
			var style = dynamicDoc.createElement('style');

			if (isLink) {
				// as creating a stylesheet as link will need to be awaited
				// till `onload`, it is wise to convert link href to @import statement
				var text = dynamicDoc.createTextNode(
					'@import "'.concat(data.href, '"')
				);
				style.appendChild(text);
			} else {
				style.appendChild(dynamicDoc.createTextNode(data));
			}

			dynamicDoc.head.appendChild(style);
			return {
				sheet: style.sheet,
				isCrossOrigin: isCrossOrigin,
				shadowId: shadowId,
				root: root,
				priority: priority
			};
		};
	};

	('use strict');

	/*global axe */
	function getXPathArray(node, path) {
		var sibling, count; // Gets an XPath for an element which describes its hierarchical location.

		if (!node) {
			return [];
		}

		if (!path && node.nodeType === 9) {
			// special case for when we are called and give the document itself as the starting node
			path = [
				{
					str: 'html'
				}
			];
			return path;
		}

		path = path || [];

		if (node.parentNode && node.parentNode !== node) {
			path = getXPathArray(node.parentNode, path);
		}

		if (node.previousSibling) {
			count = 1;
			sibling = node.previousSibling;

			do {
				if (sibling.nodeType === 1 && sibling.nodeName === node.nodeName) {
					count++;
				}

				sibling = sibling.previousSibling;
			} while (sibling);

			if (count === 1) {
				count = null;
			}
		} else if (node.nextSibling) {
			sibling = node.nextSibling;

			do {
				if (sibling.nodeType === 1 && sibling.nodeName === node.nodeName) {
					count = 1;
					sibling = null;
				} else {
					count = null;
					sibling = sibling.previousSibling;
				}
			} while (sibling);
		}

		if (node.nodeType === 1) {
			var element = {};
			element.str = node.nodeName.toLowerCase(); // add the id and the count so we can construct robust versions of the xpath

			var id =
				node.getAttribute && axe.utils.escapeSelector(node.getAttribute('id'));

			if (id && node.ownerDocument.querySelectorAll('#' + id).length === 1) {
				element.id = node.getAttribute('id');
			}

			if (count > 1) {
				element.count = count;
			}

			path.push(element);
		}

		return path;
	} // Robust is intended to allow xpaths to be robust to changes in the HTML structure of the page
	// This means always use the id when present
	// Non robust means always use the count (i.e. the exact position of the element)
	// Ironically this is a bit of a misnomer because in very, very dynamic pages (e.g. where ids are generated on the fly)
	// the non-ribust Xpaths will work whereas the robust ones will not work

	function xpathToString(xpathArray) {
		return xpathArray.reduce(function(str, elm) {
			if (elm.id) {
				return '/'.concat(elm.str, "[@id='").concat(elm.id, "']");
			} else {
				return (
					str +
					'/'.concat(elm.str) +
					(elm.count > 0 ? '['.concat(elm.count, ']') : '')
				);
			}
		}, '');
	}

	axe.utils.getXpath = function getXpath(node) {
		var xpathArray = getXPathArray(node);
		return xpathToString(xpathArray);
	};

	('use strict');

	/*exported injectStyle */

	/*global axe*/
	var styleSheet;

	function injectStyle(style) {
		'use strict';

		if (styleSheet && styleSheet.parentNode) {
			// append the style to the existing sheet
			if (styleSheet.styleSheet === undefined) {
				// Not old IE
				styleSheet.appendChild(document.createTextNode(style));
			} else {
				styleSheet.styleSheet.cssText += style;
			}

			return styleSheet;
		}

		if (!style) {
			return;
		}

		var head = document.head || document.getElementsByTagName('head')[0];
		styleSheet = document.createElement('style');
		styleSheet.type = 'text/css';

		if (styleSheet.styleSheet === undefined) {
			// Not old IE
			styleSheet.appendChild(document.createTextNode(style));
		} else {
			styleSheet.styleSheet.cssText = style;
		}

		head.appendChild(styleSheet);
		return styleSheet;
	}

	axe.utils.injectStyle = injectStyle;

	('use strict');

	/**
	 * Determine whether an element is visible
	 * @method isHidden
	 * @memberof axe.utils
	 * @param {HTMLElement} el The HTMLElement
	 * @param {Boolean} recursed
	 * @return {Boolean} The element's visibilty status
	 */
	axe.utils.isHidden = function isHidden(el, recursed) {
		'use strict';

		var node = axe.utils.getNodeFromTree(el); // 9 === Node.DOCUMENT

		if (el.nodeType === 9) {
			return false;
		} // do not exclude `video` or `audio` el's

		if (['VIDEO', 'AUDIO'].includes(el.nodeName.toUpperCase())) {
			return false;
		} // 11 === Node.DOCUMENT_FRAGMENT_NODE

		if (el.nodeType === 11) {
			el = el.host; // grab the host Node
		}

		if (node && node._isHidden !== null) {
			return node._isHidden;
		}

		var style = window.getComputedStyle(el, null);

		if (
			!style ||
			!el.parentNode ||
			style.getPropertyValue('display') === 'none' ||
			(!recursed && // visibility is only accurate on the first element
				style.getPropertyValue('visibility') === 'hidden') ||
			el.getAttribute('aria-hidden') === 'true'
		) {
			return true;
		}

		var parent = el.assignedSlot ? el.assignedSlot : el.parentNode;
		var isHidden = axe.utils.isHidden(parent, true); // cache the results of the isHidden check on the parent tree
		// so we don't have to look at the parent tree again for all its
		// descendants

		if (node) {
			node._isHidden = isHidden;
		}

		return isHidden;
	};

	('use strict');

	var htmlTags = [
		'a',
		'abbr',
		'address',
		'area',
		'article',
		'aside',
		'audio',
		'b',
		'base',
		'bdi',
		'bdo',
		'blockquote',
		'body',
		'br',
		'button',
		'canvas',
		'caption',
		'cite',
		'code',
		'col',
		'colgroup',
		'data',
		'datalist',
		'dd',
		'del',
		'details',
		'dfn',
		'dialog',
		'div',
		'dl',
		'dt',
		'em',
		'embed',
		'fieldset',
		'figcaption',
		'figure',
		'footer',
		'form',
		'h1',
		'h2',
		'h3',
		'h4',
		'h5',
		'h6',
		'head',
		'header',
		'hgroup',
		'hr',
		'html',
		'i',
		'iframe',
		'img',
		'input',
		'ins',
		'kbd',
		'keygen',
		'label',
		'legend',
		'li',
		'link',
		'main',
		'map',
		'mark',
		'math',
		'menu',
		'menuitem',
		'meta',
		'meter',
		'nav',
		'noscript',
		'object',
		'ol',
		'optgroup',
		'option',
		'output',
		'p',
		'param',
		'picture',
		'pre',
		'progress',
		'q',
		'rb',
		'rp',
		'rt',
		'rtc',
		'ruby',
		's',
		'samp',
		'script',
		'section',
		'select',
		'slot',
		'small',
		'source',
		'span',
		'strong',
		'style',
		'sub',
		'summary',
		'sup',
		'svg',
		'table',
		'tbody',
		'td',
		'template',
		'textarea',
		'tfoot',
		'th',
		'thead',
		'time',
		'title',
		'tr',
		'track',
		'u',
		'ul',
		'var',
		'video',
		'wbr'
	];
	/**
	 * Verifies that if a given html tag is valid
	 * @method isHtmlElement
	 * @memberof axe.utils
	 * @param htmlTag htmlTag to check if valid
	 * @return {Boolean} true/ false
	 */

	axe.utils.isHtmlElement = function isHtmlElement(node) {
		if (node.namespaceURI === 'http://www.w3.org/2000/svg') {
			return false;
		}

		return htmlTags.includes(node.nodeName.toLowerCase());
	};

	('use strict');

	/* global axe */
	var possibleShadowRoots = [
		'article',
		'aside',
		'blockquote',
		'body',
		'div',
		'footer',
		'h1',
		'h2',
		'h3',
		'h4',
		'h5',
		'h6',
		'header',
		'main',
		'nav',
		'p',
		'section',
		'span'
	];
	/**
	 * Test a node to see if it has a spec-conforming shadow root
	 *
	 * @param {Node}   node  The HTML DOM node
	 * @return {Boolean}
	 */

	axe.utils.isShadowRoot = function isShadowRoot(node) {
		if (node.shadowRoot) {
			var nodeName = node.nodeName.toLowerCase();

			if (
				possibleShadowRoots.includes(nodeName) ||
				/^[a-z][a-z0-9_.-]*-[a-z0-9_.-]*$/.test(nodeName)
			) {
				return true;
			}
		}

		return false;
	};

	('use strict');

	/**
	 * Determines if a document node is XHTML
	 * @method isXHTML
	 * @memberof axe.utils
	 * @param {Node} doc a document node
	 * @return {Boolean}
	 */
	axe.utils.isXHTML = function(doc) {
		'use strict';

		if (!doc.createElement) {
			return false;
		}

		return doc.createElement('A').localName === 'A';
	};

	('use strict');

	/**
	 * Memoize a function.
	 * @method memoize
	 * @memberof axe.utils
	 * @param {Function} fn Function to memoize
	 * @return {Function}
	 */
	axe._memoizedFns = [];

	axe.utils.memoize = function(fn) {
		// keep track of each function that is memoized so it can be cleared at
		// the end of a run. each memoized function has its own cache, so there is
		// no method to clear all memoized caches. instead, we have to clear each
		// individual memoized function ourselves.
		var memoized = axe.imports.memoize(fn);

		axe._memoizedFns.push(memoized);

		return memoized;
	};

	('use strict');

	/**
	 * Adds the owning frame's CSS selector onto each instance of DqElement
	 * @private
	 * @param	{Array} resultSet `nodes` array on a `RuleResult`
	 * @param	{HTMLElement} frameElement	The frame element
	 * @param	{String} frameSelector		 Unique CSS selector for the frame
	 */
	function pushFrame(resultSet, options, frameElement, frameSelector) {
		'use strict';

		var frameXpath = axe.utils.getXpath(frameElement);
		var frameSpec = {
			element: frameElement,
			selector: frameSelector,
			xpath: frameXpath
		};
		resultSet.forEach(function(res) {
			res.node = axe.utils.DqElement.fromFrame(res.node, options, frameSpec);
			var checks = axe.utils.getAllChecks(res);

			if (checks.length) {
				checks.forEach(function(check) {
					check.relatedNodes = check.relatedNodes.map(function(node) {
						return axe.utils.DqElement.fromFrame(node, options, frameSpec);
					});
				});
			}
		});
	}
	/**
	 * Adds `to` to `from` and then re-sorts by DOM order
	 * @private
	 * @param	{Array} target	`nodes` array on a `RuleResult`
	 * @param	{Array} to	 `nodes` array on a `RuleResult`
	 * @return {Array}			The merged and sorted result
	 */

	function spliceNodes(target, to) {
		'use strict';

		var firstFromFrame = to[0].node,
			sorterResult,
			t;

		for (var i = 0, l = target.length; i < l; i++) {
			t = target[i].node;
			sorterResult = axe.utils.nodeSorter(
				{
					actualNode: t.element
				},
				{
					actualNode: firstFromFrame.element
				}
			);

			if (
				sorterResult > 0 ||
				(sorterResult === 0 &&
					firstFromFrame.selector.length < t.selector.length)
			) {
				target.splice.apply(target, [i, 0].concat(to));
				return;
			}
		}

		target.push.apply(target, to);
	}

	function normalizeResult(result) {
		'use strict';

		if (!result || !result.results) {
			return null;
		}

		if (!Array.isArray(result.results)) {
			return [result.results];
		}

		if (!result.results.length) {
			return null;
		}

		return result.results;
	}
	/**
	 * Merges one or more RuleResults (possibly from different frames) into one RuleResult
	 * @private
	 * @param	{Array} frameResults	Array of objects including the RuleResults as `results` and frame as `frame`
	 * @return {Array}							The merged RuleResults; should only have one result per rule
	 */

	axe.utils.mergeResults = function mergeResults(frameResults, options) {
		'use strict';

		var result = [];
		frameResults.forEach(function(frameResult) {
			var results = normalizeResult(frameResult);

			if (!results || !results.length) {
				return;
			}

			results.forEach(function(ruleResult) {
				if (ruleResult.nodes && frameResult.frame) {
					pushFrame(
						ruleResult.nodes,
						options,
						frameResult.frameElement,
						frameResult.frame
					);
				}

				var res = axe.utils.findBy(result, 'id', ruleResult.id);

				if (!res) {
					result.push(ruleResult);
				} else {
					if (ruleResult.nodes.length) {
						spliceNodes(res.nodes, ruleResult.nodes);
					}
				}
			});
		});
		return result;
	};

	('use strict');

	/**
	 * Array#sort callback to sort nodes by DOM order
	 * @private
	 * @param  {Node} nodeA
	 * @param  {Node} nodeB
	 * @return {Integer}   @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Sort
	 */
	axe.utils.nodeSorter = function nodeSorter(nodeA, nodeB) {
		/*eslint no-bitwise: 0 */
		nodeA = nodeA.actualNode || nodeA;
		nodeB = nodeB.actualNode || nodeB;

		if (nodeA === nodeB) {
			return 0;
		}

		if (nodeA.compareDocumentPosition(nodeB) & 4) {
			return -1; // a before b
		} else {
			return 1; // b before a
		}
	};

	('use strict');

	/**
	 * Parse cross-origin stylesheets
	 *
	 * @method parseCrossOriginStylesheet
	 * @memberof axe.utils
	 * @param {String} url url from which to fetch stylesheet
	 * @param {Object} options options object from `axe.utils.parseStylesheet`
	 * @param {Array<Number>} priority sheet priority
	 * @param {Array<String>} importedUrls urls of already imported stylesheets
	 * @param {Boolean} isCrossOrigin boolean denoting if a stylesheet is `cross-origin`
	 * @returns {Promise}
	 */
	axe.utils.parseCrossOriginStylesheet = function parseCrossOriginStylesheet(
		url,
		options,
		priority,
		importedUrls,
		isCrossOrigin
	) {
		var axiosOptions = {
			method: 'get',
			timeout: axe.constants.preload.timeout,
			url: url
		};
		/**
		 * Add `url` to `importedUrls`
		 */

		importedUrls.push(url);
		/**
		 * Fetch `cross-origin stylesheet` via axios
		 */

		return axe.imports.axios(axiosOptions).then(function(_ref) {
			var data = _ref.data;
			var result = options.convertDataToStylesheet({
				data: data,
				isCrossOrigin: isCrossOrigin,
				priority: priority,
				root: options.rootNode,
				shadowId: options.shadowId
			});
			/**
			 * Parse resolved stylesheet further for any `@import` styles
			 */

			return axe.utils.parseStylesheet(
				result.sheet,
				options,
				priority,
				importedUrls,
				result.isCrossOrigin
			);
		});
	};

	('use strict');

	function _toConsumableArray(arr) {
		return (
			_arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
		);
	}

	function _nonIterableSpread() {
		throw new TypeError('Invalid attempt to spread non-iterable instance');
	}

	function _iterableToArray(iter) {
		if (
			Symbol.iterator in Object(iter) ||
			Object.prototype.toString.call(iter) === '[object Arguments]'
		)
			return Array.from(iter);
	}

	function _arrayWithoutHoles(arr) {
		if (Array.isArray(arr)) {
			for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
				arr2[i] = arr[i];
			}
			return arr2;
		}
	}

	/**
	 * Parse non cross-origin stylesheets
	 *
	 * @method parseSameOriginStylesheet
	 * @memberof axe.utils
	 * @param {Object} sheet CSSStylesheet object
	 * @param {Object} options options object from `axe.utils.parseStylesheet`
	 * @param {Array<Number>} priority sheet priority
	 * @param {Array<String>} importedUrls urls of already imported stylesheets
	 * @param {Boolean} isCrossOrigin boolean denoting if a stylesheet is `cross-origin`
	 * @returns {Promise}
	 */
	axe.utils.parseSameOriginStylesheet = function parseSameOriginStylesheet(
		sheet,
		options,
		priority,
		importedUrls
	) {
		var isCrossOrigin =
			arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
		var rules = Array.from(sheet.cssRules);

		if (!rules) {
			return Promise.resolve();
		}
		/**
		 * reference -> https://developer.mozilla.org/en-US/docs/Web/API/CSSRule#Type_constants
		 */

		var cssImportRules = rules.filter(function(r) {
			return r.type === 3;
		}); // type === 3 -> CSSRule.IMPORT_RULE

		/**
		 * when no `@import` rules in given sheet -> resolve the current `sheet` & exit
		 */

		if (!cssImportRules.length) {
			// exit
			return Promise.resolve({
				isCrossOrigin: isCrossOrigin,
				priority: priority,
				root: options.rootNode,
				shadowId: options.shadowId,
				sheet: sheet
			});
		}
		/**
		 * filter rules that are not already fetched
		 */

		var cssImportUrlsNotAlreadyImported = cssImportRules // ensure rule has a href
			.filter(function(rule) {
				return rule.href;
			}) // extract href from object
			.map(function(rule) {
				return rule.href;
			}) // only href that are not already imported
			.filter(function(url) {
				return !importedUrls.includes(url);
			});
		/**
		 * iterate `@import` rules and fetch styles
		 */

		var promises = cssImportUrlsNotAlreadyImported.map(function(
			importUrl,
			cssRuleIndex
		) {
			var newPriority = [].concat(_toConsumableArray(priority), [cssRuleIndex]);
			var isCrossOriginRequest = /^https?:\/\/|^\/\//i.test(importUrl);
			return axe.utils.parseCrossOriginStylesheet(
				importUrl,
				options,
				newPriority,
				importedUrls,
				isCrossOriginRequest
			);
		});
		var nonImportCSSRules = rules.filter(function(r) {
			return r.type !== 3;
		}); // no further rules to process in this sheet

		if (!nonImportCSSRules.length) {
			return Promise.all(promises);
		} // convert all `nonImportCSSRules` style rules into `text` and chain

		promises.push(
			Promise.resolve(
				options.convertDataToStylesheet({
					data: nonImportCSSRules
						.map(function(rule) {
							return rule.cssText;
						})
						.join(),
					isCrossOrigin: isCrossOrigin,
					priority: priority,
					root: options.rootNode,
					shadowId: options.shadowId
				})
			)
		);
		return Promise.all(promises);
	};

	('use strict');

	/**
	 * Parse a given stylesheet
	 *
	 * @method parseStylesheet
	 * @memberof axe.utils
	 * @param {Object} sheet stylesheet to parse
	 * @param {Object} options configuration options object from `axe.utils.parseStylesheets`
	 * @param {Array<Number>} priority priority of stylesheet
	 * @param {Array<String>} importedUrls list of resolved `@import` urls
	 * @param {Boolean} isCrossOrigin boolean denoting if a stylesheet is `cross-origin`, passed for re-parsing `cross-origin` sheets
	 * @returns {Promise}
	 */
	axe.utils.parseStylesheet = function parseStylesheet(
		sheet,
		options,
		priority,
		importedUrls
	) {
		var isCrossOrigin =
			arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
		var isSameOrigin = isSameOriginStylesheet(sheet);

		if (isSameOrigin) {
			/**
			 * resolve `same-origin` stylesheet
			 */
			return axe.utils.parseSameOriginStylesheet(
				sheet,
				options,
				priority,
				importedUrls,
				isCrossOrigin
			);
		}
		/**
		 * resolve `cross-origin` stylesheet
		 */

		return axe.utils.parseCrossOriginStylesheet(
			sheet.href,
			options,
			priority,
			importedUrls,
			true // -> isCrossOrigin
		);
	};
	/**
	 * Check if a given stylesheet is from the `same-origin`
	 * Note:
	 * `sheet.cssRules` throws an error on `cross-origin` stylesheets
	 *
	 * @param {Object} sheet CSS stylesheet
	 * @returns {Boolean}
	 */

	function isSameOriginStylesheet(sheet) {
		try {
			/*eslint no-unused-vars: 0*/
			var rules = sheet.cssRules;
			/**
			 * Safari, does not throw an error when accessing cssRules property,
			 */

			if (!rules && sheet.href) {
				return false;
			}

			return true;
		} catch (e) {
			return false;
		}
	}

	('use strict');

	/*global utils, axe */

	/**
	 * Performance measuring utility shimming the User Timing API
	 *
	 * https://www.html5rocks.com/en/tutorials/webperformance/usertiming/
	 * http://caniuse.com/#search=User%20Timing
	 *
	 */
	utils.performanceTimer = (function() {
		'use strict';
		/**
		 * Get a time/date object using performance.now() if supported
		 * @return {DOMTimeStamp}
		 */

		function now() {
			if (window.performance && window.performance) {
				return window.performance.now();
			}
		}

		var originalTime = null;
		var lastRecordedTime = now();
		/**
		 * @typedef {utils.performanceTimer} Public API Methods
		 */

		return {
			/**
			 * @member {Function} start Kicks off performance timing for overall axe audit
			 */
			start: function start() {
				this.mark('mark_axe_start');
			},

			/**
			 * @member {Function} end Concludes performance timing, compares start/end marks
			 */
			end: function end() {
				this.mark('mark_axe_end');
				this.measure('axe', 'mark_axe_start', 'mark_axe_end');
				this.logMeasures('axe');
			},

			/**
			 * @member {Function} auditStart Starts an audit for a page or frame
			 */
			auditStart: function auditStart() {
				this.mark('mark_audit_start');
			},

			/**
			 * @member {Function} auditEnd Ends an audit for a page or frame, logs measurement of start/end marks
			 */
			auditEnd: function auditEnd() {
				this.mark('mark_audit_end');
				this.measure(
					'audit_start_to_end',
					'mark_audit_start',
					'mark_audit_end'
				); // log audit/rule measures

				this.logMeasures();
			},

			/**
			 * @member {Function} mark Shims creating a new named time stamp, called a mark
			 * @param {String} markName String name to record how long it took to get there.
			 * A mark that already exists will be overwritten.
			 *
			 */
			mark: function mark(markName) {
				if (window.performance && window.performance.mark !== undefined) {
					window.performance.mark(markName);
				}
			},

			/**
			 * @member {Function} measure Shims creating a measure to compare two marks, which can be logged
			 * @param {String} measureName String name to log what is being compared.
			 * Measures that already exist will be overwritten with a new time stamp.
			 * @param {String} startMark String name of mark to start measuring
			 * @param {String} endMark String name of mark to end measuring
			 */
			measure: function measure(measureName, startMark, endMark) {
				if (window.performance && window.performance.measure !== undefined) {
					window.performance.measure(measureName, startMark, endMark);
				}
			},

			/**
			 * @member {Function} logMeasures Iterates through measures and logs any that exist
			 */
			logMeasures: function logMeasures(measureName) {
				function log(req) {
					axe.log('Measure ' + req.name + ' took ' + req.duration + 'ms');
				}

				if (
					window.performance &&
					window.performance.getEntriesByType !== undefined
				) {
					// only output measures that were started after axe started, otherwise
					// we get measures made by the page before axe ran (which is confusing)
					var axeStart = window.performance.getEntriesByName(
						'mark_axe_start'
					)[0];
					var measures = window.performance
						.getEntriesByType('measure')
						.filter(function(measure) {
							return measure.startTime >= axeStart.startTime;
						});

					for (var i = 0; i < measures.length; ++i) {
						var req = measures[i];

						if (req.name === measureName) {
							log(req);
							return;
						}

						log(req);
					}
				}
			},

			/**
			 * @member {Function} timeElapsed Records time since last audit
			 * @return {DOMTimeStamp}
			 */
			timeElapsed: function timeElapsed() {
				return now() - lastRecordedTime;
			},

			/**
			 * @member {Function} reset Resets the time for a new audit
			 */
			reset: function reset() {
				if (!originalTime) {
					originalTime = now();
				}

				lastRecordedTime = now();
			}
		};
	})();

	('use strict');

	/* eslint-disable */

	/*
 These pollyfills came directly from the ES Specification it's self
 Contained within:
	- Object.assign
	- Array.prototype.find
*/
	if (typeof Object.assign !== 'function') {
		(function() {
			Object.assign = function(target) {
				'use strict';

				if (target === undefined || target === null) {
					throw new TypeError('Cannot convert undefined or null to object');
				}

				var output = Object(target);

				for (var index = 1; index < arguments.length; index++) {
					var source = arguments[index];

					if (source !== undefined && source !== null) {
						for (var nextKey in source) {
							if (source.hasOwnProperty(nextKey)) {
								output[nextKey] = source[nextKey];
							}
						}
					}
				}

				return output;
			};
		})();
	}

	if (!Array.prototype.find) {
		Object.defineProperty(Array.prototype, 'find', {
			value: function value(predicate) {
				if (this === null) {
					throw new TypeError(
						'Array.prototype.find called on null or undefined'
					);
				}

				if (typeof predicate !== 'function') {
					throw new TypeError('predicate must be a function');
				}

				var list = Object(this);
				var length = list.length >>> 0;
				var thisArg = arguments[1];
				var value;

				for (var i = 0; i < length; i++) {
					value = list[i];

					if (predicate.call(thisArg, value, i, list)) {
						return value;
					}
				}

				return undefined;
			}
		});
	}

	axe.utils.pollyfillElementsFromPoint = function() {
		if (document.elementsFromPoint) return document.elementsFromPoint;
		if (document.msElementsFromPoint) return document.msElementsFromPoint;

		var usePointer = (function() {
			var element = document.createElement('x');
			element.style.cssText = 'pointer-events:auto';
			return element.style.pointerEvents === 'auto';
		})();

		var cssProp = usePointer ? 'pointer-events' : 'visibility';
		var cssDisableVal = usePointer ? 'none' : 'hidden';
		var style = document.createElement('style');
		style.innerHTML = usePointer
			? '* { pointer-events: all }'
			: '* { visibility: visible }';
		return function(x, y) {
			var current, i, d;
			var elements = [];
			var previousPointerEvents = []; // startup

			document.head.appendChild(style);

			while (
				(current = document.elementFromPoint(x, y)) &&
				elements.indexOf(current) === -1
			) {
				// push the element and its current style
				elements.push(current);
				previousPointerEvents.push({
					value: current.style.getPropertyValue(cssProp),
					priority: current.style.getPropertyPriority(cssProp)
				}); // add "pointer-events: none", to get to the underlying element

				current.style.setProperty(cssProp, cssDisableVal, 'important');
			} // Due to negative index, documentElement could actually not be the last,
			// so we'll simply move it to the end

			if (elements.indexOf(document.documentElement) < elements.length - 1) {
				elements.splice(elements.indexOf(document.documentElement), 1);
				elements.push(document.documentElement);
			} // restore the previous pointer-events values

			for (
				i = previousPointerEvents.length;
				!!(d = previousPointerEvents[--i]);

			) {
				elements[i].style.setProperty(
					cssProp,
					d.value ? d.value : '',
					d.priority
				);
			} // teardown;

			document.head.removeChild(style);
			return elements;
		};
	};

	if (typeof window.addEventListener === 'function') {
		document.elementsFromPoint = axe.utils.pollyfillElementsFromPoint();
	}

	if (!Array.prototype.includes) {
		Object.defineProperty(Array.prototype, 'includes', {
			value: function value(searchElement) {
				'use strict';

				var O = Object(this);
				var len = parseInt(O.length, 10) || 0;

				if (len === 0) {
					return false;
				}

				var n = parseInt(arguments[1], 10) || 0;
				var k;

				if (n >= 0) {
					k = n;
				} else {
					k = len + n;

					if (k < 0) {
						k = 0;
					}
				}

				var currentElement;

				while (k < len) {
					currentElement = O[k];

					if (
						searchElement === currentElement ||
						(searchElement !== searchElement &&
							currentElement !== currentElement)
					) {
						// NaN !== NaN
						return true;
					}

					k++;
				}

				return false;
			}
		});
	} // Production steps of ECMA-262, Edition 5, 15.4.4.17
	// Reference: http://es5.github.io/#x15.4.4.17

	if (!Array.prototype.some) {
		Object.defineProperty(Array.prototype, 'some', {
			value: function value(fun) {
				'use strict';

				if (this == null) {
					throw new TypeError(
						'Array.prototype.some called on null or undefined'
					);
				}

				if (typeof fun !== 'function') {
					throw new TypeError();
				}

				var t = Object(this);
				var len = t.length >>> 0;
				var thisArg = arguments.length >= 2 ? arguments[1] : void 0;

				for (var i = 0; i < len; i++) {
					if (i in t && fun.call(thisArg, t[i], i, t)) {
						return true;
					}
				}

				return false;
			}
		});
	}

	if (!Array.from) {
		Object.defineProperty(Array, 'from', {
			value: (function() {
				var toStr = Object.prototype.toString;

				var isCallable = function isCallable(fn) {
					return (
						typeof fn === 'function' || toStr.call(fn) === '[object Function]'
					);
				};

				var toInteger = function toInteger(value) {
					var number = Number(value);

					if (isNaN(number)) {
						return 0;
					}

					if (number === 0 || !isFinite(number)) {
						return number;
					}

					return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
				};

				var maxSafeInteger = Math.pow(2, 53) - 1;

				var toLength = function toLength(value) {
					var len = toInteger(value);
					return Math.min(Math.max(len, 0), maxSafeInteger);
				}; // The length property of the from method is 1.

				return function from(
					arrayLike
					/*, mapFn, thisArg */
				) {
					// 1. Let C be the this value.
					var C = this; // 2. Let items be ToObject(arrayLike).

					var items = Object(arrayLike); // 3. ReturnIfAbrupt(items).

					if (arrayLike == null) {
						throw new TypeError(
							'Array.from requires an array-like object - not null or undefined'
						);
					} // 4. If mapfn is undefined, then let mapping be false.

					var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
					var T;

					if (typeof mapFn !== 'undefined') {
						// 5. else
						// 5. a If IsCallable(mapfn) is false, throw a TypeError exception.
						if (!isCallable(mapFn)) {
							throw new TypeError(
								'Array.from: when provided, the second argument must be a function'
							);
						} // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.

						if (arguments.length > 2) {
							T = arguments[2];
						}
					} // 10. Let lenValue be Get(items, "length").
					// 11. Let len be ToLength(lenValue).

					var len = toLength(items.length); // 13. If IsConstructor(C) is true, then
					// 13. a. Let A be the result of calling the [[Construct]] internal method of C with an argument list containing the single item len.
					// 14. a. Else, Let A be ArrayCreate(len).

					var A = isCallable(C) ? Object(new C(len)) : new Array(len); // 16. Let k be 0.

					var k = 0; // 17. Repeat, while k < len (also steps a - h)

					var kValue;

					while (k < len) {
						kValue = items[k];

						if (mapFn) {
							A[k] =
								typeof T === 'undefined'
									? mapFn(kValue, k)
									: mapFn.call(T, kValue, k);
						} else {
							A[k] = kValue;
						}

						k += 1;
					} // 18. Let putStatus be Put(A, "length", len, true).

					A.length = len; // 20. Return A.

					return A;
				};
			})()
		});
	}

	if (!String.prototype.includes) {
		String.prototype.includes = function(search, start) {
			if (typeof start !== 'number') {
				start = 0;
			}

			if (start + search.length > this.length) {
				return false;
			} else {
				return this.indexOf(search, start) !== -1;
			}
		};
	}

	('use strict');

	/**
	 * NOTE:
	 * this `eslint` rule is disabled because of calling `getStyleSheetFactory` before it is defined (further below).
	 */

	/* eslint no-use-before-define: 0 */

	/**
	 * Given a rootNode - construct CSSOM
	 * -> get all source nodes (document & document fragments) within given root node
	 * -> recursively call `axe.utils.parseStylesheets` to resolve styles for each node
	 *
	 * @method preloadCssom
	 * @memberof `axe.utils`
	 * @param {Object} options composite options object
	 * @property {Array<String>} options.assets array of preloaded assets requested, eg: [`cssom`]
	 * @property {Number} options.timeout timeout
	 * @property {Object} options.treeRoot (optional) the DOM tree to be inspected
	 * @returns {Promise}
	 */
	axe.utils.preloadCssom = function preloadCssom(_ref) {
		var _ref$treeRoot = _ref.treeRoot,
			treeRoot = _ref$treeRoot === void 0 ? axe._tree[0] : _ref$treeRoot;

		/**
		 * get all `document` and `documentFragment` with in given `tree`
		 */
		var rootNodes = axe.utils.getAllRootNodesInTree(treeRoot);

		if (!rootNodes.length) {
			return Promise.resolve();
		}

		var dynamicDoc = document.implementation.createHTMLDocument(
			'Dynamic document for loading cssom'
		);
		var convertDataToStylesheet = axe.utils.getStyleSheetFactory(dynamicDoc);
		return getCssomForAllRootNodes(rootNodes, convertDataToStylesheet).then(
			function(assets) {
				return flattenAssets(assets);
			}
		);
	};
	/**
	 * Process CSSOM on all root nodes
	 *
	 * @param {Array<Object>} rootNodes array of root nodes, where node  is an enhanced `document` or `documentFragment` object returned from `getAllRootNodesInTree`
	 * @param {Function} convertDataToStylesheet fn to convert given data to Stylesheet object
	 * @returns {Promise}
	 */

	function getCssomForAllRootNodes(rootNodes, convertDataToStylesheet) {
		var promises = [];
		rootNodes.forEach(function(_ref2, index) {
			var rootNode = _ref2.rootNode,
				shadowId = _ref2.shadowId;
			var sheets = getStylesheetsOfRootNode(
				rootNode,
				shadowId,
				convertDataToStylesheet
			);

			if (!sheets) {
				return Promise.all(promises);
			}

			var rootIndex = index + 1;
			var parseOptions = {
				rootNode: rootNode,
				shadowId: shadowId,
				convertDataToStylesheet: convertDataToStylesheet,
				rootIndex: rootIndex
			};
			/**
			 * Note:
			 * `importedUrls` - keeps urls of already imported stylesheets, to prevent re-fetching
			 * eg: nested, cyclic or cross referenced `@import` urls
			 */

			var importedUrls = [];
			var p = Promise.all(
				sheets.map(function(sheet, sheetIndex) {
					var priority = [rootIndex, sheetIndex];
					return axe.utils.parseStylesheet(
						sheet,
						parseOptions,
						priority,
						importedUrls
					);
				})
			);
			promises.push(p);
		});
		return Promise.all(promises);
	}
	/**
	 * Flatten CSSOM assets
	 *
	 * @param {Array.<Object[]>} assets nested assets (varying depth)
	 * @returns {Array<Object>} Array of CSSOM object
	 */

	function flattenAssets(assets) {
		return assets.reduce(function(acc, val) {
			return Array.isArray(val)
				? acc.concat(flattenAssets(val))
				: acc.concat(val);
		}, []);
	}
	/**
	 * Get stylesheet(s) for root
	 *
	 * @param {Object} options.rootNode `document` or `documentFragment`
	 * @param {String} options.shadowId an id if undefined denotes that given root is a document fragment/ shadowDOM
	 * @param {Function} options.convertDataToStylesheet a utility function to generate a style sheet from given data (text)
	 * @returns {Array<Object>} an array of stylesheets
	 */

	function getStylesheetsOfRootNode(
		rootNode,
		shadowId,
		convertDataToStylesheet
	) {
		var sheets; // nodeType === 11  -> DOCUMENT_FRAGMENT

		if (rootNode.nodeType === 11 && shadowId) {
			sheets = getStylesheetsFromDocumentFragment(
				rootNode,
				convertDataToStylesheet
			);
		} else {
			sheets = getStylesheetsFromDocument(rootNode);
		}

		return filterStylesheetsWithSameHref(sheets);
	}
	/**
	 * Get stylesheets from `documentFragment`
	 *
	 * @property {Object} options.rootNode `documentFragment`
	 * @property {Function} options.convertDataToStylesheet a utility function to generate a stylesheet from given data
	 * @returns {Array<Object>}
	 */

	function getStylesheetsFromDocumentFragment(
		rootNode,
		convertDataToStylesheet
	) {
		return Array.from(rootNode.children)
			.filter(filerStyleAndLinkAttributesInDocumentFragment) // Reducer to convert `<style></style>` and `<link>` references to `CSSStyleSheet` object
			.reduce(function(out, node) {
				var nodeName = node.nodeName.toUpperCase();
				var data = nodeName === 'STYLE' ? node.textContent : node;
				var isLink = nodeName === 'LINK';
				var stylesheet = convertDataToStylesheet({
					data: data,
					isLink: isLink,
					root: rootNode
				});
				out.push(stylesheet.sheet);
				return out;
			}, []);
	}
	/**
	 * Get stylesheets from `document`
	 * -> filter out stylesheet that are `media=print`
	 *
	 * @param {Object} rootNode `document`
	 * @returns {Array<Object>}
	 */

	function getStylesheetsFromDocument(rootNode) {
		return Array.from(rootNode.styleSheets).filter(function(sheet) {
			return filterMediaIsPrint(sheet.media.mediaText);
		});
	}
	/**
	 * Get all `<style></style>` and `<link>` attributes
	 * -> limit to only `style` or `link` attributes with `rel=stylesheet` and `media != print`
	 *
	 * @param {Object} node HTMLElement
	 * @returns {Boolean}
	 */

	function filerStyleAndLinkAttributesInDocumentFragment(node) {
		var nodeName = node.nodeName.toUpperCase();
		var linkHref = node.getAttribute('href');
		var linkRel = node.getAttribute('rel');
		var isLink =
			nodeName === 'LINK' &&
			linkHref &&
			linkRel &&
			node.rel.toUpperCase().includes('STYLESHEET');
		var isStyle = nodeName === 'STYLE';
		return isStyle || (isLink && filterMediaIsPrint(node.media));
	}
	/**
	 * Exclude `link[rel='stylesheet]` attributes where `media=print`
	 *
	 * @param {String} media media value eg: 'print'
	 * @returns {Boolean}
	 */

	function filterMediaIsPrint(media) {
		if (!media) {
			return true;
		}

		return !media.toUpperCase().includes('PRINT');
	}
	/**
	 * Exclude any duplicate `stylesheets`, that share the same `href`
	 *
	 * @param {Array<Object>} sheets stylesheets
	 * @returns {Array<Object>}
	 */

	function filterStylesheetsWithSameHref(sheets) {
		var hrefs = [];
		return sheets.filter(function(sheet) {
			if (!sheet.href) {
				// include sheets without `href`
				return true;
			} // if `href` is present, ensure they are not duplicates

			if (hrefs.includes(sheet.href)) {
				return false;
			}

			hrefs.push(sheet.href);
			return true;
		});
	}

	('use strict');

	function _toConsumableArray(arr) {
		return (
			_arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
		);
	}

	function _nonIterableSpread() {
		throw new TypeError('Invalid attempt to spread non-iterable instance');
	}

	function _iterableToArray(iter) {
		if (
			Symbol.iterator in Object(iter) ||
			Object.prototype.toString.call(iter) === '[object Arguments]'
		)
			return Array.from(iter);
	}

	function _arrayWithoutHoles(arr) {
		if (Array.isArray(arr)) {
			for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
				arr2[i] = arr[i];
			}
			return arr2;
		}
	}

	/**
	 * Given a rootNode
	 * -> get all HTMLMediaElement's and ensure their metadata is loaded
	 *
	 * @method preloadMedia
	 * @memberof axe.utils
	 * @property {Object} options.treeRoot (optional) the DOM tree to be inspected
	 */
	axe.utils.preloadMedia = function preloadMedia(_ref) {
		var _ref$treeRoot = _ref.treeRoot,
			treeRoot = _ref$treeRoot === void 0 ? axe._tree[0] : _ref$treeRoot;
		var rootNodes = axe.utils.getAllRootNodesInTree(treeRoot);

		if (!rootNodes || !rootNodes.length) {
			return Promise.resolve();
		}

		var mediaNodes = rootNodes.reduce(function(out, _ref2) {
			var rootNode = _ref2.rootNode;
			out.push.apply(
				out,
				_toConsumableArray(rootNode.querySelectorAll('audio, video'))
			);
			return out;
		}, []);
		return Promise.all(
			mediaNodes.map(function(node) {
				return isMediaElementReady(node);
			})
		);
	};
	/**
	 * Ensures a media element's metadata is loaded
	 * @param {HTMLMediaElement} elm elm
	 * @returns {Promise}
	 */

	function isMediaElementReady(elm) {
		return new Promise(function(resolve, reject) {
			/**
			 * See - https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/readyState
			 */
			if (elm.readyState > 0) {
				resolve();
			}

			function onMediaReady() {
				elm.removeEventListener('loadedmetadata', onMediaReady);

				if (elm.readyState <= 0) {
					reject(
						'Preload media element has wrong readyState of HAVE_NOTHING (0)'
					);
				}

				resolve();
			}
			/**
			 * Given media is not ready, wire up listener for `loadedmetadata`
			 * See - https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loadedmetadata_event
			 */

			elm.addEventListener('loadedmetadata', onMediaReady);
		});
	}
	/**
	 * todo:jey
	 * - add tests for this preloadFn, perhaps extract this to be its own PR
	 */

	('use strict');

	function _extends() {
		_extends =
			Object.assign ||
			function(target) {
				for (var i = 1; i < arguments.length; i++) {
					var source = arguments[i];
					for (var key in source) {
						if (Object.prototype.hasOwnProperty.call(source, key)) {
							target[key] = source[key];
						}
					}
				}
				return target;
			};
		return _extends.apply(this, arguments);
	}

	function _defineProperty(obj, key, value) {
		if (key in obj) {
			Object.defineProperty(obj, key, {
				value: value,
				enumerable: true,
				configurable: true,
				writable: true
			});
		} else {
			obj[key] = value;
		}
		return obj;
	}

	function _typeof(obj) {
		if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
			_typeof = function _typeof(obj) {
				return typeof obj;
			};
		} else {
			_typeof = function _typeof(obj) {
				return obj &&
					typeof Symbol === 'function' &&
					obj.constructor === Symbol &&
					obj !== Symbol.prototype
					? 'symbol'
					: typeof obj;
			};
		}
		return _typeof(obj);
	}

	/**
	 * Validated the preload object
	 * @param {Object | boolean} preload configuration object or boolean passed via the options parameter to axe.run
	 * @return {boolean}
	 * @private
	 */
	function isValidPreloadObject(preload) {
		return _typeof(preload) === 'object' && Array.isArray(preload.assets);
	}
	/**
	 * Returns a boolean which decides if preload is configured
	 * @param {Object} options run configuration options (or defaults) passed via axe.run
	 * @return {boolean} defaults to true
	 */

	axe.utils.shouldPreload = function shouldPreload(options) {
		if (!options || options.preload === undefined || options.preload === null) {
			return true; // by default `preload` requested assets eg: ['cssom']
		}

		if (typeof options.preload === 'boolean') {
			return options.preload;
		}

		return isValidPreloadObject(options.preload);
	};
	/**
	 * Constructs a configuration object representing the preload requested assets & timeout
	 * @param {Object} options run configuration options (or defaults) passed via axe.run
	 * @return {Object} configuration
	 */

	axe.utils.getPreloadConfig = function getPreloadConfig(options) {
		var _axe$constants$preloa = axe.constants.preload,
			assets = _axe$constants$preloa.assets,
			timeout = _axe$constants$preloa.timeout;
		var config = {
			assets: assets,
			timeout: timeout
		}; // if no `preload` is configured via `options` - return default config

		if (!options.preload) {
			return config;
		} // if type is boolean

		if (typeof options.preload === 'boolean') {
			return config;
		} // check if requested assets to preload are valid items

		var areRequestedAssetsValid = options.preload.assets.every(function(a) {
			return assets.includes(a.toLowerCase());
		});

		if (!areRequestedAssetsValid) {
			throw new Error(
				'Requested assets, not supported. ' +
					'Supported assets are: '.concat(assets.join(', '), '.')
			);
		} // unique assets to load, in case user had requested same asset type many times.

		config.assets = axe.utils.uniqueArray(
			options.preload.assets.map(function(a) {
				return a.toLowerCase();
			}),
			[]
		);

		if (
			options.preload.timeout &&
			typeof options.preload.timeout === 'number' &&
			!Number.isNaN(options.preload.timeout)
		) {
			config.timeout = options.preload.timeout;
		}

		return config;
	};
	/**
	 * Returns a Promise with results of all requested preload(able) assets. eg: ['cssom'].
	 *
	 * @param {Object} options run configuration options (or defaults) passed via axe.run
	 * @return {Object} Promise
	 */

	axe.utils.preload = function preload(options) {
		var preloadFunctionsMap = {
			cssom: axe.utils.preloadCssom,
			media: axe.utils.preloadMedia
		};
		var shouldPreload = axe.utils.shouldPreload(options);

		if (!shouldPreload) {
			return Promise.resolve();
		}

		return new Promise(function(resolve, reject) {
			var _axe$utils$getPreload = axe.utils.getPreloadConfig(options),
				assets = _axe$utils$getPreload.assets,
				timeout = _axe$utils$getPreload.timeout;
			/**
			 * Start `timeout` timer for preloading assets
			 * -> reject if allowed time expires.
			 */

			setTimeout(function() {
				return reject('Preload assets timed out.');
			}, timeout);
			/**
			 * Fetch requested `assets`
			 */

			Promise.all(
				assets.map(function(asset) {
					return preloadFunctionsMap[asset](options).then(function(results) {
						return _defineProperty({}, asset, results);
					});
				})
			).then(function(results) {
				/**
				 * Combine array of results into an object map
				 *
				 * From ->
				 * 	[{cssom: [...], aom: [...]}]
				 * To ->
				 * 	{
				 * 		cssom: [...]
				 * 	 	aom: [...]
				 * 	}
				 */
				var preloadAssets = results.reduce(function(out, result) {
					return _extends({}, out, {}, result);
				}, {});
				resolve(preloadAssets);
			});
		});
	};

	('use strict');

	/* global helpers */
	var dataRegex = /\$\{\s?data\s?\}/g;
	/**
	 * Replace a placeholder with the value of a data string or object
	 * @param {String} str
	 * @param {String|Object} data
	 */

	function substitute(str, data) {
		// replace all instances of ${ data } with the value of the string
		if (typeof data === 'string') {
			return str.replace(dataRegex, data);
		} // replace all instances of ${ data[prop] } with the value of the property

		for (var prop in data) {
			if (data.hasOwnProperty(prop)) {
				var regex = new RegExp('\\${\\s?data\\.' + prop + '\\s?}', 'g');
				str = str.replace(regex, data[prop]);
			}
		}

		return str;
	}
	/**
	 * Process a metadata message.
	 * @param {String|Object} message
	 * @param {Object} data
	 * @return {String}
	 */

	axe.utils.processMessage = function processMessage(message, data) {
		if (!message) {
			return;
		} // data as array

		if (Array.isArray(data)) {
			data.values = data.join(', ');

			if (
				typeof message.singular === 'string' &&
				typeof message.plural === 'string'
			) {
				var _str = data.length === 1 ? message.singular : message.plural;

				return substitute(_str, data);
			} // no singular/plural message so just pass data

			return substitute(message, data);
		} // message is a string that uses data as a string or object properties

		if (typeof message === 'string') {
			return substitute(message, data);
		} // message is an object that uses value of data to determine message

		if (typeof data === 'string') {
			var _str2 = message[data];
			return substitute(_str2, data);
		} // message uses value of data property to determine message

		var str = message['default'] || helpers.incompleteFallbackMessage();

		if (data && data.messageKey && message[data.messageKey]) {
			str = message[data.messageKey];
		}

		return processMessage(str, data);
	};

	('use strict');

	function _typeof(obj) {
		if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
			_typeof = function _typeof(obj) {
				return typeof obj;
			};
		} else {
			_typeof = function _typeof(obj) {
				return obj &&
					typeof Symbol === 'function' &&
					obj.constructor === Symbol &&
					obj !== Symbol.prototype
					? 'symbol'
					: typeof obj;
			};
		}
		return _typeof(obj);
	}

	/* global helpers */

	/**
	 * Construct incomplete message from check.data
	 * @param  {Object} checkData Check result with reason specified
	 * @param  {Object} messages Source data object with message options
	 * @return  {String}
	 * @private
	 */
	function getIncompleteReason(checkData, messages) {
		function getDefaultMsg(messages) {
			if (messages.incomplete && messages.incomplete['default']) {
				// fall back to the default message if no reason specified
				return messages.incomplete['default'];
			} else {
				return helpers.incompleteFallbackMessage();
			}
		}

		if (checkData && checkData.missingData) {
			try {
				var msg = messages.incomplete[checkData.missingData[0].reason];

				if (!msg) {
					throw new Error();
				}

				return msg;
			} catch (e) {
				if (typeof checkData.missingData === 'string') {
					// return a string with the appropriate reason
					return messages.incomplete[checkData.missingData];
				} else {
					return getDefaultMsg(messages);
				}
			}
		} else if (checkData && checkData.messageKey) {
			return messages.incomplete[checkData.messageKey];
		} else {
			return getDefaultMsg(messages);
		}
	}
	/**
	 * Extend checksData with the correct result message
	 * @param  {Object} checksData The check result data
	 * @param  {Boolean} shouldBeTrue Result of pass/fail check run
	 * @return {Function}
	 * @private
	 */

	function extender(checksData, shouldBeTrue) {
		'use strict';

		return function(check) {
			var sourceData = checksData[check.id] || {};
			var messages = sourceData.messages || {};
			var data = Object.assign({}, sourceData);
			delete data.messages;

			if (check.result === undefined) {
				// handle old doT template
				if (
					_typeof(messages.incomplete) === 'object' &&
					!Array.isArray(check.data)
				) {
					data.message = getIncompleteReason(check.data, messages);
				} // fallback to new process message style

				if (!data.message) {
					data.message = messages.incomplete;
				}
			} else {
				data.message =
					check.result === shouldBeTrue ? messages.pass : messages.fail;
			} // don't process doT template functions

			if (typeof data.message !== 'function') {
				data.message = axe.utils.processMessage(data.message, check.data);
			}

			axe.utils.extendMetaData(check, data);
		};
	}
	/**
	 * Publish metadata from axe._audit.data
	 * @param  {RuleResult} result Result to publish to
	 * @private
	 */

	axe.utils.publishMetaData = function(ruleResult) {
		'use strict';

		var checksData = axe._audit.data.checks || {};
		var rulesData = axe._audit.data.rules || {};
		var rule = axe.utils.findBy(axe._audit.rules, 'id', ruleResult.id) || {};
		ruleResult.tags = axe.utils.clone(rule.tags || []);
		var shouldBeTrue = extender(checksData, true);
		var shouldBeFalse = extender(checksData, false);
		ruleResult.nodes.forEach(function(detail) {
			detail.any.forEach(shouldBeTrue);
			detail.all.forEach(shouldBeTrue);
			detail.none.forEach(shouldBeFalse);
		});
		axe.utils.extendMetaData(
			ruleResult,
			axe.utils.clone(rulesData[ruleResult.id] || {})
		);
	};

	('use strict');

	// The lines below is because the latedef option does not work
	var convertExpressions = function convertExpressions() {};

	var matchExpressions = function matchExpressions() {}; // todo: implement an option to follow aria-owns

	function matchesTag(vNode, exp) {
		return (
			vNode.props.nodeType === 1 &&
			(exp.tag === '*' || vNode.props.nodeName === exp.tag)
		);
	}

	function matchesClasses(vNode, exp) {
		return (
			!exp.classes ||
			exp.classes.every(function(cl) {
				return vNode.hasClass(cl.value);
			})
		);
	}

	function matchesAttributes(vNode, exp) {
		return (
			!exp.attributes ||
			exp.attributes.every(function(att) {
				var nodeAtt = vNode.attr(att.key);
				return nodeAtt !== null && (!att.value || att.test(nodeAtt));
			})
		);
	}

	function matchesId(vNode, exp) {
		return !exp.id || vNode.props.id === exp.id;
	}

	function matchesPseudos(target, exp) {
		if (
			!exp.pseudos ||
			exp.pseudos.every(function(pseudo) {
				if (pseudo.name === 'not') {
					return !matchExpressions([target], pseudo.expressions, false).length;
				}

				throw new Error(
					'the pseudo selector ' + pseudo.name + ' has not yet been implemented'
				);
			})
		) {
			return true;
		}

		return false;
	}

	var escapeRegExp = (function() {
		/*! Credit: XRegExp 0.6.1 (c) 2007-2008 Steven Levithan <http://stevenlevithan.com/regex/xregexp/> MIT License */
		var from = /(?=[\-\[\]{}()*+?.\\\^$|,#\s])/g;
		var to = '\\';
		return function(string) {
			return string.replace(from, to);
		};
	})();

	var reUnescape = /\\/g;

	function convertAttributes(atts) {
		/*! Credit Mootools Copyright Mootools, MIT License */
		if (!atts) {
			return;
		}

		return atts.map(function(att) {
			var attributeKey = att.name.replace(reUnescape, '');
			var attributeValue = (att.value || '').replace(reUnescape, '');
			var test, regexp;

			switch (att.operator) {
				case '^=':
					regexp = new RegExp('^' + escapeRegExp(attributeValue));
					break;

				case '$=':
					regexp = new RegExp(escapeRegExp(attributeValue) + '$');
					break;

				case '~=':
					regexp = new RegExp(
						'(^|\\s)' + escapeRegExp(attributeValue) + '(\\s|$)'
					);
					break;

				case '|=':
					regexp = new RegExp('^' + escapeRegExp(attributeValue) + '(-|$)');
					break;

				case '=':
					test = function test(value) {
						return attributeValue === value;
					};

					break;

				case '*=':
					test = function test(value) {
						return value && value.includes(attributeValue);
					};

					break;

				case '!=':
					test = function test(value) {
						return attributeValue !== value;
					};

					break;

				default:
					test = function test(value) {
						return !!value;
					};
			}

			if (attributeValue === '' && /^[*$^]=$/.test(att.operator)) {
				test = function test() {
					return false;
				};
			}

			if (!test) {
				test = function test(value) {
					return value && regexp.test(value);
				};
			}

			return {
				key: attributeKey,
				value: attributeValue,
				test: test
			};
		});
	}

	function convertClasses(classes) {
		if (!classes) {
			return;
		}

		return classes.map(function(className) {
			className = className.replace(reUnescape, '');
			return {
				value: className,
				regexp: new RegExp('(^|\\s)' + escapeRegExp(className) + '(\\s|$)')
			};
		});
	}

	function convertPseudos(pseudos) {
		if (!pseudos) {
			return;
		}

		return pseudos.map(function(p) {
			var expressions;

			if (p.name === 'not') {
				expressions = p.value;
				expressions = expressions.selectors
					? expressions.selectors
					: [expressions];
				expressions = convertExpressions(expressions);
			}

			return {
				name: p.name,
				expressions: expressions,
				value: p.value
			};
		});
	}
	/**
	 * convert the css-selector-parser format into the Slick format
	 * @private
	 * @param Array {Object} expressions
	 * @return Array {Object}
	 *
	 */

	convertExpressions = function convertExpressions(expressions) {
		return expressions.map(function(exp) {
			var newExp = [];
			var rule = exp.rule;

			while (rule) {
				/* eslint no-restricted-syntax: 0 */
				// `.tagName` is a property coming from the `CSSSelectorParser` library
				newExp.push({
					tag: rule.tagName ? rule.tagName.toLowerCase() : '*',
					combinator: rule.nestingOperator ? rule.nestingOperator : ' ',
					id: rule.id,
					attributes: convertAttributes(rule.attrs),
					classes: convertClasses(rule.classNames),
					pseudos: convertPseudos(rule.pseudos)
				});
				rule = rule.rule;
			}

			return newExp;
		});
	};

	function createLocalVariables(vNodes, anyLevel, thisLevel, parentShadowId) {
		var retVal = {
			vNodes: vNodes.slice(),
			anyLevel: anyLevel,
			thisLevel: thisLevel,
			parentShadowId: parentShadowId
		};
		retVal.vNodes.reverse();
		return retVal;
	}

	function matchesSelector(vNode, exp) {
		return (
			matchesTag(vNode, exp[0]) &&
			matchesClasses(vNode, exp[0]) &&
			matchesAttributes(vNode, exp[0]) &&
			matchesId(vNode, exp[0]) &&
			matchesPseudos(vNode, exp[0])
		);
	}

	matchExpressions = function matchExpressions(
		domTree,
		expressions,
		recurse,
		filter
	) {
		var stack = [];
		var vNodes = Array.isArray(domTree) ? domTree : [domTree];
		var currentLevel = createLocalVariables(
			vNodes,
			expressions,
			[],
			domTree[0].shadowId
		);
		var result = [];

		while (currentLevel.vNodes.length) {
			var vNode = currentLevel.vNodes.pop();
			var childOnly = []; // we will add hierarchical '>' selectors here

			var childAny = [];
			var combined = currentLevel.anyLevel
				.slice()
				.concat(currentLevel.thisLevel);
			var added = false; // see if node matches

			for (var i = 0; i < combined.length; i++) {
				var exp = combined[i];

				if (
					(!exp[0].id || vNode.shadowId === currentLevel.parentShadowId) &&
					matchesSelector(vNode, exp)
				) {
					if (exp.length === 1) {
						if (!added && (!filter || filter(vNode))) {
							result.push(vNode);
							added = true;
						}
					} else {
						var rest = exp.slice(1);

						if ([' ', '>'].includes(rest[0].combinator) === false) {
							throw new Error(
								'axe.utils.querySelectorAll does not support the combinator: ' +
									exp[1].combinator
							);
						}

						if (rest[0].combinator === '>') {
							// add the rest to the childOnly array
							childOnly.push(rest);
						} else {
							// add the rest to the childAny array
							childAny.push(rest);
						}
					}
				}

				if (
					(!exp[0].id || vNode.shadowId === currentLevel.parentShadowId) &&
					currentLevel.anyLevel.includes(exp)
				) {
					childAny.push(exp);
				}
			} // "recurse"

			if (vNode.children && vNode.children.length && recurse) {
				stack.push(currentLevel);
				currentLevel = createLocalVariables(
					vNode.children,
					childAny,
					childOnly,
					vNode.shadowId
				);
			} // check for "return"

			while (!currentLevel.vNodes.length && stack.length) {
				currentLevel = stack.pop();
			}
		}

		return result;
	};
	/**
	 * querySelectorAll implementation that operates on the flattened tree (supports shadow DOM)
	 * @method querySelectorAll
	 * @memberof axe.utils
	 * @param	{NodeList} domTree flattened tree collection to search
	 * @param	{String} selector String containing one or more CSS selectors separated by commas
	 * @return {NodeList} Elements matched by any of the selectors
	 */

	axe.utils.querySelectorAll = function(domTree, selector) {
		return axe.utils.querySelectorAllFilter(domTree, selector);
	};
	/**
	 * querySelectorAllFilter implements querySelectorAll on the virtual DOM with
	 * ability to filter the returned nodes using an optional supplied filter function
	 *
	 * @method querySelectorAllFilter
	 * @memberof axe.utils
	 * @param	{NodeList} domTree flattened tree collection to search
	 * @param	{String} selector String containing one or more CSS selectors separated by commas
	 * @param	{Function} filter function (optional)
	 * @return {Array} Elements matched by any of the selectors and filtered by the filter function
	 */

	axe.utils.querySelectorAllFilter = function(domTree, selector, filter) {
		domTree = Array.isArray(domTree) ? domTree : [domTree];
		var expressions = axe.utils.cssParser.parse(selector);
		expressions = expressions.selectors ? expressions.selectors : [expressions];
		expressions = convertExpressions(expressions);
		return matchExpressions(domTree, expressions, true, filter);
	};

	('use strict');

	function _typeof(obj) {
		if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
			_typeof = function _typeof(obj) {
				return typeof obj;
			};
		} else {
			_typeof = function _typeof(obj) {
				return obj &&
					typeof Symbol === 'function' &&
					obj.constructor === Symbol &&
					obj !== Symbol.prototype
					? 'symbol'
					: typeof obj;
			};
		}
		return _typeof(obj);
	}

	(function() {
		'use strict';

		function noop() {}

		function funcGuard(f) {
			if (typeof f !== 'function') {
				throw new TypeError('Queue methods require functions as arguments');
			}
		}
		/**
		 * Create an asynchronous "queue", list of functions to be invoked in parallel, but not necessarily returned in order
		 * @return {Queue} The newly generated "queue"
		 */

		function queue() {
			var tasks = [];
			var started = 0;
			var remaining = 0; // number of tasks not yet finished

			var completeQueue = noop;
			var complete = false;
			var err; // By default, wait until the next tick,
			// if no catch was set, throw to console.

			var defaultFail = function defaultFail(e) {
				err = e;
				setTimeout(function() {
					if (err !== undefined && err !== null) {
						axe.log('Uncaught error (of queue)', err);
					}
				}, 1);
			};

			var failed = defaultFail;

			function createResolve(i) {
				return function(r) {
					tasks[i] = r;
					remaining -= 1;

					if (!remaining && completeQueue !== noop) {
						complete = true;
						completeQueue(tasks);
					}
				};
			}

			function abort(msg) {
				// reset tasks
				completeQueue = noop; // notify catch

				failed(msg); // return unfinished work

				return tasks;
			}

			function pop() {
				var length = tasks.length;

				for (; started < length; started++) {
					var task = tasks[started];

					try {
						task.call(null, createResolve(started), abort);
					} catch (e) {
						abort(e);
					}
				}
			}

			var q = {
				/**
				 * Defer a function that may or may not run asynchronously.
				 *
				 * First parameter should be the function to execute with subsequent
				 * parameters being passed as arguments to that function
				 */
				defer: function defer(fn) {
					if (_typeof(fn) === 'object' && fn.then && fn['catch']) {
						var defer = fn;

						fn = function fn(resolve, reject) {
							defer.then(resolve)['catch'](reject);
						};
					}

					funcGuard(fn);

					if (err !== undefined) {
						return;
					} else if (complete) {
						throw new Error('Queue already completed');
					}

					tasks.push(fn);
					++remaining;
					pop();
					return q;
				},

				/**
				 * The callback to execute once all "deferred" functions have completed.  Will only be invoked once.
				 * @param  {Function} f The callback, receives an array of the return/callbacked
				 * values of each of the "deferred" functions
				 */
				then: function then(fn) {
					funcGuard(fn);

					if (completeQueue !== noop) {
						throw new Error('queue `then` already set');
					}

					if (!err) {
						completeQueue = fn;

						if (!remaining) {
							complete = true;
							completeQueue(tasks);
						}
					}

					return q;
				},
				catch: function _catch(fn) {
					funcGuard(fn);

					if (failed !== defaultFail) {
						throw new Error('queue `catch` already set');
					}

					if (!err) {
						failed = fn;
					} else {
						fn(err);
						err = null;
					}

					return q;
				},

				/**
				 * Abort the "queue" and prevent `then` function from firing
				 * @param  {Function} fn The callback to execute; receives an array of the results which have completed
				 */
				abort: abort
			};
			return q;
		}

		axe.utils.queue = queue;
	})();

	('use strict');

	function _typeof(obj) {
		if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
			_typeof = function _typeof(obj) {
				return typeof obj;
			};
		} else {
			_typeof = function _typeof(obj) {
				return obj &&
					typeof Symbol === 'function' &&
					obj.constructor === Symbol &&
					obj !== Symbol.prototype
					? 'symbol'
					: typeof obj;
			};
		}
		return _typeof(obj);
	}

	/*global uuid, utils, axe */
	(function(exports) {
		'use strict';

		var messages = {},
			subscribers = {},
			errorTypes = Object.freeze([
				'EvalError',
				'RangeError',
				'ReferenceError',
				'SyntaxError',
				'TypeError',
				'URIError'
			]);
		/**
		 * get the unique string to be used to identify our instance of axe
		 * @private
		 */

		function _getSource() {
			var application = 'axeAPI',
				version = '',
				src;

			if (typeof axe !== 'undefined' && axe._audit && axe._audit.application) {
				application = axe._audit.application;
			}

			if (typeof axe !== 'undefined') {
				version = axe.version;
			}

			src = application + '.' + version;
			return src;
		}
		/**
		 * Verify the received message is from the "respondable" module
		 * @private
		 * @param  {Object} postedMessage The message received via postMessage
		 * @return {Boolean}              `true` if the message is verified from respondable
		 */

		function verify(postedMessage) {
			if (
				// Check incoming message is valid
				_typeof(postedMessage) === 'object' &&
				typeof postedMessage.uuid === 'string' &&
				postedMessage._respondable === true
			) {
				var messageSource = _getSource();

				return (
					// Check the version matches
					postedMessage._source === messageSource || // Allow free communication with axe test
					postedMessage._source === 'axeAPI.x.y.z' ||
					messageSource === 'axeAPI.x.y.z'
				);
			}

			return false;
		}
		/**
		 * Posts the message to correct frame.
		 * This abstraction necessary because IE9 & 10 do not support posting Objects; only strings
		 * @private
		 * @param  {Window}   win      The `window` to post the message to
		 * @param  {String}   topic    The topic of the message
		 * @param  {Object}   message  The message content
		 * @param  {String}   uuid     The UUID, or pseudo-unique ID of the message
		 * @param  {Boolean}  keepalive Whether to allow multiple responses - default is false
		 * @param  {Function} callback The function to invoke when/if the message is responded to
		 */

		function post(win, topic, message, uuid, keepalive, callback) {
			var error;

			if (message instanceof Error) {
				error = {
					name: message.name,
					message: message.message,
					stack: message.stack
				};
				message = undefined;
			}

			var data = {
				uuid: uuid,
				topic: topic,
				message: message,
				error: error,
				_respondable: true,
				_source: _getSource(),
				_keepalive: keepalive
			};

			var axeRespondables = axe._cache.get('axeRespondables');

			if (!axeRespondables) {
				axeRespondables = {};

				axe._cache.set('axeRespondables', axeRespondables);
			}

			axeRespondables[uuid] = true;

			if (typeof callback === 'function') {
				messages[uuid] = callback;
			}

			win.postMessage(JSON.stringify(data), '*');
		}
		/**
		 * Post a message to a window who may or may not respond to it.
		 * @param  {Window}   win      The window to post the message to
		 * @param  {String}   topic    The topic of the message
		 * @param  {Object}   message  The message content
		 * @param  {Boolean}  keepalive Whether to allow multiple responses - default is false
		 * @param  {Function} callback The function to invoke when/if the message is responded to
		 */

		function respondable(win, topic, message, keepalive, callback) {
			var id = uuid.v1();
			post(win, topic, message, id, keepalive, callback);
		}
		/**
		 * Subscribe to messages sent via the `respondable` module.
		 *
		 * Axe._load uses this to listen for messages from other frames
		 *
		 * @param  {String}   topic    The topic to listen to
		 * @param  {Function} callback The function to invoke when a message is received
		 */

		respondable.subscribe = function(topic, callback) {
			subscribers[topic] = callback;
		};
		/**
		 * checks if the current context is inside a frame
		 * @return {Boolean}
		 */

		respondable.isInFrame = function(win) {
			win = win || window;
			return !!win.frameElement;
		};
		/**
		 * Helper closure to create a function that may be used to respond to a message
		 * @private
		 * @param  {Window} source The window from which the message originated
		 * @param  {String} topic  The topic of the message
		 * @param  {String} uuid   The "unique" ID of the original message
		 * @return {Function}      A function that may be invoked to respond to the message
		 */

		function createResponder(source, topic, uuid) {
			return function(message, keepalive, callback) {
				post(source, topic, message, uuid, keepalive, callback);
			};
		}
		/**
		 * Publishes the "respondable" message to the appropriate subscriber
		 * @private
		 * @param  {Window}  source    The window from which the message originated
		 * @param  {Object}  data      The data sent with the message
		 * @param  {Boolean} keepalive Whether to allow multiple responses - default is false
		 */

		function publish(source, data, keepalive) {
			var topic = data.topic;
			var subscriber = subscribers[topic];

			if (subscriber) {
				var responder = createResponder(source, null, data.uuid);
				subscriber(data.message, keepalive, responder);
			}
		}
		/**
		 * Convert a javascript Error into something that can be stringified
		 * @param  {Error} error  Any type of error
		 * @return {Object}       Processable object
		 */

		function buildErrorObject(error) {
			var msg = error.message || 'Unknown error occurred';
			var errorName = errorTypes.includes(error.name) ? error.name : 'Error';
			var ErrConstructor = window[errorName] || Error;

			if (error.stack) {
				msg += '\n' + error.stack.replace(error.message, '');
			}

			return new ErrConstructor(msg);
		}
		/**
		 * Parse the received message for processing
		 * @param  {string} dataString Message received
		 * @return {object}            Object to be used for pub/sub
		 */

		function parseMessage(dataString) {
			/*eslint no-empty: 0*/
			var data;

			if (typeof dataString !== 'string') {
				return;
			}

			try {
				data = JSON.parse(dataString);
			} catch (ex) {}

			if (!verify(data)) {
				return;
			}

			if (_typeof(data.error) === 'object') {
				data.error = buildErrorObject(data.error);
			} else {
				data.error = undefined;
			}

			return data;
		}

		if (typeof window.addEventListener === 'function') {
			window.addEventListener(
				'message',
				function(e) {
					var data = parseMessage(e.data);

					if (!data) {
						return;
					}

					var uuid = data.uuid;
					/**
					 * NOTE: messages from other contexts (frames) in response
					 * to a message should not contain a topic. We ignore these
					 * messages to prevent rogue postMessage handlers reflecting
					 * our messages.
					 * @see https://github.com/dequelabs/axe-core/issues/1754
					 */

					var axeRespondables = axe._cache.get('axeRespondables') || {};

					if (axeRespondables[uuid] && data.topic && e.source !== window) {
						return;
					}

					var keepalive = data._keepalive;
					var callback = messages[uuid];

					if (callback) {
						var result = data.error || data.message;
						var responder = createResponder(e.source, data.topic, uuid);
						callback(result, keepalive, responder);

						if (!keepalive) {
							delete messages[uuid];
						}
					}

					if (!data.error) {
						try {
							publish(e.source, data, keepalive);
						} catch (err) {
							post(e.source, null, err, uuid, false);
						}
					}
				},
				false
			);
		}

		exports.respondable = respondable;
	})(utils);

	('use strict');

	/**
	 * Check if a rule matches the value of runOnly type=tag
	 * @private
	 * @param  {object} rule
	 * @param  {object}	runOnly Value of runOnly with type=tags
	 * @return {bool}
	 */
	function matchTags(rule, runOnly) {
		'use strict';

		var include, exclude, matching;
		var defaultExclude =
			axe._audit && axe._audit.tagExclude ? axe._audit.tagExclude : []; // normalize include/exclude

		if (
			runOnly.hasOwnProperty('include') ||
			runOnly.hasOwnProperty('exclude')
		) {
			// Wrap include and exclude if it's not already an array
			include = runOnly.include || [];
			include = Array.isArray(include) ? include : [include];
			exclude = runOnly.exclude || [];
			exclude = Array.isArray(exclude) ? exclude : [exclude]; // add defaults, unless mentioned in include

			exclude = exclude.concat(
				defaultExclude.filter(function(tag) {
					return include.indexOf(tag) === -1;
				})
			); // Otherwise, only use the include value, ignore exclude
		} else {
			include = Array.isArray(runOnly) ? runOnly : [runOnly]; // exclude the defaults not included

			exclude = defaultExclude.filter(function(tag) {
				return include.indexOf(tag) === -1;
			});
		}

		matching = include.some(function(tag) {
			return rule.tags.indexOf(tag) !== -1;
		});

		if (matching || (include.length === 0 && rule.enabled !== false)) {
			return exclude.every(function(tag) {
				return rule.tags.indexOf(tag) === -1;
			});
		} else {
			return false;
		}
	}
	/**
	 * Determines whether a rule should run
	 * @param  {Rule}    rule     The rule to test
	 * @param  {Context} context  The context of the Audit
	 * @param  {Object}  options  Options object
	 * @return {Boolean}
	 */

	axe.utils.ruleShouldRun = function(rule, context, options) {
		'use strict';

		var runOnly = options.runOnly || {};
		var ruleOptions = (options.rules || {})[rule.id]; // Never run page level rules if the context is not on the page

		if (rule.pageLevel && !context.page) {
			return false; // First, runOnly type rule overrides anything else
		} else if (runOnly.type === 'rule') {
			return runOnly.values.indexOf(rule.id) !== -1; // Second, if options.rules[rule].enabled is set, it overrides all
		} else if (ruleOptions && typeof ruleOptions.enabled === 'boolean') {
			return ruleOptions.enabled; // Third, if tags are set, look at those
		} else if (runOnly.type === 'tag' && runOnly.values) {
			return matchTags(rule, runOnly.values); // If nothing is set, only check for default excludes
		} else {
			return matchTags(rule, []);
		}
	};

	('use strict');

	/**
	 * set the scroll position of an element
	 */
	function setScroll(elm, top, left) {
		if (elm === window) {
			return elm.scroll(left, top);
		} else {
			elm.scrollTop = top;
			elm.scrollLeft = left;
		}
	}
	/**
	 * Create an array scroll positions from descending elements
	 */

	function getElmScrollRecursive(root) {
		// Need to also get .childNodes since SVGs in IE don't have .children.
		return Array.from(root.children || root.childNodes || []).reduce(function(
			scrolls,
			elm
		) {
			var scroll = axe.utils.getScroll(elm);

			if (scroll) {
				scrolls.push(scroll);
			}

			return scrolls.concat(getElmScrollRecursive(elm));
		},
		[]);
	}
	/**
	 * Get the scroll position of all scrollable elements in a page
	 */

	axe.utils.getScrollState = function getScrollState() {
		var win =
			arguments.length > 0 && arguments[0] !== undefined
				? arguments[0]
				: window;
		var root = win.document.documentElement;
		var windowScroll = [
			win.pageXOffset !== undefined
				? {
						elm: win,
						top: win.pageYOffset,
						left: win.pageXOffset
				  }
				: {
						elm: root,
						top: root.scrollTop,
						left: root.scrollLeft
				  }
		];
		return windowScroll.concat(getElmScrollRecursive(document.body));
	};
	/**
	 * set the scroll position of all items in the scrollState array
	 */

	axe.utils.setScrollState = function setScrollState(scrollState) {
		scrollState.forEach(function(_ref) {
			var elm = _ref.elm,
				top = _ref.top,
				left = _ref.left;
			return setScroll(elm, top, left);
		});
	};

	('use strict');

	/**
	 * Get the deepest node in a given collection
	 * @private
	 * @param  {Array} collection Array of nodes to test
	 * @return {Node}             The deepest node
	 */
	function getDeepest(collection) {
		'use strict';

		return collection.sort(function(a, b) {
			if (axe.utils.contains(a, b)) {
				return 1;
			}

			return -1;
		})[0];
	}
	/**
	 * Determines if a node is included or excluded in a given context
	 * @private
	 * @param  {Node}  node     The node to test
	 * @param  {Object}  context "Resolved" context object, @see resolveContext
	 * @return {Boolean}         [description]
	 */

	function isNodeInContext(node, context) {
		'use strict';

		var include =
			context.include &&
			getDeepest(
				context.include.filter(function(candidate) {
					return axe.utils.contains(candidate, node);
				})
			);
		var exclude =
			context.exclude &&
			getDeepest(
				context.exclude.filter(function(candidate) {
					return axe.utils.contains(candidate, node);
				})
			);

		if (
			(!exclude && include) ||
			(exclude && axe.utils.contains(exclude, include))
		) {
			return true;
		}

		return false;
	}
	/**
	 * Pushes unique nodes that are in context to an array
	 * @private
	 * @param  {Array} result  The array to push to
	 * @param  {Array} nodes   The list of nodes to push
	 * @param  {Object} context The "resolved" context object, @see resolveContext
	 */

	function pushNode(result, nodes) {
		'use strict';

		var temp;

		if (result.length === 0) {
			return nodes;
		}

		if (result.length < nodes.length) {
			// switch so the comparison is shortest
			temp = result;
			result = nodes;
			nodes = temp;
		}

		for (var i = 0, l = nodes.length; i < l; i++) {
			if (!result.includes(nodes[i])) {
				result.push(nodes[i]);
			}
		}

		return result;
	}
	/**
	 * reduces the includes list to only the outermost includes
	 * @param {Array} the array of include nodes
	 * @return {Array} the modified array of nodes
	 */

	function reduceIncludes(includes) {
		return includes.reduce(function(res, el) {
			if (!res.length || !axe.utils.contains(res[res.length - 1], el)) {
				res.push(el);
			}

			return res;
		}, []);
	}
	/**
	 * Selects elements which match `selector` that are included and excluded via the `Context` object
	 * @param  {String} selector  CSS selector of the HTMLElements to select
	 * @param  {Context} context  The "resolved" context object, @see Context
	 * @return {Array}            Matching virtual DOM nodes sorted by DOM order
	 */

	axe.utils.select = function select(selector, context) {
		'use strict';

		var result = [];
		var candidate;

		if (axe._selectCache) {
			// if used outside of run, it will still work
			for (var j = 0, l = axe._selectCache.length; j < l; j++) {
				// First see whether the item exists in the cache
				var item = axe._selectCache[j];

				if (item.selector === selector) {
					return item.result;
				}
			}
		}

		var curried = (function(context) {
			return function(node) {
				return isNodeInContext(node, context);
			};
		})(context);

		var reducedIncludes = reduceIncludes(context.include);

		for (var i = 0; i < reducedIncludes.length; i++) {
			candidate = reducedIncludes[i];
			result = pushNode(
				result,
				axe.utils.querySelectorAllFilter(candidate, selector, curried)
			);
		}

		if (axe._selectCache) {
			axe._selectCache.push({
				selector: selector,
				result: result
			});
		}

		return result;
	};

	('use strict');

	/**
	 * Converts array-like (numerical indicies and `length` property) structures to actual, real arrays
	 * @param	{Mixed} thing Array-like thing to convert
	 * @return {Array}
	 */
	axe.utils.toArray = function(thing) {
		'use strict';

		return Array.prototype.slice.call(thing);
	};
	/**
	 * Creates an array without duplicate values from 2 array inputs
	 * @param	{Array} arr1 First array
	 * @param	{Array} arr2 Second array
	 * @return {Array}
	 */

	axe.utils.uniqueArray = function(arr1, arr2) {
		return arr1.concat(arr2).filter(function(elem, pos, arr) {
			return arr.indexOf(elem) === pos;
		});
	};

	('use strict');

	/**
	 * Converts space delimited token list to an Array
	 * @method tokenList
	 * @memberof axe.utils
	 * @param  {String} str
	 * @return {Array}
	 */
	axe.utils.tokenList = function(str) {
		'use strict';

		return str
			.trim()
			.replace(/\s{2,}/g, ' ')
			.split(' ');
	};

	('use strict');

	/*eslint no-bitwise: 0, eqeqeq: 0, curly: 0, strict: 0, no-eq-null: 0, no-shadow: 0, no-undef: 0 */
	//		 uuid.js
	//
	//		 Copyright (c) 2010-2012 Robert Kieffer
	//		 MIT License - http://opensource.org/licenses/mit-license.php
	var uuid;

	(function(_global) {
		// Unique ID creation requires a high quality random # generator.	We feature
		// detect to determine the best RNG source, normalizing to a function that
		// returns 128-bits of randomness, since that's what's usually required
		var _rng; // Allow for MSIE11 msCrypto

		var _crypto = _global.crypto || _global.msCrypto;

		if (!_rng && _crypto && _crypto.getRandomValues) {
			// WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
			//
			// Moderately fast, high quality
			var _rnds8 = new Uint8Array(16);

			_rng = function whatwgRNG() {
				_crypto.getRandomValues(_rnds8);

				return _rnds8;
			};
		}

		if (!_rng) {
			// Math.random()-based (RNG)
			//
			// If all else fails, use Math.random().	It's fast, but is of unspecified
			// quality.
			var _rnds = new Array(16);

			_rng = function _rng() {
				for (var i = 0, r; i < 16; i++) {
					if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
					_rnds[i] = (r >>> ((i & 0x03) << 3)) & 0xff;
				}

				return _rnds;
			};
		} // Buffer class to use

		var BufferClass =
			typeof _global.Buffer == 'function' ? _global.Buffer : Array; // Maps for number <-> hex string conversion

		var _byteToHex = [];
		var _hexToByte = {};

		for (var i = 0; i < 256; i++) {
			_byteToHex[i] = (i + 0x100).toString(16).substr(1);
			_hexToByte[_byteToHex[i]] = i;
		} // **`parse()` - Parse a UUID into it's component bytes**

		function parse(s, buf, offset) {
			var i = (buf && offset) || 0,
				ii = 0;
			buf = buf || [];
			s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
				if (ii < 16) {
					// Don't overflow!
					buf[i + ii++] = _hexToByte[oct];
				}
			}); // Zero out remaining bytes if string was short

			while (ii < 16) {
				buf[i + ii++] = 0;
			}

			return buf;
		} // **`unparse()` - Convert UUID byte array (ala parse()) into a string**

		function unparse(buf, offset) {
			var i = offset || 0,
				bth = _byteToHex;
			return (
				bth[buf[i++]] +
				bth[buf[i++]] +
				bth[buf[i++]] +
				bth[buf[i++]] +
				'-' +
				bth[buf[i++]] +
				bth[buf[i++]] +
				'-' +
				bth[buf[i++]] +
				bth[buf[i++]] +
				'-' +
				bth[buf[i++]] +
				bth[buf[i++]] +
				'-' +
				bth[buf[i++]] +
				bth[buf[i++]] +
				bth[buf[i++]] +
				bth[buf[i++]] +
				bth[buf[i++]] +
				bth[buf[i++]]
			);
		} // **`v1()` - Generate time-based UUID**
		//
		// Inspired by https://github.com/LiosK/UUID.js
		// and http://docs.python.org/library/uuid.html
		// random #'s we need to init node and clockseq

		var _seedBytes = _rng(); // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)

		var _nodeId = [
			_seedBytes[0] | 0x01,
			_seedBytes[1],
			_seedBytes[2],
			_seedBytes[3],
			_seedBytes[4],
			_seedBytes[5]
		]; // Per 4.2.2, randomize (14 bit) clockseq

		var _clockseq = ((_seedBytes[6] << 8) | _seedBytes[7]) & 0x3fff; // Previous uuid creation time

		var _lastMSecs = 0,
			_lastNSecs = 0; // See https://github.com/broofa/node-uuid for API details

		function v1(options, buf, offset) {
			var i = (buf && offset) || 0;
			var b = buf || [];
			options = options || {};
			var clockseq = options.clockseq != null ? options.clockseq : _clockseq; // UUID timestamps are 100 nano-second units since the Gregorian epoch,
			// (1582-10-15 00:00).	JSNumbers aren't precise enough for this, so
			// time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
			// (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.

			var msecs = options.msecs != null ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock
			// cycle to simulate higher resolution clock

			var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

			var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

			if (dt < 0 && options.clockseq == null) {
				clockseq = (clockseq + 1) & 0x3fff;
			} // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
			// time interval

			if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
				nsecs = 0;
			} // Per 4.2.1.2 Throw error if too many uuids are requested

			if (nsecs >= 10000) {
				throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
			}

			_lastMSecs = msecs;
			_lastNSecs = nsecs;
			_clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

			msecs += 12219292800000; // `time_low`

			var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
			b[i++] = (tl >>> 24) & 0xff;
			b[i++] = (tl >>> 16) & 0xff;
			b[i++] = (tl >>> 8) & 0xff;
			b[i++] = tl & 0xff; // `time_mid`

			var tmh = ((msecs / 0x100000000) * 10000) & 0xfffffff;
			b[i++] = (tmh >>> 8) & 0xff;
			b[i++] = tmh & 0xff; // `time_high_and_version`

			b[i++] = ((tmh >>> 24) & 0xf) | 0x10; // include version

			b[i++] = (tmh >>> 16) & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

			b[i++] = (clockseq >>> 8) | 0x80; // `clock_seq_low`

			b[i++] = clockseq & 0xff; // `node`

			var node = options.node || _nodeId;

			for (var n = 0; n < 6; n++) {
				b[i + n] = node[n];
			}

			return buf ? buf : unparse(b);
		} // **`v4()` - Generate random UUID**
		// See https://github.com/broofa/node-uuid for API details

		function v4(options, buf, offset) {
			// Deprecated - 'format' argument, as supported in v1.2
			var i = (buf && offset) || 0;

			if (typeof options == 'string') {
				buf = options == 'binary' ? new BufferClass(16) : null;
				options = null;
			}

			options = options || {};

			var rnds = options.random || (options.rng || _rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

			rnds[6] = (rnds[6] & 0x0f) | 0x40;
			rnds[8] = (rnds[8] & 0x3f) | 0x80; // Copy bytes to buffer, if provided

			if (buf) {
				for (var ii = 0; ii < 16; ii++) {
					buf[i + ii] = rnds[ii];
				}
			}

			return buf || unparse(rnds);
		} // Export public API

		uuid = v4;
		uuid.v1 = v1;
		uuid.v4 = v4;
		uuid.parse = parse;
		uuid.unparse = unparse;
		uuid.BufferClass = BufferClass;
	})(window);

	('use strict');

	/**
	 * Returns array of valid input type values
	 * @method validInputTypes
	 * @memberof axe.utils
	 * @return {Array<Sting>}
	 */
	axe.utils.validInputTypes = function validInputTypes() {
		'use strict'; // Reference - https://html.spec.whatwg.org/multipage/input.html#the-input-element

		return [
			'hidden',
			'text',
			'search',
			'tel',
			'url',
			'email',
			'password',
			'date',
			'month',
			'week',
			'time',
			'datetime-local',
			'number',
			'range',
			'color',
			'checkbox',
			'radio',
			'file',
			'submit',
			'image',
			'reset',
			'button'
		];
	};

	('use strict');

	/*eslint quotes: 0*/
	var langs = [
		'aa',
		'ab',
		'ae',
		'af',
		'ak',
		'am',
		'an',
		'ar',
		'as',
		'av',
		'ay',
		'az',
		'ba',
		'be',
		'bg',
		'bh',
		'bi',
		'bm',
		'bn',
		'bo',
		'br',
		'bs',
		'ca',
		'ce',
		'ch',
		'co',
		'cr',
		'cs',
		'cu',
		'cv',
		'cy',
		'da',
		'de',
		'dv',
		'dz',
		'ee',
		'el',
		'en',
		'eo',
		'es',
		'et',
		'eu',
		'fa',
		'ff',
		'fi',
		'fj',
		'fo',
		'fr',
		'fy',
		'ga',
		'gd',
		'gl',
		'gn',
		'gu',
		'gv',
		'ha',
		'he',
		'hi',
		'ho',
		'hr',
		'ht',
		'hu',
		'hy',
		'hz',
		'ia',
		'id',
		'ie',
		'ig',
		'ii',
		'ik',
		'in',
		'io',
		'is',
		'it',
		'iu',
		'iw',
		'ja',
		'ji',
		'jv',
		'jw',
		'ka',
		'kg',
		'ki',
		'kj',
		'kk',
		'kl',
		'km',
		'kn',
		'ko',
		'kr',
		'ks',
		'ku',
		'kv',
		'kw',
		'ky',
		'la',
		'lb',
		'lg',
		'li',
		'ln',
		'lo',
		'lt',
		'lu',
		'lv',
		'mg',
		'mh',
		'mi',
		'mk',
		'ml',
		'mn',
		'mo',
		'mr',
		'ms',
		'mt',
		'my',
		'na',
		'nb',
		'nd',
		'ne',
		'ng',
		'nl',
		'nn',
		'no',
		'nr',
		'nv',
		'ny',
		'oc',
		'oj',
		'om',
		'or',
		'os',
		'pa',
		'pi',
		'pl',
		'ps',
		'pt',
		'qu',
		'rm',
		'rn',
		'ro',
		'ru',
		'rw',
		'sa',
		'sc',
		'sd',
		'se',
		'sg',
		'sh',
		'si',
		'sk',
		'sl',
		'sm',
		'sn',
		'so',
		'sq',
		'sr',
		'ss',
		'st',
		'su',
		'sv',
		'sw',
		'ta',
		'te',
		'tg',
		'th',
		'ti',
		'tk',
		'tl',
		'tn',
		'to',
		'tr',
		'ts',
		'tt',
		'tw',
		'ty',
		'ug',
		'uk',
		'ur',
		'uz',
		've',
		'vi',
		'vo',
		'wa',
		'wo',
		'xh',
		'yi',
		'yo',
		'za',
		'zh',
		'zu',
		'aaa',
		'aab',
		'aac',
		'aad',
		'aae',
		'aaf',
		'aag',
		'aah',
		'aai',
		'aak',
		'aal',
		'aam',
		'aan',
		'aao',
		'aap',
		'aaq',
		'aas',
		'aat',
		'aau',
		'aav',
		'aaw',
		'aax',
		'aaz',
		'aba',
		'abb',
		'abc',
		'abd',
		'abe',
		'abf',
		'abg',
		'abh',
		'abi',
		'abj',
		'abl',
		'abm',
		'abn',
		'abo',
		'abp',
		'abq',
		'abr',
		'abs',
		'abt',
		'abu',
		'abv',
		'abw',
		'abx',
		'aby',
		'abz',
		'aca',
		'acb',
		'acd',
		'ace',
		'acf',
		'ach',
		'aci',
		'ack',
		'acl',
		'acm',
		'acn',
		'acp',
		'acq',
		'acr',
		'acs',
		'act',
		'acu',
		'acv',
		'acw',
		'acx',
		'acy',
		'acz',
		'ada',
		'adb',
		'add',
		'ade',
		'adf',
		'adg',
		'adh',
		'adi',
		'adj',
		'adl',
		'adn',
		'ado',
		'adp',
		'adq',
		'adr',
		'ads',
		'adt',
		'adu',
		'adw',
		'adx',
		'ady',
		'adz',
		'aea',
		'aeb',
		'aec',
		'aed',
		'aee',
		'aek',
		'ael',
		'aem',
		'aen',
		'aeq',
		'aer',
		'aes',
		'aeu',
		'aew',
		'aey',
		'aez',
		'afa',
		'afb',
		'afd',
		'afe',
		'afg',
		'afh',
		'afi',
		'afk',
		'afn',
		'afo',
		'afp',
		'afs',
		'aft',
		'afu',
		'afz',
		'aga',
		'agb',
		'agc',
		'agd',
		'age',
		'agf',
		'agg',
		'agh',
		'agi',
		'agj',
		'agk',
		'agl',
		'agm',
		'agn',
		'ago',
		'agp',
		'agq',
		'agr',
		'ags',
		'agt',
		'agu',
		'agv',
		'agw',
		'agx',
		'agy',
		'agz',
		'aha',
		'ahb',
		'ahg',
		'ahh',
		'ahi',
		'ahk',
		'ahl',
		'ahm',
		'ahn',
		'aho',
		'ahp',
		'ahr',
		'ahs',
		'aht',
		'aia',
		'aib',
		'aic',
		'aid',
		'aie',
		'aif',
		'aig',
		'aih',
		'aii',
		'aij',
		'aik',
		'ail',
		'aim',
		'ain',
		'aio',
		'aip',
		'aiq',
		'air',
		'ais',
		'ait',
		'aiw',
		'aix',
		'aiy',
		'aja',
		'ajg',
		'aji',
		'ajn',
		'ajp',
		'ajt',
		'aju',
		'ajw',
		'ajz',
		'akb',
		'akc',
		'akd',
		'ake',
		'akf',
		'akg',
		'akh',
		'aki',
		'akj',
		'akk',
		'akl',
		'akm',
		'ako',
		'akp',
		'akq',
		'akr',
		'aks',
		'akt',
		'aku',
		'akv',
		'akw',
		'akx',
		'aky',
		'akz',
		'ala',
		'alc',
		'ald',
		'ale',
		'alf',
		'alg',
		'alh',
		'ali',
		'alj',
		'alk',
		'all',
		'alm',
		'aln',
		'alo',
		'alp',
		'alq',
		'alr',
		'als',
		'alt',
		'alu',
		'alv',
		'alw',
		'alx',
		'aly',
		'alz',
		'ama',
		'amb',
		'amc',
		'ame',
		'amf',
		'amg',
		'ami',
		'amj',
		'amk',
		'aml',
		'amm',
		'amn',
		'amo',
		'amp',
		'amq',
		'amr',
		'ams',
		'amt',
		'amu',
		'amv',
		'amw',
		'amx',
		'amy',
		'amz',
		'ana',
		'anb',
		'anc',
		'and',
		'ane',
		'anf',
		'ang',
		'anh',
		'ani',
		'anj',
		'ank',
		'anl',
		'anm',
		'ann',
		'ano',
		'anp',
		'anq',
		'anr',
		'ans',
		'ant',
		'anu',
		'anv',
		'anw',
		'anx',
		'any',
		'anz',
		'aoa',
		'aob',
		'aoc',
		'aod',
		'aoe',
		'aof',
		'aog',
		'aoh',
		'aoi',
		'aoj',
		'aok',
		'aol',
		'aom',
		'aon',
		'aor',
		'aos',
		'aot',
		'aou',
		'aox',
		'aoz',
		'apa',
		'apb',
		'apc',
		'apd',
		'ape',
		'apf',
		'apg',
		'aph',
		'api',
		'apj',
		'apk',
		'apl',
		'apm',
		'apn',
		'apo',
		'app',
		'apq',
		'apr',
		'aps',
		'apt',
		'apu',
		'apv',
		'apw',
		'apx',
		'apy',
		'apz',
		'aqa',
		'aqc',
		'aqd',
		'aqg',
		'aql',
		'aqm',
		'aqn',
		'aqp',
		'aqr',
		'aqt',
		'aqz',
		'arb',
		'arc',
		'ard',
		'are',
		'arh',
		'ari',
		'arj',
		'ark',
		'arl',
		'arn',
		'aro',
		'arp',
		'arq',
		'arr',
		'ars',
		'art',
		'aru',
		'arv',
		'arw',
		'arx',
		'ary',
		'arz',
		'asa',
		'asb',
		'asc',
		'asd',
		'ase',
		'asf',
		'asg',
		'ash',
		'asi',
		'asj',
		'ask',
		'asl',
		'asn',
		'aso',
		'asp',
		'asq',
		'asr',
		'ass',
		'ast',
		'asu',
		'asv',
		'asw',
		'asx',
		'asy',
		'asz',
		'ata',
		'atb',
		'atc',
		'atd',
		'ate',
		'atg',
		'ath',
		'ati',
		'atj',
		'atk',
		'atl',
		'atm',
		'atn',
		'ato',
		'atp',
		'atq',
		'atr',
		'ats',
		'att',
		'atu',
		'atv',
		'atw',
		'atx',
		'aty',
		'atz',
		'aua',
		'aub',
		'auc',
		'aud',
		'aue',
		'auf',
		'aug',
		'auh',
		'aui',
		'auj',
		'auk',
		'aul',
		'aum',
		'aun',
		'auo',
		'aup',
		'auq',
		'aur',
		'aus',
		'aut',
		'auu',
		'auw',
		'aux',
		'auy',
		'auz',
		'avb',
		'avd',
		'avi',
		'avk',
		'avl',
		'avm',
		'avn',
		'avo',
		'avs',
		'avt',
		'avu',
		'avv',
		'awa',
		'awb',
		'awc',
		'awd',
		'awe',
		'awg',
		'awh',
		'awi',
		'awk',
		'awm',
		'awn',
		'awo',
		'awr',
		'aws',
		'awt',
		'awu',
		'awv',
		'aww',
		'awx',
		'awy',
		'axb',
		'axe',
		'axg',
		'axk',
		'axl',
		'axm',
		'axx',
		'aya',
		'ayb',
		'ayc',
		'ayd',
		'aye',
		'ayg',
		'ayh',
		'ayi',
		'ayk',
		'ayl',
		'ayn',
		'ayo',
		'ayp',
		'ayq',
		'ayr',
		'ays',
		'ayt',
		'ayu',
		'ayx',
		'ayy',
		'ayz',
		'aza',
		'azb',
		'azc',
		'azd',
		'azg',
		'azj',
		'azm',
		'azn',
		'azo',
		'azt',
		'azz',
		'baa',
		'bab',
		'bac',
		'bad',
		'bae',
		'baf',
		'bag',
		'bah',
		'bai',
		'baj',
		'bal',
		'ban',
		'bao',
		'bap',
		'bar',
		'bas',
		'bat',
		'bau',
		'bav',
		'baw',
		'bax',
		'bay',
		'baz',
		'bba',
		'bbb',
		'bbc',
		'bbd',
		'bbe',
		'bbf',
		'bbg',
		'bbh',
		'bbi',
		'bbj',
		'bbk',
		'bbl',
		'bbm',
		'bbn',
		'bbo',
		'bbp',
		'bbq',
		'bbr',
		'bbs',
		'bbt',
		'bbu',
		'bbv',
		'bbw',
		'bbx',
		'bby',
		'bbz',
		'bca',
		'bcb',
		'bcc',
		'bcd',
		'bce',
		'bcf',
		'bcg',
		'bch',
		'bci',
		'bcj',
		'bck',
		'bcl',
		'bcm',
		'bcn',
		'bco',
		'bcp',
		'bcq',
		'bcr',
		'bcs',
		'bct',
		'bcu',
		'bcv',
		'bcw',
		'bcy',
		'bcz',
		'bda',
		'bdb',
		'bdc',
		'bdd',
		'bde',
		'bdf',
		'bdg',
		'bdh',
		'bdi',
		'bdj',
		'bdk',
		'bdl',
		'bdm',
		'bdn',
		'bdo',
		'bdp',
		'bdq',
		'bdr',
		'bds',
		'bdt',
		'bdu',
		'bdv',
		'bdw',
		'bdx',
		'bdy',
		'bdz',
		'bea',
		'beb',
		'bec',
		'bed',
		'bee',
		'bef',
		'beg',
		'beh',
		'bei',
		'bej',
		'bek',
		'bem',
		'beo',
		'bep',
		'beq',
		'ber',
		'bes',
		'bet',
		'beu',
		'bev',
		'bew',
		'bex',
		'bey',
		'bez',
		'bfa',
		'bfb',
		'bfc',
		'bfd',
		'bfe',
		'bff',
		'bfg',
		'bfh',
		'bfi',
		'bfj',
		'bfk',
		'bfl',
		'bfm',
		'bfn',
		'bfo',
		'bfp',
		'bfq',
		'bfr',
		'bfs',
		'bft',
		'bfu',
		'bfw',
		'bfx',
		'bfy',
		'bfz',
		'bga',
		'bgb',
		'bgc',
		'bgd',
		'bge',
		'bgf',
		'bgg',
		'bgi',
		'bgj',
		'bgk',
		'bgl',
		'bgm',
		'bgn',
		'bgo',
		'bgp',
		'bgq',
		'bgr',
		'bgs',
		'bgt',
		'bgu',
		'bgv',
		'bgw',
		'bgx',
		'bgy',
		'bgz',
		'bha',
		'bhb',
		'bhc',
		'bhd',
		'bhe',
		'bhf',
		'bhg',
		'bhh',
		'bhi',
		'bhj',
		'bhk',
		'bhl',
		'bhm',
		'bhn',
		'bho',
		'bhp',
		'bhq',
		'bhr',
		'bhs',
		'bht',
		'bhu',
		'bhv',
		'bhw',
		'bhx',
		'bhy',
		'bhz',
		'bia',
		'bib',
		'bic',
		'bid',
		'bie',
		'bif',
		'big',
		'bij',
		'bik',
		'bil',
		'bim',
		'bin',
		'bio',
		'bip',
		'biq',
		'bir',
		'bit',
		'biu',
		'biv',
		'biw',
		'bix',
		'biy',
		'biz',
		'bja',
		'bjb',
		'bjc',
		'bjd',
		'bje',
		'bjf',
		'bjg',
		'bjh',
		'bji',
		'bjj',
		'bjk',
		'bjl',
		'bjm',
		'bjn',
		'bjo',
		'bjp',
		'bjq',
		'bjr',
		'bjs',
		'bjt',
		'bju',
		'bjv',
		'bjw',
		'bjx',
		'bjy',
		'bjz',
		'bka',
		'bkb',
		'bkc',
		'bkd',
		'bkf',
		'bkg',
		'bkh',
		'bki',
		'bkj',
		'bkk',
		'bkl',
		'bkm',
		'bkn',
		'bko',
		'bkp',
		'bkq',
		'bkr',
		'bks',
		'bkt',
		'bku',
		'bkv',
		'bkw',
		'bkx',
		'bky',
		'bkz',
		'bla',
		'blb',
		'blc',
		'bld',
		'ble',
		'blf',
		'blg',
		'blh',
		'bli',
		'blj',
		'blk',
		'bll',
		'blm',
		'bln',
		'blo',
		'blp',
		'blq',
		'blr',
		'bls',
		'blt',
		'blv',
		'blw',
		'blx',
		'bly',
		'blz',
		'bma',
		'bmb',
		'bmc',
		'bmd',
		'bme',
		'bmf',
		'bmg',
		'bmh',
		'bmi',
		'bmj',
		'bmk',
		'bml',
		'bmm',
		'bmn',
		'bmo',
		'bmp',
		'bmq',
		'bmr',
		'bms',
		'bmt',
		'bmu',
		'bmv',
		'bmw',
		'bmx',
		'bmy',
		'bmz',
		'bna',
		'bnb',
		'bnc',
		'bnd',
		'bne',
		'bnf',
		'bng',
		'bni',
		'bnj',
		'bnk',
		'bnl',
		'bnm',
		'bnn',
		'bno',
		'bnp',
		'bnq',
		'bnr',
		'bns',
		'bnt',
		'bnu',
		'bnv',
		'bnw',
		'bnx',
		'bny',
		'bnz',
		'boa',
		'bob',
		'boe',
		'bof',
		'bog',
		'boh',
		'boi',
		'boj',
		'bok',
		'bol',
		'bom',
		'bon',
		'boo',
		'bop',
		'boq',
		'bor',
		'bot',
		'bou',
		'bov',
		'bow',
		'box',
		'boy',
		'boz',
		'bpa',
		'bpb',
		'bpd',
		'bpg',
		'bph',
		'bpi',
		'bpj',
		'bpk',
		'bpl',
		'bpm',
		'bpn',
		'bpo',
		'bpp',
		'bpq',
		'bpr',
		'bps',
		'bpt',
		'bpu',
		'bpv',
		'bpw',
		'bpx',
		'bpy',
		'bpz',
		'bqa',
		'bqb',
		'bqc',
		'bqd',
		'bqf',
		'bqg',
		'bqh',
		'bqi',
		'bqj',
		'bqk',
		'bql',
		'bqm',
		'bqn',
		'bqo',
		'bqp',
		'bqq',
		'bqr',
		'bqs',
		'bqt',
		'bqu',
		'bqv',
		'bqw',
		'bqx',
		'bqy',
		'bqz',
		'bra',
		'brb',
		'brc',
		'brd',
		'brf',
		'brg',
		'brh',
		'bri',
		'brj',
		'brk',
		'brl',
		'brm',
		'brn',
		'bro',
		'brp',
		'brq',
		'brr',
		'brs',
		'brt',
		'bru',
		'brv',
		'brw',
		'brx',
		'bry',
		'brz',
		'bsa',
		'bsb',
		'bsc',
		'bse',
		'bsf',
		'bsg',
		'bsh',
		'bsi',
		'bsj',
		'bsk',
		'bsl',
		'bsm',
		'bsn',
		'bso',
		'bsp',
		'bsq',
		'bsr',
		'bss',
		'bst',
		'bsu',
		'bsv',
		'bsw',
		'bsx',
		'bsy',
		'bta',
		'btb',
		'btc',
		'btd',
		'bte',
		'btf',
		'btg',
		'bth',
		'bti',
		'btj',
		'btk',
		'btl',
		'btm',
		'btn',
		'bto',
		'btp',
		'btq',
		'btr',
		'bts',
		'btt',
		'btu',
		'btv',
		'btw',
		'btx',
		'bty',
		'btz',
		'bua',
		'bub',
		'buc',
		'bud',
		'bue',
		'buf',
		'bug',
		'buh',
		'bui',
		'buj',
		'buk',
		'bum',
		'bun',
		'buo',
		'bup',
		'buq',
		'bus',
		'but',
		'buu',
		'buv',
		'buw',
		'bux',
		'buy',
		'buz',
		'bva',
		'bvb',
		'bvc',
		'bvd',
		'bve',
		'bvf',
		'bvg',
		'bvh',
		'bvi',
		'bvj',
		'bvk',
		'bvl',
		'bvm',
		'bvn',
		'bvo',
		'bvp',
		'bvq',
		'bvr',
		'bvt',
		'bvu',
		'bvv',
		'bvw',
		'bvx',
		'bvy',
		'bvz',
		'bwa',
		'bwb',
		'bwc',
		'bwd',
		'bwe',
		'bwf',
		'bwg',
		'bwh',
		'bwi',
		'bwj',
		'bwk',
		'bwl',
		'bwm',
		'bwn',
		'bwo',
		'bwp',
		'bwq',
		'bwr',
		'bws',
		'bwt',
		'bwu',
		'bww',
		'bwx',
		'bwy',
		'bwz',
		'bxa',
		'bxb',
		'bxc',
		'bxd',
		'bxe',
		'bxf',
		'bxg',
		'bxh',
		'bxi',
		'bxj',
		'bxk',
		'bxl',
		'bxm',
		'bxn',
		'bxo',
		'bxp',
		'bxq',
		'bxr',
		'bxs',
		'bxu',
		'bxv',
		'bxw',
		'bxx',
		'bxz',
		'bya',
		'byb',
		'byc',
		'byd',
		'bye',
		'byf',
		'byg',
		'byh',
		'byi',
		'byj',
		'byk',
		'byl',
		'bym',
		'byn',
		'byo',
		'byp',
		'byq',
		'byr',
		'bys',
		'byt',
		'byv',
		'byw',
		'byx',
		'byy',
		'byz',
		'bza',
		'bzb',
		'bzc',
		'bzd',
		'bze',
		'bzf',
		'bzg',
		'bzh',
		'bzi',
		'bzj',
		'bzk',
		'bzl',
		'bzm',
		'bzn',
		'bzo',
		'bzp',
		'bzq',
		'bzr',
		'bzs',
		'bzt',
		'bzu',
		'bzv',
		'bzw',
		'bzx',
		'bzy',
		'bzz',
		'caa',
		'cab',
		'cac',
		'cad',
		'cae',
		'caf',
		'cag',
		'cah',
		'cai',
		'caj',
		'cak',
		'cal',
		'cam',
		'can',
		'cao',
		'cap',
		'caq',
		'car',
		'cas',
		'cau',
		'cav',
		'caw',
		'cax',
		'cay',
		'caz',
		'cba',
		'cbb',
		'cbc',
		'cbd',
		'cbe',
		'cbg',
		'cbh',
		'cbi',
		'cbj',
		'cbk',
		'cbl',
		'cbn',
		'cbo',
		'cbq',
		'cbr',
		'cbs',
		'cbt',
		'cbu',
		'cbv',
		'cbw',
		'cby',
		'cca',
		'ccc',
		'ccd',
		'cce',
		'ccg',
		'cch',
		'ccj',
		'ccl',
		'ccm',
		'ccn',
		'cco',
		'ccp',
		'ccq',
		'ccr',
		'ccs',
		'cda',
		'cdc',
		'cdd',
		'cde',
		'cdf',
		'cdg',
		'cdh',
		'cdi',
		'cdj',
		'cdm',
		'cdn',
		'cdo',
		'cdr',
		'cds',
		'cdy',
		'cdz',
		'cea',
		'ceb',
		'ceg',
		'cek',
		'cel',
		'cen',
		'cet',
		'cfa',
		'cfd',
		'cfg',
		'cfm',
		'cga',
		'cgc',
		'cgg',
		'cgk',
		'chb',
		'chc',
		'chd',
		'chf',
		'chg',
		'chh',
		'chj',
		'chk',
		'chl',
		'chm',
		'chn',
		'cho',
		'chp',
		'chq',
		'chr',
		'cht',
		'chw',
		'chx',
		'chy',
		'chz',
		'cia',
		'cib',
		'cic',
		'cid',
		'cie',
		'cih',
		'cik',
		'cim',
		'cin',
		'cip',
		'cir',
		'ciw',
		'ciy',
		'cja',
		'cje',
		'cjh',
		'cji',
		'cjk',
		'cjm',
		'cjn',
		'cjo',
		'cjp',
		'cjr',
		'cjs',
		'cjv',
		'cjy',
		'cka',
		'ckb',
		'ckh',
		'ckl',
		'ckn',
		'cko',
		'ckq',
		'ckr',
		'cks',
		'ckt',
		'cku',
		'ckv',
		'ckx',
		'cky',
		'ckz',
		'cla',
		'clc',
		'cld',
		'cle',
		'clh',
		'cli',
		'clj',
		'clk',
		'cll',
		'clm',
		'clo',
		'clt',
		'clu',
		'clw',
		'cly',
		'cma',
		'cmc',
		'cme',
		'cmg',
		'cmi',
		'cmk',
		'cml',
		'cmm',
		'cmn',
		'cmo',
		'cmr',
		'cms',
		'cmt',
		'cna',
		'cnb',
		'cnc',
		'cng',
		'cnh',
		'cni',
		'cnk',
		'cnl',
		'cno',
		'cnr',
		'cns',
		'cnt',
		'cnu',
		'cnw',
		'cnx',
		'coa',
		'cob',
		'coc',
		'cod',
		'coe',
		'cof',
		'cog',
		'coh',
		'coj',
		'cok',
		'col',
		'com',
		'con',
		'coo',
		'cop',
		'coq',
		'cot',
		'cou',
		'cov',
		'cow',
		'cox',
		'coy',
		'coz',
		'cpa',
		'cpb',
		'cpc',
		'cpe',
		'cpf',
		'cpg',
		'cpi',
		'cpn',
		'cpo',
		'cpp',
		'cps',
		'cpu',
		'cpx',
		'cpy',
		'cqd',
		'cqu',
		'cra',
		'crb',
		'crc',
		'crd',
		'crf',
		'crg',
		'crh',
		'cri',
		'crj',
		'crk',
		'crl',
		'crm',
		'crn',
		'cro',
		'crp',
		'crq',
		'crr',
		'crs',
		'crt',
		'crv',
		'crw',
		'crx',
		'cry',
		'crz',
		'csa',
		'csb',
		'csc',
		'csd',
		'cse',
		'csf',
		'csg',
		'csh',
		'csi',
		'csj',
		'csk',
		'csl',
		'csm',
		'csn',
		'cso',
		'csq',
		'csr',
		'css',
		'cst',
		'csu',
		'csv',
		'csw',
		'csy',
		'csz',
		'cta',
		'ctc',
		'ctd',
		'cte',
		'ctg',
		'cth',
		'ctl',
		'ctm',
		'ctn',
		'cto',
		'ctp',
		'cts',
		'ctt',
		'ctu',
		'ctz',
		'cua',
		'cub',
		'cuc',
		'cug',
		'cuh',
		'cui',
		'cuj',
		'cuk',
		'cul',
		'cum',
		'cuo',
		'cup',
		'cuq',
		'cur',
		'cus',
		'cut',
		'cuu',
		'cuv',
		'cuw',
		'cux',
		'cuy',
		'cvg',
		'cvn',
		'cwa',
		'cwb',
		'cwd',
		'cwe',
		'cwg',
		'cwt',
		'cya',
		'cyb',
		'cyo',
		'czh',
		'czk',
		'czn',
		'czo',
		'czt',
		'daa',
		'dac',
		'dad',
		'dae',
		'daf',
		'dag',
		'dah',
		'dai',
		'daj',
		'dak',
		'dal',
		'dam',
		'dao',
		'dap',
		'daq',
		'dar',
		'das',
		'dau',
		'dav',
		'daw',
		'dax',
		'day',
		'daz',
		'dba',
		'dbb',
		'dbd',
		'dbe',
		'dbf',
		'dbg',
		'dbi',
		'dbj',
		'dbl',
		'dbm',
		'dbn',
		'dbo',
		'dbp',
		'dbq',
		'dbr',
		'dbt',
		'dbu',
		'dbv',
		'dbw',
		'dby',
		'dcc',
		'dcr',
		'dda',
		'ddd',
		'dde',
		'ddg',
		'ddi',
		'ddj',
		'ddn',
		'ddo',
		'ddr',
		'dds',
		'ddw',
		'dec',
		'ded',
		'dee',
		'def',
		'deg',
		'deh',
		'dei',
		'dek',
		'del',
		'dem',
		'den',
		'dep',
		'deq',
		'der',
		'des',
		'dev',
		'dez',
		'dga',
		'dgb',
		'dgc',
		'dgd',
		'dge',
		'dgg',
		'dgh',
		'dgi',
		'dgk',
		'dgl',
		'dgn',
		'dgo',
		'dgr',
		'dgs',
		'dgt',
		'dgu',
		'dgw',
		'dgx',
		'dgz',
		'dha',
		'dhd',
		'dhg',
		'dhi',
		'dhl',
		'dhm',
		'dhn',
		'dho',
		'dhr',
		'dhs',
		'dhu',
		'dhv',
		'dhw',
		'dhx',
		'dia',
		'dib',
		'dic',
		'did',
		'dif',
		'dig',
		'dih',
		'dii',
		'dij',
		'dik',
		'dil',
		'dim',
		'din',
		'dio',
		'dip',
		'diq',
		'dir',
		'dis',
		'dit',
		'diu',
		'diw',
		'dix',
		'diy',
		'diz',
		'dja',
		'djb',
		'djc',
		'djd',
		'dje',
		'djf',
		'dji',
		'djj',
		'djk',
		'djl',
		'djm',
		'djn',
		'djo',
		'djr',
		'dju',
		'djw',
		'dka',
		'dkk',
		'dkl',
		'dkr',
		'dks',
		'dkx',
		'dlg',
		'dlk',
		'dlm',
		'dln',
		'dma',
		'dmb',
		'dmc',
		'dmd',
		'dme',
		'dmg',
		'dmk',
		'dml',
		'dmm',
		'dmn',
		'dmo',
		'dmr',
		'dms',
		'dmu',
		'dmv',
		'dmw',
		'dmx',
		'dmy',
		'dna',
		'dnd',
		'dne',
		'dng',
		'dni',
		'dnj',
		'dnk',
		'dnn',
		'dnr',
		'dnt',
		'dnu',
		'dnv',
		'dnw',
		'dny',
		'doa',
		'dob',
		'doc',
		'doe',
		'dof',
		'doh',
		'doi',
		'dok',
		'dol',
		'don',
		'doo',
		'dop',
		'doq',
		'dor',
		'dos',
		'dot',
		'dov',
		'dow',
		'dox',
		'doy',
		'doz',
		'dpp',
		'dra',
		'drb',
		'drc',
		'drd',
		'dre',
		'drg',
		'drh',
		'dri',
		'drl',
		'drn',
		'dro',
		'drq',
		'drr',
		'drs',
		'drt',
		'dru',
		'drw',
		'dry',
		'dsb',
		'dse',
		'dsh',
		'dsi',
		'dsl',
		'dsn',
		'dso',
		'dsq',
		'dta',
		'dtb',
		'dtd',
		'dth',
		'dti',
		'dtk',
		'dtm',
		'dtn',
		'dto',
		'dtp',
		'dtr',
		'dts',
		'dtt',
		'dtu',
		'dty',
		'dua',
		'dub',
		'duc',
		'dud',
		'due',
		'duf',
		'dug',
		'duh',
		'dui',
		'duj',
		'duk',
		'dul',
		'dum',
		'dun',
		'duo',
		'dup',
		'duq',
		'dur',
		'dus',
		'duu',
		'duv',
		'duw',
		'dux',
		'duy',
		'duz',
		'dva',
		'dwa',
		'dwl',
		'dwr',
		'dws',
		'dwu',
		'dww',
		'dwy',
		'dya',
		'dyb',
		'dyd',
		'dyg',
		'dyi',
		'dym',
		'dyn',
		'dyo',
		'dyu',
		'dyy',
		'dza',
		'dzd',
		'dze',
		'dzg',
		'dzl',
		'dzn',
		'eaa',
		'ebg',
		'ebk',
		'ebo',
		'ebr',
		'ebu',
		'ecr',
		'ecs',
		'ecy',
		'eee',
		'efa',
		'efe',
		'efi',
		'ega',
		'egl',
		'ego',
		'egx',
		'egy',
		'ehu',
		'eip',
		'eit',
		'eiv',
		'eja',
		'eka',
		'ekc',
		'eke',
		'ekg',
		'eki',
		'ekk',
		'ekl',
		'ekm',
		'eko',
		'ekp',
		'ekr',
		'eky',
		'ele',
		'elh',
		'eli',
		'elk',
		'elm',
		'elo',
		'elp',
		'elu',
		'elx',
		'ema',
		'emb',
		'eme',
		'emg',
		'emi',
		'emk',
		'emm',
		'emn',
		'emo',
		'emp',
		'ems',
		'emu',
		'emw',
		'emx',
		'emy',
		'ena',
		'enb',
		'enc',
		'end',
		'enf',
		'enh',
		'enl',
		'enm',
		'enn',
		'eno',
		'enq',
		'enr',
		'enu',
		'env',
		'enw',
		'enx',
		'eot',
		'epi',
		'era',
		'erg',
		'erh',
		'eri',
		'erk',
		'ero',
		'err',
		'ers',
		'ert',
		'erw',
		'ese',
		'esg',
		'esh',
		'esi',
		'esk',
		'esl',
		'esm',
		'esn',
		'eso',
		'esq',
		'ess',
		'esu',
		'esx',
		'esy',
		'etb',
		'etc',
		'eth',
		'etn',
		'eto',
		'etr',
		'ets',
		'ett',
		'etu',
		'etx',
		'etz',
		'euq',
		'eve',
		'evh',
		'evn',
		'ewo',
		'ext',
		'eya',
		'eyo',
		'eza',
		'eze',
		'faa',
		'fab',
		'fad',
		'faf',
		'fag',
		'fah',
		'fai',
		'faj',
		'fak',
		'fal',
		'fam',
		'fan',
		'fap',
		'far',
		'fat',
		'fau',
		'fax',
		'fay',
		'faz',
		'fbl',
		'fcs',
		'fer',
		'ffi',
		'ffm',
		'fgr',
		'fia',
		'fie',
		'fil',
		'fip',
		'fir',
		'fit',
		'fiu',
		'fiw',
		'fkk',
		'fkv',
		'fla',
		'flh',
		'fli',
		'fll',
		'fln',
		'flr',
		'fly',
		'fmp',
		'fmu',
		'fnb',
		'fng',
		'fni',
		'fod',
		'foi',
		'fom',
		'fon',
		'for',
		'fos',
		'fox',
		'fpe',
		'fqs',
		'frc',
		'frd',
		'frk',
		'frm',
		'fro',
		'frp',
		'frq',
		'frr',
		'frs',
		'frt',
		'fse',
		'fsl',
		'fss',
		'fub',
		'fuc',
		'fud',
		'fue',
		'fuf',
		'fuh',
		'fui',
		'fuj',
		'fum',
		'fun',
		'fuq',
		'fur',
		'fut',
		'fuu',
		'fuv',
		'fuy',
		'fvr',
		'fwa',
		'fwe',
		'gaa',
		'gab',
		'gac',
		'gad',
		'gae',
		'gaf',
		'gag',
		'gah',
		'gai',
		'gaj',
		'gak',
		'gal',
		'gam',
		'gan',
		'gao',
		'gap',
		'gaq',
		'gar',
		'gas',
		'gat',
		'gau',
		'gav',
		'gaw',
		'gax',
		'gay',
		'gaz',
		'gba',
		'gbb',
		'gbc',
		'gbd',
		'gbe',
		'gbf',
		'gbg',
		'gbh',
		'gbi',
		'gbj',
		'gbk',
		'gbl',
		'gbm',
		'gbn',
		'gbo',
		'gbp',
		'gbq',
		'gbr',
		'gbs',
		'gbu',
		'gbv',
		'gbw',
		'gbx',
		'gby',
		'gbz',
		'gcc',
		'gcd',
		'gce',
		'gcf',
		'gcl',
		'gcn',
		'gcr',
		'gct',
		'gda',
		'gdb',
		'gdc',
		'gdd',
		'gde',
		'gdf',
		'gdg',
		'gdh',
		'gdi',
		'gdj',
		'gdk',
		'gdl',
		'gdm',
		'gdn',
		'gdo',
		'gdq',
		'gdr',
		'gds',
		'gdt',
		'gdu',
		'gdx',
		'gea',
		'geb',
		'gec',
		'ged',
		'geg',
		'geh',
		'gei',
		'gej',
		'gek',
		'gel',
		'gem',
		'geq',
		'ges',
		'gev',
		'gew',
		'gex',
		'gey',
		'gez',
		'gfk',
		'gft',
		'gfx',
		'gga',
		'ggb',
		'ggd',
		'gge',
		'ggg',
		'ggk',
		'ggl',
		'ggn',
		'ggo',
		'ggr',
		'ggt',
		'ggu',
		'ggw',
		'gha',
		'ghc',
		'ghe',
		'ghh',
		'ghk',
		'ghl',
		'ghn',
		'gho',
		'ghr',
		'ghs',
		'ght',
		'gia',
		'gib',
		'gic',
		'gid',
		'gie',
		'gig',
		'gih',
		'gil',
		'gim',
		'gin',
		'gio',
		'gip',
		'giq',
		'gir',
		'gis',
		'git',
		'giu',
		'giw',
		'gix',
		'giy',
		'giz',
		'gji',
		'gjk',
		'gjm',
		'gjn',
		'gjr',
		'gju',
		'gka',
		'gkd',
		'gke',
		'gkn',
		'gko',
		'gkp',
		'gku',
		'glc',
		'gld',
		'glh',
		'gli',
		'glj',
		'glk',
		'gll',
		'glo',
		'glr',
		'glu',
		'glw',
		'gly',
		'gma',
		'gmb',
		'gmd',
		'gme',
		'gmg',
		'gmh',
		'gml',
		'gmm',
		'gmn',
		'gmq',
		'gmu',
		'gmv',
		'gmw',
		'gmx',
		'gmy',
		'gmz',
		'gna',
		'gnb',
		'gnc',
		'gnd',
		'gne',
		'gng',
		'gnh',
		'gni',
		'gnj',
		'gnk',
		'gnl',
		'gnm',
		'gnn',
		'gno',
		'gnq',
		'gnr',
		'gnt',
		'gnu',
		'gnw',
		'gnz',
		'goa',
		'gob',
		'goc',
		'god',
		'goe',
		'gof',
		'gog',
		'goh',
		'goi',
		'goj',
		'gok',
		'gol',
		'gom',
		'gon',
		'goo',
		'gop',
		'goq',
		'gor',
		'gos',
		'got',
		'gou',
		'gow',
		'gox',
		'goy',
		'goz',
		'gpa',
		'gpe',
		'gpn',
		'gqa',
		'gqi',
		'gqn',
		'gqr',
		'gqu',
		'gra',
		'grb',
		'grc',
		'grd',
		'grg',
		'grh',
		'gri',
		'grj',
		'grk',
		'grm',
		'gro',
		'grq',
		'grr',
		'grs',
		'grt',
		'gru',
		'grv',
		'grw',
		'grx',
		'gry',
		'grz',
		'gse',
		'gsg',
		'gsl',
		'gsm',
		'gsn',
		'gso',
		'gsp',
		'gss',
		'gsw',
		'gta',
		'gti',
		'gtu',
		'gua',
		'gub',
		'guc',
		'gud',
		'gue',
		'guf',
		'gug',
		'guh',
		'gui',
		'guk',
		'gul',
		'gum',
		'gun',
		'guo',
		'gup',
		'guq',
		'gur',
		'gus',
		'gut',
		'guu',
		'guv',
		'guw',
		'gux',
		'guz',
		'gva',
		'gvc',
		'gve',
		'gvf',
		'gvj',
		'gvl',
		'gvm',
		'gvn',
		'gvo',
		'gvp',
		'gvr',
		'gvs',
		'gvy',
		'gwa',
		'gwb',
		'gwc',
		'gwd',
		'gwe',
		'gwf',
		'gwg',
		'gwi',
		'gwj',
		'gwm',
		'gwn',
		'gwr',
		'gwt',
		'gwu',
		'gww',
		'gwx',
		'gxx',
		'gya',
		'gyb',
		'gyd',
		'gye',
		'gyf',
		'gyg',
		'gyi',
		'gyl',
		'gym',
		'gyn',
		'gyo',
		'gyr',
		'gyy',
		'gza',
		'gzi',
		'gzn',
		'haa',
		'hab',
		'hac',
		'had',
		'hae',
		'haf',
		'hag',
		'hah',
		'hai',
		'haj',
		'hak',
		'hal',
		'ham',
		'han',
		'hao',
		'hap',
		'haq',
		'har',
		'has',
		'hav',
		'haw',
		'hax',
		'hay',
		'haz',
		'hba',
		'hbb',
		'hbn',
		'hbo',
		'hbu',
		'hca',
		'hch',
		'hdn',
		'hds',
		'hdy',
		'hea',
		'hed',
		'heg',
		'heh',
		'hei',
		'hem',
		'hgm',
		'hgw',
		'hhi',
		'hhr',
		'hhy',
		'hia',
		'hib',
		'hid',
		'hif',
		'hig',
		'hih',
		'hii',
		'hij',
		'hik',
		'hil',
		'him',
		'hio',
		'hir',
		'hit',
		'hiw',
		'hix',
		'hji',
		'hka',
		'hke',
		'hkk',
		'hkn',
		'hks',
		'hla',
		'hlb',
		'hld',
		'hle',
		'hlt',
		'hlu',
		'hma',
		'hmb',
		'hmc',
		'hmd',
		'hme',
		'hmf',
		'hmg',
		'hmh',
		'hmi',
		'hmj',
		'hmk',
		'hml',
		'hmm',
		'hmn',
		'hmp',
		'hmq',
		'hmr',
		'hms',
		'hmt',
		'hmu',
		'hmv',
		'hmw',
		'hmx',
		'hmy',
		'hmz',
		'hna',
		'hnd',
		'hne',
		'hnh',
		'hni',
		'hnj',
		'hnn',
		'hno',
		'hns',
		'hnu',
		'hoa',
		'hob',
		'hoc',
		'hod',
		'hoe',
		'hoh',
		'hoi',
		'hoj',
		'hok',
		'hol',
		'hom',
		'hoo',
		'hop',
		'hor',
		'hos',
		'hot',
		'hov',
		'how',
		'hoy',
		'hoz',
		'hpo',
		'hps',
		'hra',
		'hrc',
		'hre',
		'hrk',
		'hrm',
		'hro',
		'hrp',
		'hrr',
		'hrt',
		'hru',
		'hrw',
		'hrx',
		'hrz',
		'hsb',
		'hsh',
		'hsl',
		'hsn',
		'hss',
		'hti',
		'hto',
		'hts',
		'htu',
		'htx',
		'hub',
		'huc',
		'hud',
		'hue',
		'huf',
		'hug',
		'huh',
		'hui',
		'huj',
		'huk',
		'hul',
		'hum',
		'huo',
		'hup',
		'huq',
		'hur',
		'hus',
		'hut',
		'huu',
		'huv',
		'huw',
		'hux',
		'huy',
		'huz',
		'hvc',
		'hve',
		'hvk',
		'hvn',
		'hvv',
		'hwa',
		'hwc',
		'hwo',
		'hya',
		'hyw',
		'hyx',
		'iai',
		'ian',
		'iap',
		'iar',
		'iba',
		'ibb',
		'ibd',
		'ibe',
		'ibg',
		'ibh',
		'ibi',
		'ibl',
		'ibm',
		'ibn',
		'ibr',
		'ibu',
		'iby',
		'ica',
		'ich',
		'icl',
		'icr',
		'ida',
		'idb',
		'idc',
		'idd',
		'ide',
		'idi',
		'idr',
		'ids',
		'idt',
		'idu',
		'ifa',
		'ifb',
		'ife',
		'iff',
		'ifk',
		'ifm',
		'ifu',
		'ify',
		'igb',
		'ige',
		'igg',
		'igl',
		'igm',
		'ign',
		'igo',
		'igs',
		'igw',
		'ihb',
		'ihi',
		'ihp',
		'ihw',
		'iin',
		'iir',
		'ijc',
		'ije',
		'ijj',
		'ijn',
		'ijo',
		'ijs',
		'ike',
		'iki',
		'ikk',
		'ikl',
		'iko',
		'ikp',
		'ikr',
		'iks',
		'ikt',
		'ikv',
		'ikw',
		'ikx',
		'ikz',
		'ila',
		'ilb',
		'ilg',
		'ili',
		'ilk',
		'ill',
		'ilm',
		'ilo',
		'ilp',
		'ils',
		'ilu',
		'ilv',
		'ilw',
		'ima',
		'ime',
		'imi',
		'iml',
		'imn',
		'imo',
		'imr',
		'ims',
		'imy',
		'inb',
		'inc',
		'ine',
		'ing',
		'inh',
		'inj',
		'inl',
		'inm',
		'inn',
		'ino',
		'inp',
		'ins',
		'int',
		'inz',
		'ior',
		'iou',
		'iow',
		'ipi',
		'ipo',
		'iqu',
		'iqw',
		'ira',
		'ire',
		'irh',
		'iri',
		'irk',
		'irn',
		'iro',
		'irr',
		'iru',
		'irx',
		'iry',
		'isa',
		'isc',
		'isd',
		'ise',
		'isg',
		'ish',
		'isi',
		'isk',
		'ism',
		'isn',
		'iso',
		'isr',
		'ist',
		'isu',
		'itb',
		'itc',
		'itd',
		'ite',
		'iti',
		'itk',
		'itl',
		'itm',
		'ito',
		'itr',
		'its',
		'itt',
		'itv',
		'itw',
		'itx',
		'ity',
		'itz',
		'ium',
		'ivb',
		'ivv',
		'iwk',
		'iwm',
		'iwo',
		'iws',
		'ixc',
		'ixl',
		'iya',
		'iyo',
		'iyx',
		'izh',
		'izi',
		'izr',
		'izz',
		'jaa',
		'jab',
		'jac',
		'jad',
		'jae',
		'jaf',
		'jah',
		'jaj',
		'jak',
		'jal',
		'jam',
		'jan',
		'jao',
		'jaq',
		'jar',
		'jas',
		'jat',
		'jau',
		'jax',
		'jay',
		'jaz',
		'jbe',
		'jbi',
		'jbj',
		'jbk',
		'jbn',
		'jbo',
		'jbr',
		'jbt',
		'jbu',
		'jbw',
		'jcs',
		'jct',
		'jda',
		'jdg',
		'jdt',
		'jeb',
		'jee',
		'jeg',
		'jeh',
		'jei',
		'jek',
		'jel',
		'jen',
		'jer',
		'jet',
		'jeu',
		'jgb',
		'jge',
		'jgk',
		'jgo',
		'jhi',
		'jhs',
		'jia',
		'jib',
		'jic',
		'jid',
		'jie',
		'jig',
		'jih',
		'jii',
		'jil',
		'jim',
		'jio',
		'jiq',
		'jit',
		'jiu',
		'jiv',
		'jiy',
		'jje',
		'jjr',
		'jka',
		'jkm',
		'jko',
		'jkp',
		'jkr',
		'jku',
		'jle',
		'jls',
		'jma',
		'jmb',
		'jmc',
		'jmd',
		'jmi',
		'jml',
		'jmn',
		'jmr',
		'jms',
		'jmw',
		'jmx',
		'jna',
		'jnd',
		'jng',
		'jni',
		'jnj',
		'jnl',
		'jns',
		'job',
		'jod',
		'jog',
		'jor',
		'jos',
		'jow',
		'jpa',
		'jpr',
		'jpx',
		'jqr',
		'jra',
		'jrb',
		'jrr',
		'jrt',
		'jru',
		'jsl',
		'jua',
		'jub',
		'juc',
		'jud',
		'juh',
		'jui',
		'juk',
		'jul',
		'jum',
		'jun',
		'juo',
		'jup',
		'jur',
		'jus',
		'jut',
		'juu',
		'juw',
		'juy',
		'jvd',
		'jvn',
		'jwi',
		'jya',
		'jye',
		'jyy',
		'kaa',
		'kab',
		'kac',
		'kad',
		'kae',
		'kaf',
		'kag',
		'kah',
		'kai',
		'kaj',
		'kak',
		'kam',
		'kao',
		'kap',
		'kaq',
		'kar',
		'kav',
		'kaw',
		'kax',
		'kay',
		'kba',
		'kbb',
		'kbc',
		'kbd',
		'kbe',
		'kbf',
		'kbg',
		'kbh',
		'kbi',
		'kbj',
		'kbk',
		'kbl',
		'kbm',
		'kbn',
		'kbo',
		'kbp',
		'kbq',
		'kbr',
		'kbs',
		'kbt',
		'kbu',
		'kbv',
		'kbw',
		'kbx',
		'kby',
		'kbz',
		'kca',
		'kcb',
		'kcc',
		'kcd',
		'kce',
		'kcf',
		'kcg',
		'kch',
		'kci',
		'kcj',
		'kck',
		'kcl',
		'kcm',
		'kcn',
		'kco',
		'kcp',
		'kcq',
		'kcr',
		'kcs',
		'kct',
		'kcu',
		'kcv',
		'kcw',
		'kcx',
		'kcy',
		'kcz',
		'kda',
		'kdc',
		'kdd',
		'kde',
		'kdf',
		'kdg',
		'kdh',
		'kdi',
		'kdj',
		'kdk',
		'kdl',
		'kdm',
		'kdn',
		'kdo',
		'kdp',
		'kdq',
		'kdr',
		'kdt',
		'kdu',
		'kdv',
		'kdw',
		'kdx',
		'kdy',
		'kdz',
		'kea',
		'keb',
		'kec',
		'ked',
		'kee',
		'kef',
		'keg',
		'keh',
		'kei',
		'kej',
		'kek',
		'kel',
		'kem',
		'ken',
		'keo',
		'kep',
		'keq',
		'ker',
		'kes',
		'ket',
		'keu',
		'kev',
		'kew',
		'kex',
		'key',
		'kez',
		'kfa',
		'kfb',
		'kfc',
		'kfd',
		'kfe',
		'kff',
		'kfg',
		'kfh',
		'kfi',
		'kfj',
		'kfk',
		'kfl',
		'kfm',
		'kfn',
		'kfo',
		'kfp',
		'kfq',
		'kfr',
		'kfs',
		'kft',
		'kfu',
		'kfv',
		'kfw',
		'kfx',
		'kfy',
		'kfz',
		'kga',
		'kgb',
		'kgc',
		'kgd',
		'kge',
		'kgf',
		'kgg',
		'kgh',
		'kgi',
		'kgj',
		'kgk',
		'kgl',
		'kgm',
		'kgn',
		'kgo',
		'kgp',
		'kgq',
		'kgr',
		'kgs',
		'kgt',
		'kgu',
		'kgv',
		'kgw',
		'kgx',
		'kgy',
		'kha',
		'khb',
		'khc',
		'khd',
		'khe',
		'khf',
		'khg',
		'khh',
		'khi',
		'khj',
		'khk',
		'khl',
		'khn',
		'kho',
		'khp',
		'khq',
		'khr',
		'khs',
		'kht',
		'khu',
		'khv',
		'khw',
		'khx',
		'khy',
		'khz',
		'kia',
		'kib',
		'kic',
		'kid',
		'kie',
		'kif',
		'kig',
		'kih',
		'kii',
		'kij',
		'kil',
		'kim',
		'kio',
		'kip',
		'kiq',
		'kis',
		'kit',
		'kiu',
		'kiv',
		'kiw',
		'kix',
		'kiy',
		'kiz',
		'kja',
		'kjb',
		'kjc',
		'kjd',
		'kje',
		'kjf',
		'kjg',
		'kjh',
		'kji',
		'kjj',
		'kjk',
		'kjl',
		'kjm',
		'kjn',
		'kjo',
		'kjp',
		'kjq',
		'kjr',
		'kjs',
		'kjt',
		'kju',
		'kjv',
		'kjx',
		'kjy',
		'kjz',
		'kka',
		'kkb',
		'kkc',
		'kkd',
		'kke',
		'kkf',
		'kkg',
		'kkh',
		'kki',
		'kkj',
		'kkk',
		'kkl',
		'kkm',
		'kkn',
		'kko',
		'kkp',
		'kkq',
		'kkr',
		'kks',
		'kkt',
		'kku',
		'kkv',
		'kkw',
		'kkx',
		'kky',
		'kkz',
		'kla',
		'klb',
		'klc',
		'kld',
		'kle',
		'klf',
		'klg',
		'klh',
		'kli',
		'klj',
		'klk',
		'kll',
		'klm',
		'kln',
		'klo',
		'klp',
		'klq',
		'klr',
		'kls',
		'klt',
		'klu',
		'klv',
		'klw',
		'klx',
		'kly',
		'klz',
		'kma',
		'kmb',
		'kmc',
		'kmd',
		'kme',
		'kmf',
		'kmg',
		'kmh',
		'kmi',
		'kmj',
		'kmk',
		'kml',
		'kmm',
		'kmn',
		'kmo',
		'kmp',
		'kmq',
		'kmr',
		'kms',
		'kmt',
		'kmu',
		'kmv',
		'kmw',
		'kmx',
		'kmy',
		'kmz',
		'kna',
		'knb',
		'knc',
		'knd',
		'kne',
		'knf',
		'kng',
		'kni',
		'knj',
		'knk',
		'knl',
		'knm',
		'knn',
		'kno',
		'knp',
		'knq',
		'knr',
		'kns',
		'knt',
		'knu',
		'knv',
		'knw',
		'knx',
		'kny',
		'knz',
		'koa',
		'koc',
		'kod',
		'koe',
		'kof',
		'kog',
		'koh',
		'koi',
		'koj',
		'kok',
		'kol',
		'koo',
		'kop',
		'koq',
		'kos',
		'kot',
		'kou',
		'kov',
		'kow',
		'kox',
		'koy',
		'koz',
		'kpa',
		'kpb',
		'kpc',
		'kpd',
		'kpe',
		'kpf',
		'kpg',
		'kph',
		'kpi',
		'kpj',
		'kpk',
		'kpl',
		'kpm',
		'kpn',
		'kpo',
		'kpp',
		'kpq',
		'kpr',
		'kps',
		'kpt',
		'kpu',
		'kpv',
		'kpw',
		'kpx',
		'kpy',
		'kpz',
		'kqa',
		'kqb',
		'kqc',
		'kqd',
		'kqe',
		'kqf',
		'kqg',
		'kqh',
		'kqi',
		'kqj',
		'kqk',
		'kql',
		'kqm',
		'kqn',
		'kqo',
		'kqp',
		'kqq',
		'kqr',
		'kqs',
		'kqt',
		'kqu',
		'kqv',
		'kqw',
		'kqx',
		'kqy',
		'kqz',
		'kra',
		'krb',
		'krc',
		'krd',
		'kre',
		'krf',
		'krh',
		'kri',
		'krj',
		'krk',
		'krl',
		'krm',
		'krn',
		'kro',
		'krp',
		'krr',
		'krs',
		'krt',
		'kru',
		'krv',
		'krw',
		'krx',
		'kry',
		'krz',
		'ksa',
		'ksb',
		'ksc',
		'ksd',
		'kse',
		'ksf',
		'ksg',
		'ksh',
		'ksi',
		'ksj',
		'ksk',
		'ksl',
		'ksm',
		'ksn',
		'kso',
		'ksp',
		'ksq',
		'ksr',
		'kss',
		'kst',
		'ksu',
		'ksv',
		'ksw',
		'ksx',
		'ksy',
		'ksz',
		'kta',
		'ktb',
		'ktc',
		'ktd',
		'kte',
		'ktf',
		'ktg',
		'kth',
		'kti',
		'ktj',
		'ktk',
		'ktl',
		'ktm',
		'ktn',
		'kto',
		'ktp',
		'ktq',
		'ktr',
		'kts',
		'ktt',
		'ktu',
		'ktv',
		'ktw',
		'ktx',
		'kty',
		'ktz',
		'kub',
		'kuc',
		'kud',
		'kue',
		'kuf',
		'kug',
		'kuh',
		'kui',
		'kuj',
		'kuk',
		'kul',
		'kum',
		'kun',
		'kuo',
		'kup',
		'kuq',
		'kus',
		'kut',
		'kuu',
		'kuv',
		'kuw',
		'kux',
		'kuy',
		'kuz',
		'kva',
		'kvb',
		'kvc',
		'kvd',
		'kve',
		'kvf',
		'kvg',
		'kvh',
		'kvi',
		'kvj',
		'kvk',
		'kvl',
		'kvm',
		'kvn',
		'kvo',
		'kvp',
		'kvq',
		'kvr',
		'kvs',
		'kvt',
		'kvu',
		'kvv',
		'kvw',
		'kvx',
		'kvy',
		'kvz',
		'kwa',
		'kwb',
		'kwc',
		'kwd',
		'kwe',
		'kwf',
		'kwg',
		'kwh',
		'kwi',
		'kwj',
		'kwk',
		'kwl',
		'kwm',
		'kwn',
		'kwo',
		'kwp',
		'kwq',
		'kwr',
		'kws',
		'kwt',
		'kwu',
		'kwv',
		'kww',
		'kwx',
		'kwy',
		'kwz',
		'kxa',
		'kxb',
		'kxc',
		'kxd',
		'kxe',
		'kxf',
		'kxh',
		'kxi',
		'kxj',
		'kxk',
		'kxl',
		'kxm',
		'kxn',
		'kxo',
		'kxp',
		'kxq',
		'kxr',
		'kxs',
		'kxt',
		'kxu',
		'kxv',
		'kxw',
		'kxx',
		'kxy',
		'kxz',
		'kya',
		'kyb',
		'kyc',
		'kyd',
		'kye',
		'kyf',
		'kyg',
		'kyh',
		'kyi',
		'kyj',
		'kyk',
		'kyl',
		'kym',
		'kyn',
		'kyo',
		'kyp',
		'kyq',
		'kyr',
		'kys',
		'kyt',
		'kyu',
		'kyv',
		'kyw',
		'kyx',
		'kyy',
		'kyz',
		'kza',
		'kzb',
		'kzc',
		'kzd',
		'kze',
		'kzf',
		'kzg',
		'kzh',
		'kzi',
		'kzj',
		'kzk',
		'kzl',
		'kzm',
		'kzn',
		'kzo',
		'kzp',
		'kzq',
		'kzr',
		'kzs',
		'kzt',
		'kzu',
		'kzv',
		'kzw',
		'kzx',
		'kzy',
		'kzz',
		'laa',
		'lab',
		'lac',
		'lad',
		'lae',
		'laf',
		'lag',
		'lah',
		'lai',
		'laj',
		'lak',
		'lal',
		'lam',
		'lan',
		'lap',
		'laq',
		'lar',
		'las',
		'lau',
		'law',
		'lax',
		'lay',
		'laz',
		'lba',
		'lbb',
		'lbc',
		'lbe',
		'lbf',
		'lbg',
		'lbi',
		'lbj',
		'lbk',
		'lbl',
		'lbm',
		'lbn',
		'lbo',
		'lbq',
		'lbr',
		'lbs',
		'lbt',
		'lbu',
		'lbv',
		'lbw',
		'lbx',
		'lby',
		'lbz',
		'lcc',
		'lcd',
		'lce',
		'lcf',
		'lch',
		'lcl',
		'lcm',
		'lcp',
		'lcq',
		'lcs',
		'lda',
		'ldb',
		'ldd',
		'ldg',
		'ldh',
		'ldi',
		'ldj',
		'ldk',
		'ldl',
		'ldm',
		'ldn',
		'ldo',
		'ldp',
		'ldq',
		'lea',
		'leb',
		'lec',
		'led',
		'lee',
		'lef',
		'leg',
		'leh',
		'lei',
		'lej',
		'lek',
		'lel',
		'lem',
		'len',
		'leo',
		'lep',
		'leq',
		'ler',
		'les',
		'let',
		'leu',
		'lev',
		'lew',
		'lex',
		'ley',
		'lez',
		'lfa',
		'lfn',
		'lga',
		'lgb',
		'lgg',
		'lgh',
		'lgi',
		'lgk',
		'lgl',
		'lgm',
		'lgn',
		'lgq',
		'lgr',
		'lgt',
		'lgu',
		'lgz',
		'lha',
		'lhh',
		'lhi',
		'lhl',
		'lhm',
		'lhn',
		'lhp',
		'lhs',
		'lht',
		'lhu',
		'lia',
		'lib',
		'lic',
		'lid',
		'lie',
		'lif',
		'lig',
		'lih',
		'lii',
		'lij',
		'lik',
		'lil',
		'lio',
		'lip',
		'liq',
		'lir',
		'lis',
		'liu',
		'liv',
		'liw',
		'lix',
		'liy',
		'liz',
		'lja',
		'lje',
		'lji',
		'ljl',
		'ljp',
		'ljw',
		'ljx',
		'lka',
		'lkb',
		'lkc',
		'lkd',
		'lke',
		'lkh',
		'lki',
		'lkj',
		'lkl',
		'lkm',
		'lkn',
		'lko',
		'lkr',
		'lks',
		'lkt',
		'lku',
		'lky',
		'lla',
		'llb',
		'llc',
		'lld',
		'lle',
		'llf',
		'llg',
		'llh',
		'lli',
		'llj',
		'llk',
		'lll',
		'llm',
		'lln',
		'llo',
		'llp',
		'llq',
		'lls',
		'llu',
		'llx',
		'lma',
		'lmb',
		'lmc',
		'lmd',
		'lme',
		'lmf',
		'lmg',
		'lmh',
		'lmi',
		'lmj',
		'lmk',
		'lml',
		'lmm',
		'lmn',
		'lmo',
		'lmp',
		'lmq',
		'lmr',
		'lmu',
		'lmv',
		'lmw',
		'lmx',
		'lmy',
		'lmz',
		'lna',
		'lnb',
		'lnd',
		'lng',
		'lnh',
		'lni',
		'lnj',
		'lnl',
		'lnm',
		'lnn',
		'lno',
		'lns',
		'lnu',
		'lnw',
		'lnz',
		'loa',
		'lob',
		'loc',
		'loe',
		'lof',
		'log',
		'loh',
		'loi',
		'loj',
		'lok',
		'lol',
		'lom',
		'lon',
		'loo',
		'lop',
		'loq',
		'lor',
		'los',
		'lot',
		'lou',
		'lov',
		'low',
		'lox',
		'loy',
		'loz',
		'lpa',
		'lpe',
		'lpn',
		'lpo',
		'lpx',
		'lra',
		'lrc',
		'lre',
		'lrg',
		'lri',
		'lrk',
		'lrl',
		'lrm',
		'lrn',
		'lro',
		'lrr',
		'lrt',
		'lrv',
		'lrz',
		'lsa',
		'lsd',
		'lse',
		'lsg',
		'lsh',
		'lsi',
		'lsl',
		'lsm',
		'lso',
		'lsp',
		'lsr',
		'lss',
		'lst',
		'lsy',
		'ltc',
		'ltg',
		'lth',
		'lti',
		'ltn',
		'lto',
		'lts',
		'ltu',
		'lua',
		'luc',
		'lud',
		'lue',
		'luf',
		'lui',
		'luj',
		'luk',
		'lul',
		'lum',
		'lun',
		'luo',
		'lup',
		'luq',
		'lur',
		'lus',
		'lut',
		'luu',
		'luv',
		'luw',
		'luy',
		'luz',
		'lva',
		'lvk',
		'lvs',
		'lvu',
		'lwa',
		'lwe',
		'lwg',
		'lwh',
		'lwl',
		'lwm',
		'lwo',
		'lws',
		'lwt',
		'lwu',
		'lww',
		'lya',
		'lyg',
		'lyn',
		'lzh',
		'lzl',
		'lzn',
		'lzz',
		'maa',
		'mab',
		'mad',
		'mae',
		'maf',
		'mag',
		'mai',
		'maj',
		'mak',
		'mam',
		'man',
		'map',
		'maq',
		'mas',
		'mat',
		'mau',
		'mav',
		'maw',
		'max',
		'maz',
		'mba',
		'mbb',
		'mbc',
		'mbd',
		'mbe',
		'mbf',
		'mbh',
		'mbi',
		'mbj',
		'mbk',
		'mbl',
		'mbm',
		'mbn',
		'mbo',
		'mbp',
		'mbq',
		'mbr',
		'mbs',
		'mbt',
		'mbu',
		'mbv',
		'mbw',
		'mbx',
		'mby',
		'mbz',
		'mca',
		'mcb',
		'mcc',
		'mcd',
		'mce',
		'mcf',
		'mcg',
		'mch',
		'mci',
		'mcj',
		'mck',
		'mcl',
		'mcm',
		'mcn',
		'mco',
		'mcp',
		'mcq',
		'mcr',
		'mcs',
		'mct',
		'mcu',
		'mcv',
		'mcw',
		'mcx',
		'mcy',
		'mcz',
		'mda',
		'mdb',
		'mdc',
		'mdd',
		'mde',
		'mdf',
		'mdg',
		'mdh',
		'mdi',
		'mdj',
		'mdk',
		'mdl',
		'mdm',
		'mdn',
		'mdp',
		'mdq',
		'mdr',
		'mds',
		'mdt',
		'mdu',
		'mdv',
		'mdw',
		'mdx',
		'mdy',
		'mdz',
		'mea',
		'meb',
		'mec',
		'med',
		'mee',
		'mef',
		'meg',
		'meh',
		'mei',
		'mej',
		'mek',
		'mel',
		'mem',
		'men',
		'meo',
		'mep',
		'meq',
		'mer',
		'mes',
		'met',
		'meu',
		'mev',
		'mew',
		'mey',
		'mez',
		'mfa',
		'mfb',
		'mfc',
		'mfd',
		'mfe',
		'mff',
		'mfg',
		'mfh',
		'mfi',
		'mfj',
		'mfk',
		'mfl',
		'mfm',
		'mfn',
		'mfo',
		'mfp',
		'mfq',
		'mfr',
		'mfs',
		'mft',
		'mfu',
		'mfv',
		'mfw',
		'mfx',
		'mfy',
		'mfz',
		'mga',
		'mgb',
		'mgc',
		'mgd',
		'mge',
		'mgf',
		'mgg',
		'mgh',
		'mgi',
		'mgj',
		'mgk',
		'mgl',
		'mgm',
		'mgn',
		'mgo',
		'mgp',
		'mgq',
		'mgr',
		'mgs',
		'mgt',
		'mgu',
		'mgv',
		'mgw',
		'mgx',
		'mgy',
		'mgz',
		'mha',
		'mhb',
		'mhc',
		'mhd',
		'mhe',
		'mhf',
		'mhg',
		'mhh',
		'mhi',
		'mhj',
		'mhk',
		'mhl',
		'mhm',
		'mhn',
		'mho',
		'mhp',
		'mhq',
		'mhr',
		'mhs',
		'mht',
		'mhu',
		'mhw',
		'mhx',
		'mhy',
		'mhz',
		'mia',
		'mib',
		'mic',
		'mid',
		'mie',
		'mif',
		'mig',
		'mih',
		'mii',
		'mij',
		'mik',
		'mil',
		'mim',
		'min',
		'mio',
		'mip',
		'miq',
		'mir',
		'mis',
		'mit',
		'miu',
		'miw',
		'mix',
		'miy',
		'miz',
		'mja',
		'mjb',
		'mjc',
		'mjd',
		'mje',
		'mjg',
		'mjh',
		'mji',
		'mjj',
		'mjk',
		'mjl',
		'mjm',
		'mjn',
		'mjo',
		'mjp',
		'mjq',
		'mjr',
		'mjs',
		'mjt',
		'mju',
		'mjv',
		'mjw',
		'mjx',
		'mjy',
		'mjz',
		'mka',
		'mkb',
		'mkc',
		'mke',
		'mkf',
		'mkg',
		'mkh',
		'mki',
		'mkj',
		'mkk',
		'mkl',
		'mkm',
		'mkn',
		'mko',
		'mkp',
		'mkq',
		'mkr',
		'mks',
		'mkt',
		'mku',
		'mkv',
		'mkw',
		'mkx',
		'mky',
		'mkz',
		'mla',
		'mlb',
		'mlc',
		'mld',
		'mle',
		'mlf',
		'mlh',
		'mli',
		'mlj',
		'mlk',
		'mll',
		'mlm',
		'mln',
		'mlo',
		'mlp',
		'mlq',
		'mlr',
		'mls',
		'mlu',
		'mlv',
		'mlw',
		'mlx',
		'mlz',
		'mma',
		'mmb',
		'mmc',
		'mmd',
		'mme',
		'mmf',
		'mmg',
		'mmh',
		'mmi',
		'mmj',
		'mmk',
		'mml',
		'mmm',
		'mmn',
		'mmo',
		'mmp',
		'mmq',
		'mmr',
		'mmt',
		'mmu',
		'mmv',
		'mmw',
		'mmx',
		'mmy',
		'mmz',
		'mna',
		'mnb',
		'mnc',
		'mnd',
		'mne',
		'mnf',
		'mng',
		'mnh',
		'mni',
		'mnj',
		'mnk',
		'mnl',
		'mnm',
		'mnn',
		'mno',
		'mnp',
		'mnq',
		'mnr',
		'mns',
		'mnt',
		'mnu',
		'mnv',
		'mnw',
		'mnx',
		'mny',
		'mnz',
		'moa',
		'moc',
		'mod',
		'moe',
		'mof',
		'mog',
		'moh',
		'moi',
		'moj',
		'mok',
		'mom',
		'moo',
		'mop',
		'moq',
		'mor',
		'mos',
		'mot',
		'mou',
		'mov',
		'mow',
		'mox',
		'moy',
		'moz',
		'mpa',
		'mpb',
		'mpc',
		'mpd',
		'mpe',
		'mpg',
		'mph',
		'mpi',
		'mpj',
		'mpk',
		'mpl',
		'mpm',
		'mpn',
		'mpo',
		'mpp',
		'mpq',
		'mpr',
		'mps',
		'mpt',
		'mpu',
		'mpv',
		'mpw',
		'mpx',
		'mpy',
		'mpz',
		'mqa',
		'mqb',
		'mqc',
		'mqe',
		'mqf',
		'mqg',
		'mqh',
		'mqi',
		'mqj',
		'mqk',
		'mql',
		'mqm',
		'mqn',
		'mqo',
		'mqp',
		'mqq',
		'mqr',
		'mqs',
		'mqt',
		'mqu',
		'mqv',
		'mqw',
		'mqx',
		'mqy',
		'mqz',
		'mra',
		'mrb',
		'mrc',
		'mrd',
		'mre',
		'mrf',
		'mrg',
		'mrh',
		'mrj',
		'mrk',
		'mrl',
		'mrm',
		'mrn',
		'mro',
		'mrp',
		'mrq',
		'mrr',
		'mrs',
		'mrt',
		'mru',
		'mrv',
		'mrw',
		'mrx',
		'mry',
		'mrz',
		'msb',
		'msc',
		'msd',
		'mse',
		'msf',
		'msg',
		'msh',
		'msi',
		'msj',
		'msk',
		'msl',
		'msm',
		'msn',
		'mso',
		'msp',
		'msq',
		'msr',
		'mss',
		'mst',
		'msu',
		'msv',
		'msw',
		'msx',
		'msy',
		'msz',
		'mta',
		'mtb',
		'mtc',
		'mtd',
		'mte',
		'mtf',
		'mtg',
		'mth',
		'mti',
		'mtj',
		'mtk',
		'mtl',
		'mtm',
		'mtn',
		'mto',
		'mtp',
		'mtq',
		'mtr',
		'mts',
		'mtt',
		'mtu',
		'mtv',
		'mtw',
		'mtx',
		'mty',
		'mua',
		'mub',
		'muc',
		'mud',
		'mue',
		'mug',
		'muh',
		'mui',
		'muj',
		'muk',
		'mul',
		'mum',
		'mun',
		'muo',
		'mup',
		'muq',
		'mur',
		'mus',
		'mut',
		'muu',
		'muv',
		'mux',
		'muy',
		'muz',
		'mva',
		'mvb',
		'mvd',
		'mve',
		'mvf',
		'mvg',
		'mvh',
		'mvi',
		'mvk',
		'mvl',
		'mvm',
		'mvn',
		'mvo',
		'mvp',
		'mvq',
		'mvr',
		'mvs',
		'mvt',
		'mvu',
		'mvv',
		'mvw',
		'mvx',
		'mvy',
		'mvz',
		'mwa',
		'mwb',
		'mwc',
		'mwd',
		'mwe',
		'mwf',
		'mwg',
		'mwh',
		'mwi',
		'mwj',
		'mwk',
		'mwl',
		'mwm',
		'mwn',
		'mwo',
		'mwp',
		'mwq',
		'mwr',
		'mws',
		'mwt',
		'mwu',
		'mwv',
		'mww',
		'mwx',
		'mwy',
		'mwz',
		'mxa',
		'mxb',
		'mxc',
		'mxd',
		'mxe',
		'mxf',
		'mxg',
		'mxh',
		'mxi',
		'mxj',
		'mxk',
		'mxl',
		'mxm',
		'mxn',
		'mxo',
		'mxp',
		'mxq',
		'mxr',
		'mxs',
		'mxt',
		'mxu',
		'mxv',
		'mxw',
		'mxx',
		'mxy',
		'mxz',
		'myb',
		'myc',
		'myd',
		'mye',
		'myf',
		'myg',
		'myh',
		'myi',
		'myj',
		'myk',
		'myl',
		'mym',
		'myn',
		'myo',
		'myp',
		'myq',
		'myr',
		'mys',
		'myt',
		'myu',
		'myv',
		'myw',
		'myx',
		'myy',
		'myz',
		'mza',
		'mzb',
		'mzc',
		'mzd',
		'mze',
		'mzg',
		'mzh',
		'mzi',
		'mzj',
		'mzk',
		'mzl',
		'mzm',
		'mzn',
		'mzo',
		'mzp',
		'mzq',
		'mzr',
		'mzs',
		'mzt',
		'mzu',
		'mzv',
		'mzw',
		'mzx',
		'mzy',
		'mzz',
		'naa',
		'nab',
		'nac',
		'nad',
		'nae',
		'naf',
		'nag',
		'nah',
		'nai',
		'naj',
		'nak',
		'nal',
		'nam',
		'nan',
		'nao',
		'nap',
		'naq',
		'nar',
		'nas',
		'nat',
		'naw',
		'nax',
		'nay',
		'naz',
		'nba',
		'nbb',
		'nbc',
		'nbd',
		'nbe',
		'nbf',
		'nbg',
		'nbh',
		'nbi',
		'nbj',
		'nbk',
		'nbm',
		'nbn',
		'nbo',
		'nbp',
		'nbq',
		'nbr',
		'nbs',
		'nbt',
		'nbu',
		'nbv',
		'nbw',
		'nbx',
		'nby',
		'nca',
		'ncb',
		'ncc',
		'ncd',
		'nce',
		'ncf',
		'ncg',
		'nch',
		'nci',
		'ncj',
		'nck',
		'ncl',
		'ncm',
		'ncn',
		'nco',
		'ncp',
		'ncq',
		'ncr',
		'ncs',
		'nct',
		'ncu',
		'ncx',
		'ncz',
		'nda',
		'ndb',
		'ndc',
		'ndd',
		'ndf',
		'ndg',
		'ndh',
		'ndi',
		'ndj',
		'ndk',
		'ndl',
		'ndm',
		'ndn',
		'ndp',
		'ndq',
		'ndr',
		'nds',
		'ndt',
		'ndu',
		'ndv',
		'ndw',
		'ndx',
		'ndy',
		'ndz',
		'nea',
		'neb',
		'nec',
		'ned',
		'nee',
		'nef',
		'neg',
		'neh',
		'nei',
		'nej',
		'nek',
		'nem',
		'nen',
		'neo',
		'neq',
		'ner',
		'nes',
		'net',
		'neu',
		'nev',
		'new',
		'nex',
		'ney',
		'nez',
		'nfa',
		'nfd',
		'nfl',
		'nfr',
		'nfu',
		'nga',
		'ngb',
		'ngc',
		'ngd',
		'nge',
		'ngf',
		'ngg',
		'ngh',
		'ngi',
		'ngj',
		'ngk',
		'ngl',
		'ngm',
		'ngn',
		'ngo',
		'ngp',
		'ngq',
		'ngr',
		'ngs',
		'ngt',
		'ngu',
		'ngv',
		'ngw',
		'ngx',
		'ngy',
		'ngz',
		'nha',
		'nhb',
		'nhc',
		'nhd',
		'nhe',
		'nhf',
		'nhg',
		'nhh',
		'nhi',
		'nhk',
		'nhm',
		'nhn',
		'nho',
		'nhp',
		'nhq',
		'nhr',
		'nht',
		'nhu',
		'nhv',
		'nhw',
		'nhx',
		'nhy',
		'nhz',
		'nia',
		'nib',
		'nic',
		'nid',
		'nie',
		'nif',
		'nig',
		'nih',
		'nii',
		'nij',
		'nik',
		'nil',
		'nim',
		'nin',
		'nio',
		'niq',
		'nir',
		'nis',
		'nit',
		'niu',
		'niv',
		'niw',
		'nix',
		'niy',
		'niz',
		'nja',
		'njb',
		'njd',
		'njh',
		'nji',
		'njj',
		'njl',
		'njm',
		'njn',
		'njo',
		'njr',
		'njs',
		'njt',
		'nju',
		'njx',
		'njy',
		'njz',
		'nka',
		'nkb',
		'nkc',
		'nkd',
		'nke',
		'nkf',
		'nkg',
		'nkh',
		'nki',
		'nkj',
		'nkk',
		'nkm',
		'nkn',
		'nko',
		'nkp',
		'nkq',
		'nkr',
		'nks',
		'nkt',
		'nku',
		'nkv',
		'nkw',
		'nkx',
		'nkz',
		'nla',
		'nlc',
		'nle',
		'nlg',
		'nli',
		'nlj',
		'nlk',
		'nll',
		'nlm',
		'nln',
		'nlo',
		'nlq',
		'nlr',
		'nlu',
		'nlv',
		'nlw',
		'nlx',
		'nly',
		'nlz',
		'nma',
		'nmb',
		'nmc',
		'nmd',
		'nme',
		'nmf',
		'nmg',
		'nmh',
		'nmi',
		'nmj',
		'nmk',
		'nml',
		'nmm',
		'nmn',
		'nmo',
		'nmp',
		'nmq',
		'nmr',
		'nms',
		'nmt',
		'nmu',
		'nmv',
		'nmw',
		'nmx',
		'nmy',
		'nmz',
		'nna',
		'nnb',
		'nnc',
		'nnd',
		'nne',
		'nnf',
		'nng',
		'nnh',
		'nni',
		'nnj',
		'nnk',
		'nnl',
		'nnm',
		'nnn',
		'nnp',
		'nnq',
		'nnr',
		'nns',
		'nnt',
		'nnu',
		'nnv',
		'nnw',
		'nnx',
		'nny',
		'nnz',
		'noa',
		'noc',
		'nod',
		'noe',
		'nof',
		'nog',
		'noh',
		'noi',
		'noj',
		'nok',
		'nol',
		'nom',
		'non',
		'noo',
		'nop',
		'noq',
		'nos',
		'not',
		'nou',
		'nov',
		'now',
		'noy',
		'noz',
		'npa',
		'npb',
		'npg',
		'nph',
		'npi',
		'npl',
		'npn',
		'npo',
		'nps',
		'npu',
		'npx',
		'npy',
		'nqg',
		'nqk',
		'nql',
		'nqm',
		'nqn',
		'nqo',
		'nqq',
		'nqy',
		'nra',
		'nrb',
		'nrc',
		'nre',
		'nrf',
		'nrg',
		'nri',
		'nrk',
		'nrl',
		'nrm',
		'nrn',
		'nrp',
		'nrr',
		'nrt',
		'nru',
		'nrx',
		'nrz',
		'nsa',
		'nsc',
		'nsd',
		'nse',
		'nsf',
		'nsg',
		'nsh',
		'nsi',
		'nsk',
		'nsl',
		'nsm',
		'nsn',
		'nso',
		'nsp',
		'nsq',
		'nsr',
		'nss',
		'nst',
		'nsu',
		'nsv',
		'nsw',
		'nsx',
		'nsy',
		'nsz',
		'ntd',
		'nte',
		'ntg',
		'nti',
		'ntj',
		'ntk',
		'ntm',
		'nto',
		'ntp',
		'ntr',
		'nts',
		'ntu',
		'ntw',
		'ntx',
		'nty',
		'ntz',
		'nua',
		'nub',
		'nuc',
		'nud',
		'nue',
		'nuf',
		'nug',
		'nuh',
		'nui',
		'nuj',
		'nuk',
		'nul',
		'num',
		'nun',
		'nuo',
		'nup',
		'nuq',
		'nur',
		'nus',
		'nut',
		'nuu',
		'nuv',
		'nuw',
		'nux',
		'nuy',
		'nuz',
		'nvh',
		'nvm',
		'nvo',
		'nwa',
		'nwb',
		'nwc',
		'nwe',
		'nwg',
		'nwi',
		'nwm',
		'nwo',
		'nwr',
		'nwx',
		'nwy',
		'nxa',
		'nxd',
		'nxe',
		'nxg',
		'nxi',
		'nxk',
		'nxl',
		'nxm',
		'nxn',
		'nxo',
		'nxq',
		'nxr',
		'nxu',
		'nxx',
		'nyb',
		'nyc',
		'nyd',
		'nye',
		'nyf',
		'nyg',
		'nyh',
		'nyi',
		'nyj',
		'nyk',
		'nyl',
		'nym',
		'nyn',
		'nyo',
		'nyp',
		'nyq',
		'nyr',
		'nys',
		'nyt',
		'nyu',
		'nyv',
		'nyw',
		'nyx',
		'nyy',
		'nza',
		'nzb',
		'nzd',
		'nzi',
		'nzk',
		'nzm',
		'nzs',
		'nzu',
		'nzy',
		'nzz',
		'oaa',
		'oac',
		'oar',
		'oav',
		'obi',
		'obk',
		'obl',
		'obm',
		'obo',
		'obr',
		'obt',
		'obu',
		'oca',
		'och',
		'oco',
		'ocu',
		'oda',
		'odk',
		'odt',
		'odu',
		'ofo',
		'ofs',
		'ofu',
		'ogb',
		'ogc',
		'oge',
		'ogg',
		'ogo',
		'ogu',
		'oht',
		'ohu',
		'oia',
		'oin',
		'ojb',
		'ojc',
		'ojg',
		'ojp',
		'ojs',
		'ojv',
		'ojw',
		'oka',
		'okb',
		'okd',
		'oke',
		'okg',
		'okh',
		'oki',
		'okj',
		'okk',
		'okl',
		'okm',
		'okn',
		'oko',
		'okr',
		'oks',
		'oku',
		'okv',
		'okx',
		'ola',
		'old',
		'ole',
		'olk',
		'olm',
		'olo',
		'olr',
		'olt',
		'olu',
		'oma',
		'omb',
		'omc',
		'ome',
		'omg',
		'omi',
		'omk',
		'oml',
		'omn',
		'omo',
		'omp',
		'omq',
		'omr',
		'omt',
		'omu',
		'omv',
		'omw',
		'omx',
		'ona',
		'onb',
		'one',
		'ong',
		'oni',
		'onj',
		'onk',
		'onn',
		'ono',
		'onp',
		'onr',
		'ons',
		'ont',
		'onu',
		'onw',
		'onx',
		'ood',
		'oog',
		'oon',
		'oor',
		'oos',
		'opa',
		'opk',
		'opm',
		'opo',
		'opt',
		'opy',
		'ora',
		'orc',
		'ore',
		'org',
		'orh',
		'orn',
		'oro',
		'orr',
		'ors',
		'ort',
		'oru',
		'orv',
		'orw',
		'orx',
		'ory',
		'orz',
		'osa',
		'osc',
		'osi',
		'oso',
		'osp',
		'ost',
		'osu',
		'osx',
		'ota',
		'otb',
		'otd',
		'ote',
		'oti',
		'otk',
		'otl',
		'otm',
		'otn',
		'oto',
		'otq',
		'otr',
		'ots',
		'ott',
		'otu',
		'otw',
		'otx',
		'oty',
		'otz',
		'oua',
		'oub',
		'oue',
		'oui',
		'oum',
		'oun',
		'ovd',
		'owi',
		'owl',
		'oyb',
		'oyd',
		'oym',
		'oyy',
		'ozm',
		'paa',
		'pab',
		'pac',
		'pad',
		'pae',
		'paf',
		'pag',
		'pah',
		'pai',
		'pak',
		'pal',
		'pam',
		'pao',
		'pap',
		'paq',
		'par',
		'pas',
		'pat',
		'pau',
		'pav',
		'paw',
		'pax',
		'pay',
		'paz',
		'pbb',
		'pbc',
		'pbe',
		'pbf',
		'pbg',
		'pbh',
		'pbi',
		'pbl',
		'pbm',
		'pbn',
		'pbo',
		'pbp',
		'pbr',
		'pbs',
		'pbt',
		'pbu',
		'pbv',
		'pby',
		'pbz',
		'pca',
		'pcb',
		'pcc',
		'pcd',
		'pce',
		'pcf',
		'pcg',
		'pch',
		'pci',
		'pcj',
		'pck',
		'pcl',
		'pcm',
		'pcn',
		'pcp',
		'pcr',
		'pcw',
		'pda',
		'pdc',
		'pdi',
		'pdn',
		'pdo',
		'pdt',
		'pdu',
		'pea',
		'peb',
		'ped',
		'pee',
		'pef',
		'peg',
		'peh',
		'pei',
		'pej',
		'pek',
		'pel',
		'pem',
		'peo',
		'pep',
		'peq',
		'pes',
		'pev',
		'pex',
		'pey',
		'pez',
		'pfa',
		'pfe',
		'pfl',
		'pga',
		'pgd',
		'pgg',
		'pgi',
		'pgk',
		'pgl',
		'pgn',
		'pgs',
		'pgu',
		'pgy',
		'pgz',
		'pha',
		'phd',
		'phg',
		'phh',
		'phi',
		'phk',
		'phl',
		'phm',
		'phn',
		'pho',
		'phq',
		'phr',
		'pht',
		'phu',
		'phv',
		'phw',
		'pia',
		'pib',
		'pic',
		'pid',
		'pie',
		'pif',
		'pig',
		'pih',
		'pii',
		'pij',
		'pil',
		'pim',
		'pin',
		'pio',
		'pip',
		'pir',
		'pis',
		'pit',
		'piu',
		'piv',
		'piw',
		'pix',
		'piy',
		'piz',
		'pjt',
		'pka',
		'pkb',
		'pkc',
		'pkg',
		'pkh',
		'pkn',
		'pko',
		'pkp',
		'pkr',
		'pks',
		'pkt',
		'pku',
		'pla',
		'plb',
		'plc',
		'pld',
		'ple',
		'plf',
		'plg',
		'plh',
		'plj',
		'plk',
		'pll',
		'pln',
		'plo',
		'plp',
		'plq',
		'plr',
		'pls',
		'plt',
		'plu',
		'plv',
		'plw',
		'ply',
		'plz',
		'pma',
		'pmb',
		'pmc',
		'pmd',
		'pme',
		'pmf',
		'pmh',
		'pmi',
		'pmj',
		'pmk',
		'pml',
		'pmm',
		'pmn',
		'pmo',
		'pmq',
		'pmr',
		'pms',
		'pmt',
		'pmu',
		'pmw',
		'pmx',
		'pmy',
		'pmz',
		'pna',
		'pnb',
		'pnc',
		'pne',
		'png',
		'pnh',
		'pni',
		'pnj',
		'pnk',
		'pnl',
		'pnm',
		'pnn',
		'pno',
		'pnp',
		'pnq',
		'pnr',
		'pns',
		'pnt',
		'pnu',
		'pnv',
		'pnw',
		'pnx',
		'pny',
		'pnz',
		'poc',
		'pod',
		'poe',
		'pof',
		'pog',
		'poh',
		'poi',
		'pok',
		'pom',
		'pon',
		'poo',
		'pop',
		'poq',
		'pos',
		'pot',
		'pov',
		'pow',
		'pox',
		'poy',
		'poz',
		'ppa',
		'ppe',
		'ppi',
		'ppk',
		'ppl',
		'ppm',
		'ppn',
		'ppo',
		'ppp',
		'ppq',
		'ppr',
		'pps',
		'ppt',
		'ppu',
		'pqa',
		'pqe',
		'pqm',
		'pqw',
		'pra',
		'prb',
		'prc',
		'prd',
		'pre',
		'prf',
		'prg',
		'prh',
		'pri',
		'prk',
		'prl',
		'prm',
		'prn',
		'pro',
		'prp',
		'prq',
		'prr',
		'prs',
		'prt',
		'pru',
		'prw',
		'prx',
		'pry',
		'prz',
		'psa',
		'psc',
		'psd',
		'pse',
		'psg',
		'psh',
		'psi',
		'psl',
		'psm',
		'psn',
		'pso',
		'psp',
		'psq',
		'psr',
		'pss',
		'pst',
		'psu',
		'psw',
		'psy',
		'pta',
		'pth',
		'pti',
		'ptn',
		'pto',
		'ptp',
		'ptq',
		'ptr',
		'ptt',
		'ptu',
		'ptv',
		'ptw',
		'pty',
		'pua',
		'pub',
		'puc',
		'pud',
		'pue',
		'puf',
		'pug',
		'pui',
		'puj',
		'puk',
		'pum',
		'puo',
		'pup',
		'puq',
		'pur',
		'put',
		'puu',
		'puw',
		'pux',
		'puy',
		'puz',
		'pwa',
		'pwb',
		'pwg',
		'pwi',
		'pwm',
		'pwn',
		'pwo',
		'pwr',
		'pww',
		'pxm',
		'pye',
		'pym',
		'pyn',
		'pys',
		'pyu',
		'pyx',
		'pyy',
		'pzn',
		'qaa..qtz',
		'qua',
		'qub',
		'quc',
		'qud',
		'quf',
		'qug',
		'quh',
		'qui',
		'quk',
		'qul',
		'qum',
		'qun',
		'qup',
		'quq',
		'qur',
		'qus',
		'quv',
		'quw',
		'qux',
		'quy',
		'quz',
		'qva',
		'qvc',
		'qve',
		'qvh',
		'qvi',
		'qvj',
		'qvl',
		'qvm',
		'qvn',
		'qvo',
		'qvp',
		'qvs',
		'qvw',
		'qvy',
		'qvz',
		'qwa',
		'qwc',
		'qwe',
		'qwh',
		'qwm',
		'qws',
		'qwt',
		'qxa',
		'qxc',
		'qxh',
		'qxl',
		'qxn',
		'qxo',
		'qxp',
		'qxq',
		'qxr',
		'qxs',
		'qxt',
		'qxu',
		'qxw',
		'qya',
		'qyp',
		'raa',
		'rab',
		'rac',
		'rad',
		'raf',
		'rag',
		'rah',
		'rai',
		'raj',
		'rak',
		'ral',
		'ram',
		'ran',
		'rao',
		'rap',
		'raq',
		'rar',
		'ras',
		'rat',
		'rau',
		'rav',
		'raw',
		'rax',
		'ray',
		'raz',
		'rbb',
		'rbk',
		'rbl',
		'rbp',
		'rcf',
		'rdb',
		'rea',
		'reb',
		'ree',
		'reg',
		'rei',
		'rej',
		'rel',
		'rem',
		'ren',
		'rer',
		'res',
		'ret',
		'rey',
		'rga',
		'rge',
		'rgk',
		'rgn',
		'rgr',
		'rgs',
		'rgu',
		'rhg',
		'rhp',
		'ria',
		'rie',
		'rif',
		'ril',
		'rim',
		'rin',
		'rir',
		'rit',
		'riu',
		'rjg',
		'rji',
		'rjs',
		'rka',
		'rkb',
		'rkh',
		'rki',
		'rkm',
		'rkt',
		'rkw',
		'rma',
		'rmb',
		'rmc',
		'rmd',
		'rme',
		'rmf',
		'rmg',
		'rmh',
		'rmi',
		'rmk',
		'rml',
		'rmm',
		'rmn',
		'rmo',
		'rmp',
		'rmq',
		'rmr',
		'rms',
		'rmt',
		'rmu',
		'rmv',
		'rmw',
		'rmx',
		'rmy',
		'rmz',
		'rna',
		'rnd',
		'rng',
		'rnl',
		'rnn',
		'rnp',
		'rnr',
		'rnw',
		'roa',
		'rob',
		'roc',
		'rod',
		'roe',
		'rof',
		'rog',
		'rol',
		'rom',
		'roo',
		'rop',
		'ror',
		'rou',
		'row',
		'rpn',
		'rpt',
		'rri',
		'rro',
		'rrt',
		'rsb',
		'rsi',
		'rsl',
		'rsm',
		'rtc',
		'rth',
		'rtm',
		'rts',
		'rtw',
		'rub',
		'ruc',
		'rue',
		'ruf',
		'rug',
		'ruh',
		'rui',
		'ruk',
		'ruo',
		'rup',
		'ruq',
		'rut',
		'ruu',
		'ruy',
		'ruz',
		'rwa',
		'rwk',
		'rwm',
		'rwo',
		'rwr',
		'rxd',
		'rxw',
		'ryn',
		'rys',
		'ryu',
		'rzh',
		'saa',
		'sab',
		'sac',
		'sad',
		'sae',
		'saf',
		'sah',
		'sai',
		'saj',
		'sak',
		'sal',
		'sam',
		'sao',
		'sap',
		'saq',
		'sar',
		'sas',
		'sat',
		'sau',
		'sav',
		'saw',
		'sax',
		'say',
		'saz',
		'sba',
		'sbb',
		'sbc',
		'sbd',
		'sbe',
		'sbf',
		'sbg',
		'sbh',
		'sbi',
		'sbj',
		'sbk',
		'sbl',
		'sbm',
		'sbn',
		'sbo',
		'sbp',
		'sbq',
		'sbr',
		'sbs',
		'sbt',
		'sbu',
		'sbv',
		'sbw',
		'sbx',
		'sby',
		'sbz',
		'sca',
		'scb',
		'sce',
		'scf',
		'scg',
		'sch',
		'sci',
		'sck',
		'scl',
		'scn',
		'sco',
		'scp',
		'scq',
		'scs',
		'sct',
		'scu',
		'scv',
		'scw',
		'scx',
		'sda',
		'sdb',
		'sdc',
		'sde',
		'sdf',
		'sdg',
		'sdh',
		'sdj',
		'sdk',
		'sdl',
		'sdm',
		'sdn',
		'sdo',
		'sdp',
		'sdr',
		'sds',
		'sdt',
		'sdu',
		'sdv',
		'sdx',
		'sdz',
		'sea',
		'seb',
		'sec',
		'sed',
		'see',
		'sef',
		'seg',
		'seh',
		'sei',
		'sej',
		'sek',
		'sel',
		'sem',
		'sen',
		'seo',
		'sep',
		'seq',
		'ser',
		'ses',
		'set',
		'seu',
		'sev',
		'sew',
		'sey',
		'sez',
		'sfb',
		'sfe',
		'sfm',
		'sfs',
		'sfw',
		'sga',
		'sgb',
		'sgc',
		'sgd',
		'sge',
		'sgg',
		'sgh',
		'sgi',
		'sgj',
		'sgk',
		'sgl',
		'sgm',
		'sgn',
		'sgo',
		'sgp',
		'sgr',
		'sgs',
		'sgt',
		'sgu',
		'sgw',
		'sgx',
		'sgy',
		'sgz',
		'sha',
		'shb',
		'shc',
		'shd',
		'she',
		'shg',
		'shh',
		'shi',
		'shj',
		'shk',
		'shl',
		'shm',
		'shn',
		'sho',
		'shp',
		'shq',
		'shr',
		'shs',
		'sht',
		'shu',
		'shv',
		'shw',
		'shx',
		'shy',
		'shz',
		'sia',
		'sib',
		'sid',
		'sie',
		'sif',
		'sig',
		'sih',
		'sii',
		'sij',
		'sik',
		'sil',
		'sim',
		'sio',
		'sip',
		'siq',
		'sir',
		'sis',
		'sit',
		'siu',
		'siv',
		'siw',
		'six',
		'siy',
		'siz',
		'sja',
		'sjb',
		'sjd',
		'sje',
		'sjg',
		'sjk',
		'sjl',
		'sjm',
		'sjn',
		'sjo',
		'sjp',
		'sjr',
		'sjs',
		'sjt',
		'sju',
		'sjw',
		'ska',
		'skb',
		'skc',
		'skd',
		'ske',
		'skf',
		'skg',
		'skh',
		'ski',
		'skj',
		'skk',
		'skm',
		'skn',
		'sko',
		'skp',
		'skq',
		'skr',
		'sks',
		'skt',
		'sku',
		'skv',
		'skw',
		'skx',
		'sky',
		'skz',
		'sla',
		'slc',
		'sld',
		'sle',
		'slf',
		'slg',
		'slh',
		'sli',
		'slj',
		'sll',
		'slm',
		'sln',
		'slp',
		'slq',
		'slr',
		'sls',
		'slt',
		'slu',
		'slw',
		'slx',
		'sly',
		'slz',
		'sma',
		'smb',
		'smc',
		'smd',
		'smf',
		'smg',
		'smh',
		'smi',
		'smj',
		'smk',
		'sml',
		'smm',
		'smn',
		'smp',
		'smq',
		'smr',
		'sms',
		'smt',
		'smu',
		'smv',
		'smw',
		'smx',
		'smy',
		'smz',
		'snb',
		'snc',
		'sne',
		'snf',
		'sng',
		'snh',
		'sni',
		'snj',
		'snk',
		'snl',
		'snm',
		'snn',
		'sno',
		'snp',
		'snq',
		'snr',
		'sns',
		'snu',
		'snv',
		'snw',
		'snx',
		'sny',
		'snz',
		'soa',
		'sob',
		'soc',
		'sod',
		'soe',
		'sog',
		'soh',
		'soi',
		'soj',
		'sok',
		'sol',
		'son',
		'soo',
		'sop',
		'soq',
		'sor',
		'sos',
		'sou',
		'sov',
		'sow',
		'sox',
		'soy',
		'soz',
		'spb',
		'spc',
		'spd',
		'spe',
		'spg',
		'spi',
		'spk',
		'spl',
		'spm',
		'spn',
		'spo',
		'spp',
		'spq',
		'spr',
		'sps',
		'spt',
		'spu',
		'spv',
		'spx',
		'spy',
		'sqa',
		'sqh',
		'sqj',
		'sqk',
		'sqm',
		'sqn',
		'sqo',
		'sqq',
		'sqr',
		'sqs',
		'sqt',
		'squ',
		'sra',
		'srb',
		'src',
		'sre',
		'srf',
		'srg',
		'srh',
		'sri',
		'srk',
		'srl',
		'srm',
		'srn',
		'sro',
		'srq',
		'srr',
		'srs',
		'srt',
		'sru',
		'srv',
		'srw',
		'srx',
		'sry',
		'srz',
		'ssa',
		'ssb',
		'ssc',
		'ssd',
		'sse',
		'ssf',
		'ssg',
		'ssh',
		'ssi',
		'ssj',
		'ssk',
		'ssl',
		'ssm',
		'ssn',
		'sso',
		'ssp',
		'ssq',
		'ssr',
		'sss',
		'sst',
		'ssu',
		'ssv',
		'ssx',
		'ssy',
		'ssz',
		'sta',
		'stb',
		'std',
		'ste',
		'stf',
		'stg',
		'sth',
		'sti',
		'stj',
		'stk',
		'stl',
		'stm',
		'stn',
		'sto',
		'stp',
		'stq',
		'str',
		'sts',
		'stt',
		'stu',
		'stv',
		'stw',
		'sty',
		'sua',
		'sub',
		'suc',
		'sue',
		'sug',
		'sui',
		'suj',
		'suk',
		'sul',
		'sum',
		'suq',
		'sur',
		'sus',
		'sut',
		'suv',
		'suw',
		'sux',
		'suy',
		'suz',
		'sva',
		'svb',
		'svc',
		'sve',
		'svk',
		'svm',
		'svr',
		'svs',
		'svx',
		'swb',
		'swc',
		'swf',
		'swg',
		'swh',
		'swi',
		'swj',
		'swk',
		'swl',
		'swm',
		'swn',
		'swo',
		'swp',
		'swq',
		'swr',
		'sws',
		'swt',
		'swu',
		'swv',
		'sww',
		'swx',
		'swy',
		'sxb',
		'sxc',
		'sxe',
		'sxg',
		'sxk',
		'sxl',
		'sxm',
		'sxn',
		'sxo',
		'sxr',
		'sxs',
		'sxu',
		'sxw',
		'sya',
		'syb',
		'syc',
		'syd',
		'syi',
		'syk',
		'syl',
		'sym',
		'syn',
		'syo',
		'syr',
		'sys',
		'syw',
		'syx',
		'syy',
		'sza',
		'szb',
		'szc',
		'szd',
		'sze',
		'szg',
		'szl',
		'szn',
		'szp',
		'szs',
		'szv',
		'szw',
		'taa',
		'tab',
		'tac',
		'tad',
		'tae',
		'taf',
		'tag',
		'tai',
		'taj',
		'tak',
		'tal',
		'tan',
		'tao',
		'tap',
		'taq',
		'tar',
		'tas',
		'tau',
		'tav',
		'taw',
		'tax',
		'tay',
		'taz',
		'tba',
		'tbb',
		'tbc',
		'tbd',
		'tbe',
		'tbf',
		'tbg',
		'tbh',
		'tbi',
		'tbj',
		'tbk',
		'tbl',
		'tbm',
		'tbn',
		'tbo',
		'tbp',
		'tbq',
		'tbr',
		'tbs',
		'tbt',
		'tbu',
		'tbv',
		'tbw',
		'tbx',
		'tby',
		'tbz',
		'tca',
		'tcb',
		'tcc',
		'tcd',
		'tce',
		'tcf',
		'tcg',
		'tch',
		'tci',
		'tck',
		'tcl',
		'tcm',
		'tcn',
		'tco',
		'tcp',
		'tcq',
		'tcs',
		'tct',
		'tcu',
		'tcw',
		'tcx',
		'tcy',
		'tcz',
		'tda',
		'tdb',
		'tdc',
		'tdd',
		'tde',
		'tdf',
		'tdg',
		'tdh',
		'tdi',
		'tdj',
		'tdk',
		'tdl',
		'tdm',
		'tdn',
		'tdo',
		'tdq',
		'tdr',
		'tds',
		'tdt',
		'tdu',
		'tdv',
		'tdx',
		'tdy',
		'tea',
		'teb',
		'tec',
		'ted',
		'tee',
		'tef',
		'teg',
		'teh',
		'tei',
		'tek',
		'tem',
		'ten',
		'teo',
		'tep',
		'teq',
		'ter',
		'tes',
		'tet',
		'teu',
		'tev',
		'tew',
		'tex',
		'tey',
		'tez',
		'tfi',
		'tfn',
		'tfo',
		'tfr',
		'tft',
		'tga',
		'tgb',
		'tgc',
		'tgd',
		'tge',
		'tgf',
		'tgg',
		'tgh',
		'tgi',
		'tgj',
		'tgn',
		'tgo',
		'tgp',
		'tgq',
		'tgr',
		'tgs',
		'tgt',
		'tgu',
		'tgv',
		'tgw',
		'tgx',
		'tgy',
		'tgz',
		'thc',
		'thd',
		'the',
		'thf',
		'thh',
		'thi',
		'thk',
		'thl',
		'thm',
		'thn',
		'thp',
		'thq',
		'thr',
		'ths',
		'tht',
		'thu',
		'thv',
		'thw',
		'thx',
		'thy',
		'thz',
		'tia',
		'tic',
		'tid',
		'tie',
		'tif',
		'tig',
		'tih',
		'tii',
		'tij',
		'tik',
		'til',
		'tim',
		'tin',
		'tio',
		'tip',
		'tiq',
		'tis',
		'tit',
		'tiu',
		'tiv',
		'tiw',
		'tix',
		'tiy',
		'tiz',
		'tja',
		'tjg',
		'tji',
		'tjl',
		'tjm',
		'tjn',
		'tjo',
		'tjs',
		'tju',
		'tjw',
		'tka',
		'tkb',
		'tkd',
		'tke',
		'tkf',
		'tkg',
		'tkk',
		'tkl',
		'tkm',
		'tkn',
		'tkp',
		'tkq',
		'tkr',
		'tks',
		'tkt',
		'tku',
		'tkv',
		'tkw',
		'tkx',
		'tkz',
		'tla',
		'tlb',
		'tlc',
		'tld',
		'tlf',
		'tlg',
		'tlh',
		'tli',
		'tlj',
		'tlk',
		'tll',
		'tlm',
		'tln',
		'tlo',
		'tlp',
		'tlq',
		'tlr',
		'tls',
		'tlt',
		'tlu',
		'tlv',
		'tlw',
		'tlx',
		'tly',
		'tma',
		'tmb',
		'tmc',
		'tmd',
		'tme',
		'tmf',
		'tmg',
		'tmh',
		'tmi',
		'tmj',
		'tmk',
		'tml',
		'tmm',
		'tmn',
		'tmo',
		'tmp',
		'tmq',
		'tmr',
		'tms',
		'tmt',
		'tmu',
		'tmv',
		'tmw',
		'tmy',
		'tmz',
		'tna',
		'tnb',
		'tnc',
		'tnd',
		'tne',
		'tnf',
		'tng',
		'tnh',
		'tni',
		'tnk',
		'tnl',
		'tnm',
		'tnn',
		'tno',
		'tnp',
		'tnq',
		'tnr',
		'tns',
		'tnt',
		'tnu',
		'tnv',
		'tnw',
		'tnx',
		'tny',
		'tnz',
		'tob',
		'toc',
		'tod',
		'toe',
		'tof',
		'tog',
		'toh',
		'toi',
		'toj',
		'tol',
		'tom',
		'too',
		'top',
		'toq',
		'tor',
		'tos',
		'tou',
		'tov',
		'tow',
		'tox',
		'toy',
		'toz',
		'tpa',
		'tpc',
		'tpe',
		'tpf',
		'tpg',
		'tpi',
		'tpj',
		'tpk',
		'tpl',
		'tpm',
		'tpn',
		'tpo',
		'tpp',
		'tpq',
		'tpr',
		'tpt',
		'tpu',
		'tpv',
		'tpw',
		'tpx',
		'tpy',
		'tpz',
		'tqb',
		'tql',
		'tqm',
		'tqn',
		'tqo',
		'tqp',
		'tqq',
		'tqr',
		'tqt',
		'tqu',
		'tqw',
		'tra',
		'trb',
		'trc',
		'trd',
		'tre',
		'trf',
		'trg',
		'trh',
		'tri',
		'trj',
		'trk',
		'trl',
		'trm',
		'trn',
		'tro',
		'trp',
		'trq',
		'trr',
		'trs',
		'trt',
		'tru',
		'trv',
		'trw',
		'trx',
		'try',
		'trz',
		'tsa',
		'tsb',
		'tsc',
		'tsd',
		'tse',
		'tsf',
		'tsg',
		'tsh',
		'tsi',
		'tsj',
		'tsk',
		'tsl',
		'tsm',
		'tsp',
		'tsq',
		'tsr',
		'tss',
		'tst',
		'tsu',
		'tsv',
		'tsw',
		'tsx',
		'tsy',
		'tsz',
		'tta',
		'ttb',
		'ttc',
		'ttd',
		'tte',
		'ttf',
		'ttg',
		'tth',
		'tti',
		'ttj',
		'ttk',
		'ttl',
		'ttm',
		'ttn',
		'tto',
		'ttp',
		'ttq',
		'ttr',
		'tts',
		'ttt',
		'ttu',
		'ttv',
		'ttw',
		'tty',
		'ttz',
		'tua',
		'tub',
		'tuc',
		'tud',
		'tue',
		'tuf',
		'tug',
		'tuh',
		'tui',
		'tuj',
		'tul',
		'tum',
		'tun',
		'tuo',
		'tup',
		'tuq',
		'tus',
		'tut',
		'tuu',
		'tuv',
		'tuw',
		'tux',
		'tuy',
		'tuz',
		'tva',
		'tvd',
		'tve',
		'tvk',
		'tvl',
		'tvm',
		'tvn',
		'tvo',
		'tvs',
		'tvt',
		'tvu',
		'tvw',
		'tvy',
		'twa',
		'twb',
		'twc',
		'twd',
		'twe',
		'twf',
		'twg',
		'twh',
		'twl',
		'twm',
		'twn',
		'two',
		'twp',
		'twq',
		'twr',
		'twt',
		'twu',
		'tww',
		'twx',
		'twy',
		'txa',
		'txb',
		'txc',
		'txe',
		'txg',
		'txh',
		'txi',
		'txj',
		'txm',
		'txn',
		'txo',
		'txq',
		'txr',
		'txs',
		'txt',
		'txu',
		'txx',
		'txy',
		'tya',
		'tye',
		'tyh',
		'tyi',
		'tyj',
		'tyl',
		'tyn',
		'typ',
		'tyr',
		'tys',
		'tyt',
		'tyu',
		'tyv',
		'tyx',
		'tyz',
		'tza',
		'tzh',
		'tzj',
		'tzl',
		'tzm',
		'tzn',
		'tzo',
		'tzx',
		'uam',
		'uan',
		'uar',
		'uba',
		'ubi',
		'ubl',
		'ubr',
		'ubu',
		'uby',
		'uda',
		'ude',
		'udg',
		'udi',
		'udj',
		'udl',
		'udm',
		'udu',
		'ues',
		'ufi',
		'uga',
		'ugb',
		'uge',
		'ugn',
		'ugo',
		'ugy',
		'uha',
		'uhn',
		'uis',
		'uiv',
		'uji',
		'uka',
		'ukg',
		'ukh',
		'ukk',
		'ukl',
		'ukp',
		'ukq',
		'uks',
		'uku',
		'ukw',
		'uky',
		'ula',
		'ulb',
		'ulc',
		'ule',
		'ulf',
		'uli',
		'ulk',
		'ull',
		'ulm',
		'uln',
		'ulu',
		'ulw',
		'uma',
		'umb',
		'umc',
		'umd',
		'umg',
		'umi',
		'umm',
		'umn',
		'umo',
		'ump',
		'umr',
		'ums',
		'umu',
		'una',
		'und',
		'une',
		'ung',
		'unk',
		'unm',
		'unn',
		'unp',
		'unr',
		'unu',
		'unx',
		'unz',
		'uok',
		'upi',
		'upv',
		'ura',
		'urb',
		'urc',
		'ure',
		'urf',
		'urg',
		'urh',
		'uri',
		'urj',
		'urk',
		'url',
		'urm',
		'urn',
		'uro',
		'urp',
		'urr',
		'urt',
		'uru',
		'urv',
		'urw',
		'urx',
		'ury',
		'urz',
		'usa',
		'ush',
		'usi',
		'usk',
		'usp',
		'usu',
		'uta',
		'ute',
		'utp',
		'utr',
		'utu',
		'uum',
		'uun',
		'uur',
		'uuu',
		'uve',
		'uvh',
		'uvl',
		'uwa',
		'uya',
		'uzn',
		'uzs',
		'vaa',
		'vae',
		'vaf',
		'vag',
		'vah',
		'vai',
		'vaj',
		'val',
		'vam',
		'van',
		'vao',
		'vap',
		'var',
		'vas',
		'vau',
		'vav',
		'vay',
		'vbb',
		'vbk',
		'vec',
		'ved',
		'vel',
		'vem',
		'veo',
		'vep',
		'ver',
		'vgr',
		'vgt',
		'vic',
		'vid',
		'vif',
		'vig',
		'vil',
		'vin',
		'vis',
		'vit',
		'viv',
		'vka',
		'vki',
		'vkj',
		'vkk',
		'vkl',
		'vkm',
		'vko',
		'vkp',
		'vkt',
		'vku',
		'vlp',
		'vls',
		'vma',
		'vmb',
		'vmc',
		'vmd',
		'vme',
		'vmf',
		'vmg',
		'vmh',
		'vmi',
		'vmj',
		'vmk',
		'vml',
		'vmm',
		'vmp',
		'vmq',
		'vmr',
		'vms',
		'vmu',
		'vmv',
		'vmw',
		'vmx',
		'vmy',
		'vmz',
		'vnk',
		'vnm',
		'vnp',
		'vor',
		'vot',
		'vra',
		'vro',
		'vrs',
		'vrt',
		'vsi',
		'vsl',
		'vsv',
		'vto',
		'vum',
		'vun',
		'vut',
		'vwa',
		'waa',
		'wab',
		'wac',
		'wad',
		'wae',
		'waf',
		'wag',
		'wah',
		'wai',
		'waj',
		'wak',
		'wal',
		'wam',
		'wan',
		'wao',
		'wap',
		'waq',
		'war',
		'was',
		'wat',
		'wau',
		'wav',
		'waw',
		'wax',
		'way',
		'waz',
		'wba',
		'wbb',
		'wbe',
		'wbf',
		'wbh',
		'wbi',
		'wbj',
		'wbk',
		'wbl',
		'wbm',
		'wbp',
		'wbq',
		'wbr',
		'wbs',
		'wbt',
		'wbv',
		'wbw',
		'wca',
		'wci',
		'wdd',
		'wdg',
		'wdj',
		'wdk',
		'wdu',
		'wdy',
		'wea',
		'wec',
		'wed',
		'weg',
		'weh',
		'wei',
		'wem',
		'wen',
		'weo',
		'wep',
		'wer',
		'wes',
		'wet',
		'weu',
		'wew',
		'wfg',
		'wga',
		'wgb',
		'wgg',
		'wgi',
		'wgo',
		'wgu',
		'wgw',
		'wgy',
		'wha',
		'whg',
		'whk',
		'whu',
		'wib',
		'wic',
		'wie',
		'wif',
		'wig',
		'wih',
		'wii',
		'wij',
		'wik',
		'wil',
		'wim',
		'win',
		'wir',
		'wit',
		'wiu',
		'wiv',
		'wiw',
		'wiy',
		'wja',
		'wji',
		'wka',
		'wkb',
		'wkd',
		'wkl',
		'wku',
		'wkw',
		'wky',
		'wla',
		'wlc',
		'wle',
		'wlg',
		'wli',
		'wlk',
		'wll',
		'wlm',
		'wlo',
		'wlr',
		'wls',
		'wlu',
		'wlv',
		'wlw',
		'wlx',
		'wly',
		'wma',
		'wmb',
		'wmc',
		'wmd',
		'wme',
		'wmh',
		'wmi',
		'wmm',
		'wmn',
		'wmo',
		'wms',
		'wmt',
		'wmw',
		'wmx',
		'wnb',
		'wnc',
		'wnd',
		'wne',
		'wng',
		'wni',
		'wnk',
		'wnm',
		'wnn',
		'wno',
		'wnp',
		'wnu',
		'wnw',
		'wny',
		'woa',
		'wob',
		'woc',
		'wod',
		'woe',
		'wof',
		'wog',
		'woi',
		'wok',
		'wom',
		'won',
		'woo',
		'wor',
		'wos',
		'wow',
		'woy',
		'wpc',
		'wra',
		'wrb',
		'wrd',
		'wrg',
		'wrh',
		'wri',
		'wrk',
		'wrl',
		'wrm',
		'wrn',
		'wro',
		'wrp',
		'wrr',
		'wrs',
		'wru',
		'wrv',
		'wrw',
		'wrx',
		'wry',
		'wrz',
		'wsa',
		'wsg',
		'wsi',
		'wsk',
		'wsr',
		'wss',
		'wsu',
		'wsv',
		'wtf',
		'wth',
		'wti',
		'wtk',
		'wtm',
		'wtw',
		'wua',
		'wub',
		'wud',
		'wuh',
		'wul',
		'wum',
		'wun',
		'wur',
		'wut',
		'wuu',
		'wuv',
		'wux',
		'wuy',
		'wwa',
		'wwb',
		'wwo',
		'wwr',
		'www',
		'wxa',
		'wxw',
		'wya',
		'wyb',
		'wyi',
		'wym',
		'wyr',
		'wyy',
		'xaa',
		'xab',
		'xac',
		'xad',
		'xae',
		'xag',
		'xai',
		'xaj',
		'xak',
		'xal',
		'xam',
		'xan',
		'xao',
		'xap',
		'xaq',
		'xar',
		'xas',
		'xat',
		'xau',
		'xav',
		'xaw',
		'xay',
		'xba',
		'xbb',
		'xbc',
		'xbd',
		'xbe',
		'xbg',
		'xbi',
		'xbj',
		'xbm',
		'xbn',
		'xbo',
		'xbp',
		'xbr',
		'xbw',
		'xbx',
		'xby',
		'xcb',
		'xcc',
		'xce',
		'xcg',
		'xch',
		'xcl',
		'xcm',
		'xcn',
		'xco',
		'xcr',
		'xct',
		'xcu',
		'xcv',
		'xcw',
		'xcy',
		'xda',
		'xdc',
		'xdk',
		'xdm',
		'xdo',
		'xdy',
		'xeb',
		'xed',
		'xeg',
		'xel',
		'xem',
		'xep',
		'xer',
		'xes',
		'xet',
		'xeu',
		'xfa',
		'xga',
		'xgb',
		'xgd',
		'xgf',
		'xgg',
		'xgi',
		'xgl',
		'xgm',
		'xgn',
		'xgr',
		'xgu',
		'xgw',
		'xha',
		'xhc',
		'xhd',
		'xhe',
		'xhr',
		'xht',
		'xhu',
		'xhv',
		'xia',
		'xib',
		'xii',
		'xil',
		'xin',
		'xip',
		'xir',
		'xis',
		'xiv',
		'xiy',
		'xjb',
		'xjt',
		'xka',
		'xkb',
		'xkc',
		'xkd',
		'xke',
		'xkf',
		'xkg',
		'xkh',
		'xki',
		'xkj',
		'xkk',
		'xkl',
		'xkn',
		'xko',
		'xkp',
		'xkq',
		'xkr',
		'xks',
		'xkt',
		'xku',
		'xkv',
		'xkw',
		'xkx',
		'xky',
		'xkz',
		'xla',
		'xlb',
		'xlc',
		'xld',
		'xle',
		'xlg',
		'xli',
		'xln',
		'xlo',
		'xlp',
		'xls',
		'xlu',
		'xly',
		'xma',
		'xmb',
		'xmc',
		'xmd',
		'xme',
		'xmf',
		'xmg',
		'xmh',
		'xmj',
		'xmk',
		'xml',
		'xmm',
		'xmn',
		'xmo',
		'xmp',
		'xmq',
		'xmr',
		'xms',
		'xmt',
		'xmu',
		'xmv',
		'xmw',
		'xmx',
		'xmy',
		'xmz',
		'xna',
		'xnb',
		'xnd',
		'xng',
		'xnh',
		'xni',
		'xnk',
		'xnn',
		'xno',
		'xnr',
		'xns',
		'xnt',
		'xnu',
		'xny',
		'xnz',
		'xoc',
		'xod',
		'xog',
		'xoi',
		'xok',
		'xom',
		'xon',
		'xoo',
		'xop',
		'xor',
		'xow',
		'xpa',
		'xpc',
		'xpe',
		'xpg',
		'xpi',
		'xpj',
		'xpk',
		'xpm',
		'xpn',
		'xpo',
		'xpp',
		'xpq',
		'xpr',
		'xps',
		'xpt',
		'xpu',
		'xpy',
		'xqa',
		'xqt',
		'xra',
		'xrb',
		'xrd',
		'xre',
		'xrg',
		'xri',
		'xrm',
		'xrn',
		'xrq',
		'xrr',
		'xrt',
		'xru',
		'xrw',
		'xsa',
		'xsb',
		'xsc',
		'xsd',
		'xse',
		'xsh',
		'xsi',
		'xsj',
		'xsl',
		'xsm',
		'xsn',
		'xso',
		'xsp',
		'xsq',
		'xsr',
		'xss',
		'xsu',
		'xsv',
		'xsy',
		'xta',
		'xtb',
		'xtc',
		'xtd',
		'xte',
		'xtg',
		'xth',
		'xti',
		'xtj',
		'xtl',
		'xtm',
		'xtn',
		'xto',
		'xtp',
		'xtq',
		'xtr',
		'xts',
		'xtt',
		'xtu',
		'xtv',
		'xtw',
		'xty',
		'xtz',
		'xua',
		'xub',
		'xud',
		'xug',
		'xuj',
		'xul',
		'xum',
		'xun',
		'xuo',
		'xup',
		'xur',
		'xut',
		'xuu',
		'xve',
		'xvi',
		'xvn',
		'xvo',
		'xvs',
		'xwa',
		'xwc',
		'xwd',
		'xwe',
		'xwg',
		'xwj',
		'xwk',
		'xwl',
		'xwo',
		'xwr',
		'xwt',
		'xww',
		'xxb',
		'xxk',
		'xxm',
		'xxr',
		'xxt',
		'xya',
		'xyb',
		'xyj',
		'xyk',
		'xyl',
		'xyt',
		'xyy',
		'xzh',
		'xzm',
		'xzp',
		'yaa',
		'yab',
		'yac',
		'yad',
		'yae',
		'yaf',
		'yag',
		'yah',
		'yai',
		'yaj',
		'yak',
		'yal',
		'yam',
		'yan',
		'yao',
		'yap',
		'yaq',
		'yar',
		'yas',
		'yat',
		'yau',
		'yav',
		'yaw',
		'yax',
		'yay',
		'yaz',
		'yba',
		'ybb',
		'ybd',
		'ybe',
		'ybh',
		'ybi',
		'ybj',
		'ybk',
		'ybl',
		'ybm',
		'ybn',
		'ybo',
		'ybx',
		'yby',
		'ych',
		'ycl',
		'ycn',
		'ycp',
		'yda',
		'ydd',
		'yde',
		'ydg',
		'ydk',
		'yds',
		'yea',
		'yec',
		'yee',
		'yei',
		'yej',
		'yel',
		'yen',
		'yer',
		'yes',
		'yet',
		'yeu',
		'yev',
		'yey',
		'yga',
		'ygi',
		'ygl',
		'ygm',
		'ygp',
		'ygr',
		'ygs',
		'ygu',
		'ygw',
		'yha',
		'yhd',
		'yhl',
		'yhs',
		'yia',
		'yif',
		'yig',
		'yih',
		'yii',
		'yij',
		'yik',
		'yil',
		'yim',
		'yin',
		'yip',
		'yiq',
		'yir',
		'yis',
		'yit',
		'yiu',
		'yiv',
		'yix',
		'yiy',
		'yiz',
		'yka',
		'ykg',
		'yki',
		'ykk',
		'ykl',
		'ykm',
		'ykn',
		'yko',
		'ykr',
		'ykt',
		'yku',
		'yky',
		'yla',
		'ylb',
		'yle',
		'ylg',
		'yli',
		'yll',
		'ylm',
		'yln',
		'ylo',
		'ylr',
		'ylu',
		'yly',
		'yma',
		'ymb',
		'ymc',
		'ymd',
		'yme',
		'ymg',
		'ymh',
		'ymi',
		'ymk',
		'yml',
		'ymm',
		'ymn',
		'ymo',
		'ymp',
		'ymq',
		'ymr',
		'yms',
		'ymt',
		'ymx',
		'ymz',
		'yna',
		'ynd',
		'yne',
		'yng',
		'ynh',
		'ynk',
		'ynl',
		'ynn',
		'yno',
		'ynq',
		'yns',
		'ynu',
		'yob',
		'yog',
		'yoi',
		'yok',
		'yol',
		'yom',
		'yon',
		'yos',
		'yot',
		'yox',
		'yoy',
		'ypa',
		'ypb',
		'ypg',
		'yph',
		'ypk',
		'ypm',
		'ypn',
		'ypo',
		'ypp',
		'ypz',
		'yra',
		'yrb',
		'yre',
		'yri',
		'yrk',
		'yrl',
		'yrm',
		'yrn',
		'yro',
		'yrs',
		'yrw',
		'yry',
		'ysc',
		'ysd',
		'ysg',
		'ysl',
		'ysn',
		'yso',
		'ysp',
		'ysr',
		'yss',
		'ysy',
		'yta',
		'ytl',
		'ytp',
		'ytw',
		'yty',
		'yua',
		'yub',
		'yuc',
		'yud',
		'yue',
		'yuf',
		'yug',
		'yui',
		'yuj',
		'yuk',
		'yul',
		'yum',
		'yun',
		'yup',
		'yuq',
		'yur',
		'yut',
		'yuu',
		'yuw',
		'yux',
		'yuy',
		'yuz',
		'yva',
		'yvt',
		'ywa',
		'ywg',
		'ywl',
		'ywn',
		'ywq',
		'ywr',
		'ywt',
		'ywu',
		'yww',
		'yxa',
		'yxg',
		'yxl',
		'yxm',
		'yxu',
		'yxy',
		'yyr',
		'yyu',
		'yyz',
		'yzg',
		'yzk',
		'zaa',
		'zab',
		'zac',
		'zad',
		'zae',
		'zaf',
		'zag',
		'zah',
		'zai',
		'zaj',
		'zak',
		'zal',
		'zam',
		'zao',
		'zap',
		'zaq',
		'zar',
		'zas',
		'zat',
		'zau',
		'zav',
		'zaw',
		'zax',
		'zay',
		'zaz',
		'zbc',
		'zbe',
		'zbl',
		'zbt',
		'zbw',
		'zca',
		'zch',
		'zdj',
		'zea',
		'zeg',
		'zeh',
		'zen',
		'zga',
		'zgb',
		'zgh',
		'zgm',
		'zgn',
		'zgr',
		'zhb',
		'zhd',
		'zhi',
		'zhn',
		'zhw',
		'zhx',
		'zia',
		'zib',
		'zik',
		'zil',
		'zim',
		'zin',
		'zir',
		'ziw',
		'ziz',
		'zka',
		'zkb',
		'zkd',
		'zkg',
		'zkh',
		'zkk',
		'zkn',
		'zko',
		'zkp',
		'zkr',
		'zkt',
		'zku',
		'zkv',
		'zkz',
		'zle',
		'zlj',
		'zlm',
		'zln',
		'zlq',
		'zls',
		'zlw',
		'zma',
		'zmb',
		'zmc',
		'zmd',
		'zme',
		'zmf',
		'zmg',
		'zmh',
		'zmi',
		'zmj',
		'zmk',
		'zml',
		'zmm',
		'zmn',
		'zmo',
		'zmp',
		'zmq',
		'zmr',
		'zms',
		'zmt',
		'zmu',
		'zmv',
		'zmw',
		'zmx',
		'zmy',
		'zmz',
		'zna',
		'znd',
		'zne',
		'zng',
		'znk',
		'zns',
		'zoc',
		'zoh',
		'zom',
		'zoo',
		'zoq',
		'zor',
		'zos',
		'zpa',
		'zpb',
		'zpc',
		'zpd',
		'zpe',
		'zpf',
		'zpg',
		'zph',
		'zpi',
		'zpj',
		'zpk',
		'zpl',
		'zpm',
		'zpn',
		'zpo',
		'zpp',
		'zpq',
		'zpr',
		'zps',
		'zpt',
		'zpu',
		'zpv',
		'zpw',
		'zpx',
		'zpy',
		'zpz',
		'zqe',
		'zra',
		'zrg',
		'zrn',
		'zro',
		'zrp',
		'zrs',
		'zsa',
		'zsk',
		'zsl',
		'zsm',
		'zsr',
		'zsu',
		'zte',
		'ztg',
		'ztl',
		'ztm',
		'ztn',
		'ztp',
		'ztq',
		'zts',
		'ztt',
		'ztu',
		'ztx',
		'zty',
		'zua',
		'zuh',
		'zum',
		'zun',
		'zuy',
		'zwa',
		'zxx',
		'zyb',
		'zyg',
		'zyj',
		'zyn',
		'zyp',
		'zza',
		'zzj'
	];
	/**
	 * Returns array of valid language codes
	 * @method validLangs
	 * @memberof axe.utils
	 * @return {Array<Sting>} Valid language codes
	 */

	axe.utils.validLangs = function() {
		'use strict';

		return langs;
	};

	('use strict');

	function _extends() {
		_extends =
			Object.assign ||
			function(target) {
				for (var i = 1; i < arguments.length; i++) {
					var source = arguments[i];
					for (var key in source) {
						if (Object.prototype.hasOwnProperty.call(source, key)) {
							target[key] = source[key];
						}
					}
				}
				return target;
			};
		return _extends.apply(this, arguments);
	}

	function _toConsumableArray(arr) {
		return (
			_arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
		);
	}

	function _nonIterableSpread() {
		throw new TypeError('Invalid attempt to spread non-iterable instance');
	}

	function _iterableToArray(iter) {
		if (
			Symbol.iterator in Object(iter) ||
			Object.prototype.toString.call(iter) === '[object Arguments]'
		)
			return Array.from(iter);
	}

	function _arrayWithoutHoles(arr) {
		if (Array.isArray(arr)) {
			for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
				arr2[i] = arr[i];
			}
			return arr2;
		}
	}

	function _slicedToArray(arr, i) {
		return (
			_arrayWithHoles(arr) ||
			_iterableToArrayLimit(arr, i) ||
			_nonIterableRest()
		);
	}

	function _nonIterableRest() {
		throw new TypeError('Invalid attempt to destructure non-iterable instance');
	}

	function _iterableToArrayLimit(arr, i) {
		if (
			!(
				Symbol.iterator in Object(arr) ||
				Object.prototype.toString.call(arr) === '[object Arguments]'
			)
		) {
			return;
		}
		var _arr = [];
		var _n = true;
		var _d = false;
		var _e = undefined;
		try {
			for (
				var _i = arr[Symbol.iterator](), _s;
				!(_n = (_s = _i.next()).done);
				_n = true
			) {
				_arr.push(_s.value);
				if (i && _arr.length === i) break;
			}
		} catch (err) {
			_d = true;
			_e = err;
		} finally {
			try {
				if (!_n && _i['return'] != null) _i['return']();
			} finally {
				if (_d) throw _e;
			}
		}
		return _arr;
	}

	function _arrayWithHoles(arr) {
		if (Array.isArray(arr)) return arr;
	}

	function _typeof(obj) {
		if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
			_typeof = function _typeof(obj) {
				return typeof obj;
			};
		} else {
			_typeof = function _typeof(obj) {
				return obj &&
					typeof Symbol === 'function' &&
					obj.constructor === Symbol &&
					obj !== Symbol.prototype
					? 'symbol'
					: typeof obj;
			};
		}
		return _typeof(obj);
	}

	axe._load({
		lang: 'en',
		data: {
			rules: {
				accesskeys: {
					description: 'Ensures every accesskey attribute value is unique',
					help: 'accesskey attribute value must be unique'
				},
				'area-alt': {
					description:
						'Ensures <area> elements of image maps have alternate text',
					help: 'Active <area> elements must have alternate text'
				},
				'aria-allowed-attr': {
					description:
						"Ensures ARIA attributes are allowed for an element's role",
					help: 'Elements must only use allowed ARIA attributes'
				},
				'aria-allowed-role': {
					description:
						'Ensures role attribute has an appropriate value for the element',
					help: 'ARIA role must be appropriate for the element'
				},
				'aria-dpub-role-fallback': {
					description:
						'Ensures unsupported DPUB roles are only used on elements with implicit fallback roles',
					help:
						'Unsupported DPUB ARIA roles should be used on elements with implicit fallback roles'
				},
				'aria-hidden-body': {
					description:
						"Ensures aria-hidden='true' is not present on the document body.",
					help: "aria-hidden='true' must not be present on the document body"
				},
				'aria-hidden-focus': {
					description:
						'Ensures aria-hidden elements do not contain focusable elements',
					help: 'ARIA hidden element must not contain focusable elements'
				},
				'aria-input-field-name': {
					description: 'Ensures every ARIA input field has an accessible name',
					help: 'ARIA input fields have an accessible name'
				},
				'aria-required-attr': {
					description:
						'Ensures elements with ARIA roles have all required ARIA attributes',
					help: 'Required ARIA attributes must be provided'
				},
				'aria-required-children': {
					description:
						'Ensures elements with an ARIA role that require child roles contain them',
					help: 'Certain ARIA roles must contain particular children'
				},
				'aria-required-parent': {
					description:
						'Ensures elements with an ARIA role that require parent roles are contained by them',
					help: 'Certain ARIA roles must be contained by particular parents'
				},
				'aria-roledescription': {
					description:
						'Ensure aria-roledescription is only used on elements with an implicit or explicit role',
					help: 'Use aria-roledescription on elements with a semantic role'
				},
				'aria-roles': {
					description:
						'Ensures all elements with a role attribute use a valid value',
					help: 'ARIA roles used must conform to valid values'
				},
				'aria-toggle-field-name': {
					description: 'Ensures every ARIA toggle field has an accessible name',
					help: 'ARIA toggle fields have an accessible name'
				},
				'aria-valid-attr-value': {
					description: 'Ensures all ARIA attributes have valid values',
					help: 'ARIA attributes must conform to valid values'
				},
				'aria-valid-attr': {
					description:
						'Ensures attributes that begin with aria- are valid ARIA attributes',
					help: 'ARIA attributes must conform to valid names'
				},
				'audio-caption': {
					description: 'Ensures <audio> elements have captions',
					help: '<audio> elements must have a captions track'
				},
				'autocomplete-valid': {
					description:
						'Ensure the autocomplete attribute is correct and suitable for the form field',
					help: 'autocomplete attribute must be used correctly'
				},
				'avoid-inline-spacing': {
					description:
						'Ensure that text spacing set through style attributes can be adjusted with custom stylesheets',
					help: 'Inline text spacing must be adjustable with custom stylesheets'
				},
				blink: {
					description: 'Ensures <blink> elements are not used',
					help: '<blink> elements are deprecated and must not be used'
				},
				'button-name': {
					description: 'Ensures buttons have discernible text',
					help: 'Buttons must have discernible text'
				},
				bypass: {
					description:
						'Ensures each page has at least one mechanism for a user to bypass navigation and jump straight to the content',
					help: 'Page must have means to bypass repeated blocks'
				},
				checkboxgroup: {
					description:
						'Ensures related <input type="checkbox"> elements have a group and that the group designation is consistent',
					help:
						'Checkbox inputs with the same name attribute value must be part of a group'
				},
				'color-contrast': {
					description:
						'Ensures the contrast between foreground and background colors meets WCAG 2 AA contrast ratio thresholds',
					help: 'Elements must have sufficient color contrast'
				},
				'css-orientation-lock': {
					description:
						'Ensures content is not locked to any specific display orientation, and the content is operable in all display orientations',
					help: 'CSS Media queries are not used to lock display orientation'
				},
				'definition-list': {
					description: 'Ensures <dl> elements are structured correctly',
					help:
						'<dl> elements must only directly contain properly-ordered <dt> and <dd> groups, <script> or <template> elements'
				},
				dlitem: {
					description: 'Ensures <dt> and <dd> elements are contained by a <dl>',
					help: '<dt> and <dd> elements must be contained by a <dl>'
				},
				'document-title': {
					description:
						'Ensures each HTML document contains a non-empty <title> element',
					help: 'Documents must have <title> element to aid in navigation'
				},
				'duplicate-id-active': {
					description:
						'Ensures every id attribute value of active elements is unique',
					help: 'IDs of active elements must be unique'
				},
				'duplicate-id-aria': {
					description:
						'Ensures every id attribute value used in ARIA and in labels is unique',
					help: 'IDs used in ARIA and labels must be unique'
				},
				'duplicate-id': {
					description: 'Ensures every id attribute value is unique',
					help: 'id attribute value must be unique'
				},
				'empty-heading': {
					description: 'Ensures headings have discernible text',
					help: 'Headings must not be empty'
				},
				'filename-is-valid-accessible-name': {
					description:
						'Ensure that image elements that use their source filename as their accessible name do so without loss of information',
					help:
						'Image elements that using filename as accessible name should do so without loss of information'
				},
				'focus-order-semantics': {
					description:
						'Ensures elements in the focus order have an appropriate role',
					help:
						'Elements in the focus order need a role appropriate for interactive content'
				},
				'form-field-multiple-labels': {
					description:
						'Ensures form field does not have multiple label elements',
					help: 'Form field should not have multiple label elements'
				},
				'frame-tested': {
					description:
						'Ensures <iframe> and <frame> elements contain the axe-core script',
					help: 'Frames must be tested with axe-core'
				},
				'frame-title-unique': {
					description:
						'Ensure that <iframe> and <frame> elements with the same accessible name serve a similar purpose',
					help: 'Frames with the same name have a similar purpose'
				},
				'frame-title': {
					description:
						'Ensures <iframe> and <frame> elements contain a non-empty title attribute',
					help: 'Frames must have title attribute'
				},
				'heading-order': {
					description: 'Ensures the order of headings is semantically correct',
					help: 'Heading levels should only increase by one'
				},
				'hidden-content': {
					description: 'Informs users about hidden content.',
					help: 'Hidden content on the page cannot be analyzed'
				},
				'html-has-lang': {
					description: 'Ensures every HTML document has a lang attribute',
					help: '<html> element must have a lang attribute'
				},
				'html-lang-valid': {
					description:
						'Ensures the lang attribute of the <html> element has a valid value',
					help: '<html> element must have a valid value for the lang attribute'
				},
				'html-xml-lang-mismatch': {
					description:
						'Ensure that HTML elements with both valid lang and xml:lang attributes agree on the base language of the page',
					help:
						'HTML elements with lang and xml:lang must have the same base language'
				},
				'identical-links-same-purpose': {
					description:
						'Ensure that links with the same accessible name serve a similar purpose',
					help: 'Links with the same name have a similar purpose'
				},
				'image-alt': {
					description:
						'Ensures <img> elements have alternate text or a role of none or presentation',
					help: 'Images must have alternate text'
				},
				'image-redundant-alt': {
					description: 'Ensure image alternative is not repeated as text',
					help: 'Alternative text of images should not be repeated as text'
				},
				'input-button-name': {
					description: 'Ensures input buttons have discernible text',
					help: 'Input buttons must have discernible text'
				},
				'input-image-alt': {
					description:
						'Ensures <input type="image"> elements have alternate text',
					help: 'Image buttons must have alternate text'
				},
				'label-content-name-mismatch': {
					description:
						'Ensures that elements labelled through their content must have their visible text as part of their accessible name',
					help:
						'Elements must have their visible text as part of their accessible name'
				},
				'label-title-only': {
					description:
						'Ensures that every form element is not solely labeled using the title or aria-describedby attributes',
					help: 'Form elements should have a visible label'
				},
				label: {
					description: 'Ensures every form element has a label',
					help: 'Form elements must have labels'
				},
				'landmark-banner-is-top-level': {
					description: 'Ensures the banner landmark is at top level',
					help: 'Banner landmark must not be contained in another landmark'
				},
				'landmark-complementary-is-top-level': {
					description:
						'Ensures the complementary landmark or aside is at top level',
					help: 'Aside must not be contained in another landmark'
				},
				'landmark-contentinfo-is-top-level': {
					description: 'Ensures the contentinfo landmark is at top level',
					help: 'Contentinfo landmark must not be contained in another landmark'
				},
				'landmark-main-is-top-level': {
					description: 'Ensures the main landmark is at top level',
					help: 'Main landmark must not be contained in another landmark'
				},
				'landmark-no-duplicate-banner': {
					description: 'Ensures the document has at most one banner landmark',
					help: 'Document must not have more than one banner landmark'
				},
				'landmark-no-duplicate-contentinfo': {
					description:
						'Ensures the document has at most one contentinfo landmark',
					help: 'Document must not have more than one contentinfo landmark'
				},
				'landmark-one-main': {
					description:
						'Ensures the document has only one main landmark and each iframe in the page has at most one main landmark',
					help: 'Document must have one main landmark'
				},
				'landmark-unique': {
					help: 'Ensures landmarks are unique',
					description:
						'Landmarks must have a unique role or role/label/title (i.e. accessible name) combination'
				},
				'layout-table': {
					description:
						'Ensures presentational <table> elements do not use <th>, <caption> elements or the summary attribute',
					help: 'Layout tables must not use data table elements'
				},
				'link-in-text-block': {
					description: 'Links can be distinguished without relying on color',
					help:
						'Links must be distinguished from surrounding text in a way that does not rely on color'
				},
				'link-name': {
					description: 'Ensures links have discernible text',
					help: 'Links must have discernible text'
				},
				list: {
					description: 'Ensures that lists are structured correctly',
					help:
						'<ul> and <ol> must only directly contain <li>, <script> or <template> elements'
				},
				listitem: {
					description: 'Ensures <li> elements are used semantically',
					help: '<li> elements must be contained in a <ul> or <ol>'
				},
				marquee: {
					description: 'Ensures <marquee> elements are not used',
					help: '<marquee> elements are deprecated and must not be used'
				},
				'meta-refresh': {
					description: 'Ensures <meta http-equiv="refresh"> is not used',
					help: 'Timed refresh must not exist'
				},
				'meta-viewport-large': {
					description:
						'Ensures <meta name="viewport"> can scale a significant amount',
					help: 'Users should be able to zoom and scale the text up to 500%'
				},
				'meta-viewport': {
					description:
						'Ensures <meta name="viewport"> does not disable text scaling and zooming',
					help: 'Zooming and scaling must not be disabled'
				},
				'no-autoplay-audio': {
					description:
						'Ensures <video> or <audio> elements does not autoplay audio for more than 3 seconds or has a control mechanism to stop or mute the audio',
					help: '<video> or <audio> elements does not autoplay audio'
				},
				'object-alt': {
					description: 'Ensures <object> elements have alternate text',
					help: '<object> elements must have alternate text'
				},
				'p-as-heading': {
					description: 'Ensure p elements are not used to style headings',
					help:
						'Bold, italic text and font-size are not used to style p elements as a heading'
				},
				'page-has-heading-one': {
					description:
						'Ensure that the page, or at least one of its frames contains a level-one heading',
					help: 'Page must contain a level-one heading'
				},
				radiogroup: {
					description:
						'Ensures related <input type="radio"> elements have a group and that the group designation is consistent',
					help:
						'Radio inputs with the same name attribute value must be part of a group'
				},
				region: {
					description: 'Ensures all page content is contained by landmarks',
					help: 'All page content must be contained by landmarks'
				},
				'role-img-alt': {
					description: "Ensures [role='img'] elements have alternate text",
					help: "[role='img'] elements have an alternative text"
				},
				'scope-attr-valid': {
					description:
						'Ensures the scope attribute is used correctly on tables',
					help: 'scope attribute should be used correctly'
				},
				'scrollable-region-focusable': {
					description:
						'Elements that have scrollable content should be accessible by keyboard',
					help: 'Ensure that scrollable region has keyboard access'
				},
				'server-side-image-map': {
					description: 'Ensures that server-side image maps are not used',
					help: 'Server-side image maps must not be used'
				},
				'skip-link': {
					description: 'Ensure all skip links have a focusable target',
					help: 'The skip-link target should exist and be focusable'
				},
				'svg-img-alt': {
					description:
						'Ensures svg elements with an img, graphics-document or graphics-symbol role have an accessible text',
					help: 'svg elements with an img role have an alternative text'
				},
				tabindex: {
					description:
						'Ensures tabindex attribute values are not greater than 0',
					help: 'Elements should not have tabindex greater than zero'
				},
				'table-duplicate-name': {
					description:
						'Ensure that tables do not have the same summary and caption',
					help:
						'The <caption> element should not contain the same text as the summary attribute'
				},
				'table-fake-caption': {
					description:
						'Ensure that tables with a caption use the <caption> element.',
					help:
						'Data or header cells should not be used to give caption to a data table.'
				},
				'td-has-header': {
					description:
						'Ensure that each non-empty data cell in a large table has one or more table headers',
					help:
						'All non-empty td element in table larger than 3 by 3 must have an associated table header'
				},
				'td-headers-attr': {
					description:
						'Ensure that each cell in a table using the headers refers to another cell in that table',
					help:
						'All cells in a table element that use the headers attribute must only refer to other cells of that same table'
				},
				'th-has-data-cells': {
					description:
						'Ensure that each table header in a data table refers to data cells',
					help:
						'All th elements and elements with role=columnheader/rowheader must have data cells they describe'
				},
				'valid-lang': {
					description: 'Ensures lang attributes have valid values',
					help: 'lang attribute must have a valid value'
				},
				'video-caption': {
					description: 'Ensures <video> elements have captions',
					help: '<video> elements must have captions'
				},
				'video-description': {
					description: 'Ensures <video> elements have audio descriptions',
					help: '<video> elements must have an audio description track'
				}
			},
			checks: {
				accesskeys: {
					impact: 'serious',
					messages: {
						pass: 'Accesskey attribute value is unique',
						fail: 'Document has multiple elements with the same accesskey'
					}
				},
				'non-empty-alt': {
					impact: 'critical',
					messages: {
						pass: 'Element has a non-empty alt attribute',
						fail: 'Element has no alt attribute or the alt attribute is empty'
					}
				},
				'non-empty-title': {
					impact: 'serious',
					messages: {
						pass: 'Element has a title attribute',
						fail:
							'Element has no title attribute or the title attribute is empty'
					}
				},
				'aria-label': {
					impact: 'serious',
					messages: {
						pass: 'aria-label attribute exists and is not empty',
						fail: 'aria-label attribute does not exist or is empty'
					}
				},
				'aria-labelledby': {
					impact: 'serious',
					messages: {
						pass:
							'aria-labelledby attribute exists and references elements that are visible to screen readers',
						fail:
							'aria-labelledby attribute does not exist, references elements that do not exist or references elements that are empty'
					}
				},
				'aria-allowed-attr': {
					impact: 'critical',
					messages: {
						pass: 'ARIA attributes are used correctly for the defined role',
						fail: {
							singular: 'ARIA attribute is not allowed: ${data.values}',
							plural: 'ARIA attributes are not allowed: ${data.values}'
						}
					}
				},
				'aria-unsupported-attr': {
					impact: 'critical',
					messages: {
						pass: 'ARIA attribute is supported',
						fail:
							'ARIA attribute is not widely supported in screen readers and assistive technologies: ${data.values}'
					}
				},
				'aria-allowed-role': {
					impact: 'minor',
					messages: {
						pass: 'ARIA role is allowed for given element',
						fail: {
							singular:
								'ARIA role ${data.values} is not allowed for given element',
							plural:
								'ARIA roles ${data.values} are not allowed for given element'
						},
						incomplete: {
							singular:
								'ARIA role ${data.values} must be removed when the element is made visible, as it is not allowed for the element',
							plural:
								'ARIA roles ${data.values} must be removed when the element is made visible, as they are not allowed for the element'
						}
					}
				},
				'implicit-role-fallback': {
					impact: 'moderate',
					messages: {
						pass: 'Elements implicit ARIA role is an appropriate fallback',
						fail:
							'Elements implicit ARIA role is not a good fallback for the (unsupported) role'
					}
				},
				'aria-hidden-body': {
					impact: 'critical',
					messages: {
						pass: 'No aria-hidden attribute is present on document body',
						fail: 'aria-hidden=true should not be present on the document body'
					}
				},
				'focusable-disabled': {
					impact: 'serious',
					messages: {
						pass: 'No focusable elements contained within element',
						fail:
							'Focusable content should be disabled or be removed from the DOM'
					}
				},
				'focusable-not-tabbable': {
					impact: 'serious',
					messages: {
						pass: 'No focusable elements contained within element',
						fail:
							"Focusable content should have tabindex='-1' or be removed from the DOM"
					}
				},
				'no-implicit-explicit-label': {
					impact: 'moderate',
					messages: {
						pass: 'There is no mismatch between a <label> and accessible name',
						incomplete:
							"Check that the <label> does not need be part of the ARIA ${data} field's name"
					}
				},
				'aria-required-attr': {
					impact: 'critical',
					messages: {
						pass: 'All required ARIA attributes are present',
						fail: {
							singular: 'Required ARIA attribute not present: ${data.values}',
							plural: 'Required ARIA attributes not present: ${data.values}'
						}
					}
				},
				'aria-required-children': {
					impact: 'critical',
					messages: {
						pass: 'Required ARIA children are present',
						fail: {
							singular: 'Required ARIA child role not present: ${data.values}',
							plural: 'Required ARIA children role not present: ${data.values}'
						},
						incomplete: {
							singular: 'Expecting ARIA child role to be added: ${data.values}',
							plural: 'Expecting ARIA children role to be added: ${data.values}'
						}
					}
				},
				'aria-required-parent': {
					impact: 'critical',
					messages: {
						pass: 'Required ARIA parent role present',
						fail: {
							singular: 'Required ARIA parent role not present: ${data.values}',
							plural: 'Required ARIA parents role not present: ${data.values}'
						}
					}
				},
				'aria-roledescription': {
					impact: 'serious',
					messages: {
						pass: 'aria-roledescription used on a supported semantic role',
						incomplete:
							'Check that the aria-roledescription is announced by supported screen readers',
						fail: 'Give the element a role that supports aria-roledescription'
					}
				},
				invalidrole: {
					impact: 'critical',
					messages: {
						pass: 'ARIA role is valid',
						fail: 'Role must be one of the valid ARIA roles'
					}
				},
				abstractrole: {
					impact: 'serious',
					messages: {
						pass: 'Abstract roles are not used',
						fail: 'Abstract roles cannot be directly used'
					}
				},
				unsupportedrole: {
					impact: 'critical',
					messages: {
						pass: 'ARIA role is supported',
						fail:
							'The role used is not widely supported in screen readers and assistive technologies: ${data.values}'
					}
				},
				'has-visible-text': {
					impact: 'minor',
					messages: {
						pass: 'Element has text that is visible to screen readers',
						fail: 'Element does not have text that is visible to screen readers'
					}
				},
				'aria-valid-attr-value': {
					impact: 'critical',
					messages: {
						pass: 'ARIA attribute values are valid',
						fail: {
							singular: 'Invalid ARIA attribute value: ${data.values}',
							plural: 'Invalid ARIA attribute values: ${data.values}'
						},
						incomplete: {
							singular:
								'ARIA attribute element ID does not exist on the page: ${data.values}',
							plural:
								'ARIA attributes element ID does not exist on the page: ${data.values}'
						}
					}
				},
				'aria-errormessage': {
					impact: 'critical',
					messages: {
						pass: 'Uses a supported aria-errormessage technique',
						fail: {
							singular:
								'aria-errormessage value `${data.values}` must use a technique to announce the message (e.g., aria-live, aria-describedby, role=alert, etc.)',
							plural:
								'aria-errormessage values `${data.values}` must use a technique to announce the message (e.g., aria-live, aria-describedby, role=alert, etc.)'
						}
					}
				},
				'aria-valid-attr': {
					impact: 'critical',
					messages: {
						pass: 'ARIA attribute name is valid',
						fail: {
							singular: 'Invalid ARIA attribute name: ${data.values}',
							plural: 'Invalid ARIA attribute names: ${data.values}'
						}
					}
				},
				caption: {
					impact: 'critical',
					messages: {
						pass: 'The multimedia element has a captions track',
						incomplete: 'Check that captions is available for the element'
					}
				},
				'autocomplete-valid': {
					impact: 'serious',
					messages: {
						pass: 'the autocomplete attribute is correctly formatted',
						fail: 'the autocomplete attribute is incorrectly formatted'
					}
				},
				'autocomplete-appropriate': {
					impact: 'serious',
					messages: {
						pass: 'the autocomplete value is on an appropriate element',
						fail:
							'the autocomplete value is inappropriate for this type of input'
					}
				},
				'avoid-inline-spacing': {
					impact: 'serious',
					messages: {
						pass:
							"No inline styles with '!important' that affect text spacing has been specified",
						fail: {
							singular:
								"Remove '!important' from inline style ${data.values}, as overriding this is not supported by most browsers",
							plural:
								"Remove '!important' from inline styles ${data.values}, as overriding this is not supported by most browsers"
						}
					}
				},
				'is-on-screen': {
					impact: 'serious',
					messages: {
						pass: 'Element is not visible',
						fail: 'Element is visible'
					}
				},
				'button-has-visible-text': {
					impact: 'critical',
					messages: {
						pass: 'Element has inner text that is visible to screen readers',
						fail:
							'Element does not have inner text that is visible to screen readers'
					}
				},
				'role-presentation': {
					impact: 'minor',
					messages: {
						pass:
							'Element\'s default semantics were overriden with role="presentation"',
						fail:
							'Element\'s default semantics were not overridden with role="presentation"'
					}
				},
				'role-none': {
					impact: 'minor',
					messages: {
						pass:
							'Element\'s default semantics were overriden with role="none"',
						fail:
							'Element\'s default semantics were not overridden with role="none"'
					}
				},
				'internal-link-present': {
					impact: 'serious',
					messages: {
						pass: 'Valid skip link found',
						fail: 'No valid skip link found'
					}
				},
				'header-present': {
					impact: 'serious',
					messages: {
						pass: 'Page has a header',
						fail: 'Page does not have a header'
					}
				},
				landmark: {
					impact: 'serious',
					messages: {
						pass: 'Page has a landmark region',
						fail: 'Page does not have a landmark region'
					}
				},
				'group-labelledby': {
					impact: 'critical',
					messages: {
						pass:
							'Elements with the name "${data.name}" have both a shared label, and a unique label, referenced through aria-labelledby',
						fail: {
							default:
								'Elements with the name "${data.name}" do not all have both a shared label, and a unique label referenced through aria-labelledby',
							'no-shared-label':
								'Elements with the name "${data.name}" do not all have a shared label referenced through aria-labelledby',
							'no-unique-label':
								'Elements with the name "${data.name}" do not all have a unique label referenced through aria-labelledby'
						}
					}
				},
				fieldset: {
					impact: 'critical',
					messages: {
						pass: 'Element is contained in a fieldset',
						fail: {
							default:
								'Element does not have a containing fieldset or ARIA group',
							'no-legend': 'Fieldset does not have a legend as its first child',
							'empty-legend':
								'Legend does not have text that is visible to screen readers',
							'mixed-inputs': 'Fieldset contains unrelated inputs',
							'no-group-label':
								'ARIA group does not have aria-label or aria-labelledby',
							'group-mixed-inputs': 'ARIA group contains unrelated inputs'
						}
					}
				},
				'color-contrast': {
					impact: 'serious',
					messages: {
						pass:
							'Element has sufficient color contrast of ${data.contrastRatio}',
						fail:
							'Element has insufficient color contrast of ${data.contrastRatio} (foreground color: ${data.fgColor}, background color: ${data.bgColor}, font size: ${data.fontSize}, font weight: ${data.fontWeight}). Expected contrast ratio of ${data.expectedContrastRatio}',
						incomplete: {
							default: 'Unable to determine contrast ratio',
							bgImage:
								"Element's background color could not be determined due to a background image",
							bgGradient:
								"Element's background color could not be determined due to a background gradient",
							imgNode:
								"Element's background color could not be determined because element contains an image node",
							bgOverlap:
								"Element's background color could not be determined because it is overlapped by another element",
							fgAlpha:
								"Element's foreground color could not be determined because of alpha transparency",
							elmPartiallyObscured:
								"Element's background color could not be determined because it's partially obscured by another element",
							elmPartiallyObscuring:
								"Element's background color could not be determined because it partially overlaps other elements",
							outsideViewport:
								"Element's background color could not be determined because it's outside the viewport",
							equalRatio:
								'Element has a 1:1 contrast ratio with the background',
							shortTextContent:
								'Element content is too short to determine if it is actual text content'
						}
					}
				},
				'css-orientation-lock': {
					impact: 'serious',
					messages: {
						pass: 'Display is operable, and orientation lock does not exist',
						fail:
							'CSS Orientation lock is applied, and makes display inoperable',
						incomplete: 'CSS Orientation lock cannot be determined'
					}
				},
				'structured-dlitems': {
					impact: 'serious',
					messages: {
						pass: 'When not empty, element has both <dt> and <dd> elements',
						fail:
							'When not empty, element does not have at least one <dt> element followed by at least one <dd> element'
					}
				},
				'only-dlitems': {
					impact: 'serious',
					messages: {
						pass:
							'List element only has direct children that are allowed inside <dt> or <dd> elements',
						fail:
							'List element has direct children that are not allowed inside <dt> or <dd> elements'
					}
				},
				dlitem: {
					impact: 'serious',
					messages: {
						pass: 'Description list item has a <dl> parent element',
						fail: 'Description list item does not have a <dl> parent element'
					}
				},
				'doc-has-title': {
					impact: 'serious',
					messages: {
						pass: 'Document has a non-empty <title> element',
						fail: 'Document does not have a non-empty <title> element'
					}
				},
				'duplicate-id-active': {
					impact: 'serious',
					messages: {
						pass:
							'Document has no active elements that share the same id attribute',
						fail:
							'Document has active elements with the same id attribute: ${data}'
					}
				},
				'duplicate-id-aria': {
					impact: 'critical',
					messages: {
						pass:
							'Document has no elements referenced with ARIA or labels that share the same id attribute',
						fail:
							'Document has multiple elements referenced with ARIA with the same id attribute: ${data}'
					}
				},
				'duplicate-id': {
					impact: 'minor',
					messages: {
						pass:
							'Document has no static elements that share the same id attribute',
						fail:
							'Document has multiple static elements with the same id attribute'
					}
				},
				'filename-is-valid-accessible-name': {
					impact: 'minor',
					messages: {
						pass:
							'Element has an accessible name that serves an equivalent purpose to the non-text content',
						incomplete:
							'Element does not have an accessible name that serves an equivalent purpose to the non-text content'
					}
				},
				'has-widget-role': {
					impact: 'minor',
					messages: {
						pass: 'Element has a widget role.',
						fail: 'Element does not have a widget role.'
					}
				},
				'valid-scrollable-semantics': {
					impact: 'minor',
					messages: {
						pass:
							'Element has valid semantics for an element in the focus order.',
						fail:
							'Element has invalid semantics for an element in the focus order.'
					}
				},
				'multiple-label': {
					impact: 'moderate',
					messages: {
						pass: 'Form field does not have multiple label elements',
						incomplete:
							'Multiple label elements is not widely supported in assistive technologies. Ensure the first label contains all necessary information.'
					}
				},
				'frame-tested': {
					impact: 'critical',
					messages: {
						pass: 'The iframe was tested with axe-core',
						fail: 'The iframe could not be tested with axe-core',
						incomplete: 'The iframe still has to be tested with axe-core'
					}
				},
				'unique-frame-title': {
					impact: 'serious',
					messages: {
						pass: "Element's title attribute is unique",
						fail: "Element's title attribute is not unique"
					}
				},
				'heading-order': {
					impact: 'moderate',
					messages: {
						pass: 'Heading order valid',
						fail: 'Heading order invalid'
					}
				},
				'hidden-content': {
					impact: 'minor',
					messages: {
						pass: 'All content on the page has been analyzed.',
						fail: 'There were problems analyzing the content on this page.',
						incomplete:
							'There is hidden content on the page that was not analyzed. You will need to trigger the display of this content in order to analyze it.'
					}
				},
				'has-lang': {
					impact: 'serious',
					messages: {
						pass: 'The <html> element has a lang attribute',
						fail: 'The <html> element does not have a lang attribute'
					}
				},
				'valid-lang': {
					impact: 'serious',
					messages: {
						pass:
							'Value of lang attribute is included in the list of valid languages',
						fail:
							'Value of lang attribute not included in the list of valid languages'
					}
				},
				'xml-lang-mismatch': {
					impact: 'moderate',
					messages: {
						pass: 'Lang and xml:lang attributes have the same base language',
						fail:
							'Lang and xml:lang attributes do not have the same base language'
					}
				},
				'identical-links-same-purpose': {
					impact: 'minor',
					messages: {
						pass:
							'There are no other links with the same name, that go to a different URL',
						incomplete:
							'Check that links have the same purpose, or are intentionally ambiguous.'
					}
				},
				'has-alt': {
					impact: 'critical',
					messages: {
						pass: 'Element has an alt attribute',
						fail: 'Element does not have an alt attribute'
					}
				},
				'alt-space-value': {
					impact: 'critical',
					messages: {
						pass: 'Element has a valid alt attribute value',
						fail:
							'Element has an alt attribute containing only a space character, which is not ignored by all screen readers'
					}
				},
				'duplicate-img-label': {
					impact: 'minor',
					messages: {
						pass: 'Element does not duplicate existing text in <img> alt text',
						fail:
							'Element contains <img> element with alt text that duplicates existing text'
					}
				},
				'non-empty-if-present': {
					impact: 'critical',
					messages: {
						pass: {
							default: 'Element does not have a value attribute',
							'has-label': 'Element has a non-empty value attribute'
						},
						fail:
							'Element has a value attribute and the value attribute is empty'
					}
				},
				'non-empty-value': {
					impact: 'critical',
					messages: {
						pass: 'Element has a non-empty value attribute',
						fail:
							'Element has no value attribute or the value attribute is empty'
					}
				},
				'label-content-name-mismatch': {
					impact: 'serious',
					messages: {
						pass:
							"Element contains visible text as part of it's accessible name",
						fail:
							'Text inside the element is not included in the accessible name'
					}
				},
				'title-only': {
					impact: 'serious',
					messages: {
						pass:
							'Form element does not solely use title attribute for its label',
						fail: 'Only title used to generate label for form element'
					}
				},
				'implicit-label': {
					impact: 'critical',
					messages: {
						pass: 'Form element has an implicit (wrapped) <label>',
						fail: 'Form element does not have an implicit (wrapped) <label>'
					}
				},
				'explicit-label': {
					impact: 'critical',
					messages: {
						pass: 'Form element has an explicit <label>',
						fail: 'Form element does not have an explicit <label>'
					}
				},
				'help-same-as-label': {
					impact: 'minor',
					messages: {
						pass:
							'Help text (title or aria-describedby) does not duplicate label text',
						fail:
							'Help text (title or aria-describedby) text is the same as the label text'
					}
				},
				'hidden-explicit-label': {
					impact: 'critical',
					messages: {
						pass: 'Form element has a visible explicit <label>',
						fail: 'Form element has explicit <label> that is hidden'
					}
				},
				'landmark-is-top-level': {
					impact: 'moderate',
					messages: {
						pass: 'The ${data.role} landmark is at the top level.',
						fail: 'The ${data.role} landmark is contained in another landmark.'
					}
				},
				'page-no-duplicate-banner': {
					impact: 'moderate',
					messages: {
						pass: 'Document does not have more than one banner landmark',
						fail: 'Document has more than one banner landmark'
					}
				},
				'page-no-duplicate-contentinfo': {
					impact: 'moderate',
					messages: {
						pass: 'Document does not have more than one contentinfo landmark',
						fail: 'Document has more than one contentinfo landmark'
					}
				},
				'page-has-main': {
					impact: 'moderate',
					messages: {
						pass: 'Document has at least one main landmark',
						fail: 'Document does not have a main landmark'
					}
				},
				'page-no-duplicate-main': {
					impact: 'moderate',
					messages: {
						pass: 'Document does not have more than one main landmark',
						fail: 'Document has more than one main landmark'
					}
				},
				'landmark-is-unique': {
					impact: 'moderate',
					messages: {
						pass:
							'Landmarks must have a unique role or role/label/title (i.e. accessible name) combination',
						fail:
							'The landmark must have a unique aria-label, aria-labelledby, or title to make landmarks distinguishable'
					}
				},
				'has-th': {
					impact: 'serious',
					messages: {
						pass: 'Layout table does not use <th> elements',
						fail: 'Layout table uses <th> elements'
					}
				},
				'has-caption': {
					impact: 'serious',
					messages: {
						pass: 'Layout table does not use <caption> element',
						fail: 'Layout table uses <caption> element'
					}
				},
				'has-summary': {
					impact: 'serious',
					messages: {
						pass: 'Layout table does not use summary attribute',
						fail: 'Layout table uses summary attribute'
					}
				},
				'link-in-text-block': {
					impact: 'serious',
					messages: {
						pass:
							'Links can be distinguished from surrounding text in some way other than by color',
						fail:
							'Links need to be distinguished from surrounding text in some way other than by color',
						incomplete: {
							default: 'Unable to determine contrast ratio',
							bgContrast:
								"Element's contrast ratio could not be determined. Check for a distinct hover/focus style",
							bgImage:
								"Element's contrast ratio could not be determined due to a background image",
							bgGradient:
								"Element's contrast ratio could not be determined due to a background gradient",
							imgNode:
								"Element's contrast ratio could not be determined because element contains an image node",
							bgOverlap:
								"Element's contrast ratio could not be determined because of element overlap"
						}
					}
				},
				'focusable-no-name': {
					impact: 'serious',
					messages: {
						pass: 'Element is not in tab order or has accessible text',
						fail: 'Element is in tab order and does not have accessible text'
					}
				},
				'only-listitems': {
					impact: 'serious',
					messages: {
						pass:
							'List element only has direct children that are allowed inside <li> elements',
						fail:
							'List element has direct children that are not allowed inside <li> elements'
					}
				},
				listitem: {
					impact: 'serious',
					messages: {
						pass: 'List item has a <ul>, <ol> or role="list" parent element',
						fail: {
							default: 'List item does not have a <ul>, <ol> parent element',
							roleNotValid:
								'List item does not have a <ul>, <ol> parent element without a role, or a role="list"'
						}
					}
				},
				'meta-refresh': {
					impact: 'critical',
					messages: {
						pass: '<meta> tag does not immediately refresh the page',
						fail: '<meta> tag forces timed refresh of page'
					}
				},
				'meta-viewport-large': {
					impact: 'minor',
					messages: {
						pass:
							'<meta> tag does not prevent significant zooming on mobile devices',
						fail: '<meta> tag limits zooming on mobile devices'
					}
				},
				'meta-viewport': {
					impact: 'critical',
					messages: {
						pass: '<meta> tag does not disable zooming on mobile devices',
						fail: '${data} on <meta> tag disables zooming on mobile devices'
					}
				},
				'no-autoplay-audio': {
					impact: 'moderate',
					messages: {
						pass:
							'<video> or <audio> does not output audio for more than allowed duration or has controls mechanism',
						fail:
							'<video> or <audio> either outputs audio for more than allowed duration or does not have a controls mechanism',
						incomplete:
							'Check that the <video> or <audio> does not output audio for more than allowed duration or provides a controls mechanism'
					}
				},
				'p-as-heading': {
					impact: 'serious',
					messages: {
						pass: '<p> elements are not styled as headings',
						fail: 'Heading elements should be used instead of styled p elements'
					}
				},
				'page-has-heading-one': {
					impact: 'moderate',
					messages: {
						pass: 'Page has at least one level-one heading',
						fail: 'Page must have a level-one heading'
					}
				},
				region: {
					impact: 'moderate',
					messages: {
						pass: 'All page content is contained by landmarks',
						fail: 'Some page content is not contained by landmarks'
					}
				},
				'html5-scope': {
					impact: 'moderate',
					messages: {
						pass:
							'Scope attribute is only used on table header elements (<th>)',
						fail:
							'In HTML 5, scope attributes may only be used on table header elements (<th>)'
					}
				},
				'scope-value': {
					impact: 'critical',
					messages: {
						pass: 'Scope attribute is used correctly',
						fail: "The value of the scope attribute may only be 'row' or 'col'"
					}
				},
				'focusable-content': {
					impact: 'moderate',
					messages: {
						pass: 'Element contains focusable elements',
						fail: 'Element should have focusable content'
					}
				},
				'focusable-element': {
					impact: 'moderate',
					messages: {
						pass: 'Element is focusable',
						fail: 'Element should be focusable'
					}
				},
				exists: {
					impact: 'minor',
					messages: {
						pass: 'Element does not exist',
						incomplete: 'Element exists'
					}
				},
				'skip-link': {
					impact: 'moderate',
					messages: {
						pass: 'Skip link target exists',
						incomplete: 'Skip link target should become visible on activation',
						fail: 'No skip link target'
					}
				},
				'svg-non-empty-title': {
					impact: 'serious',
					messages: {
						pass: 'element has a child that is a title',
						fail: 'element has no child that is a title'
					}
				},
				tabindex: {
					impact: 'serious',
					messages: {
						pass: 'Element does not have a tabindex greater than 0',
						fail: 'Element has a tabindex greater than 0'
					}
				},
				'same-caption-summary': {
					impact: 'minor',
					messages: {
						pass:
							'Content of summary attribute and <caption> are not duplicated',
						fail:
							'Content of summary attribute and <caption> element are identical'
					}
				},
				'caption-faked': {
					impact: 'serious',
					messages: {
						pass: 'The first row of a table is not used as a caption',
						fail:
							'The first child of the table should be a caption instead of a table cell'
					}
				},
				'td-has-header': {
					impact: 'critical',
					messages: {
						pass: 'All non-empty data cells have table headers',
						fail: 'Some non-empty data cells do not have table headers'
					}
				},
				'td-headers-attr': {
					impact: 'serious',
					messages: {
						pass:
							'The headers attribute is exclusively used to refer to other cells in the table',
						fail:
							'The headers attribute is not exclusively used to refer to other cells in the table'
					}
				},
				'th-has-data-cells': {
					impact: 'serious',
					messages: {
						pass: 'All table header cells refer to data cells',
						fail: 'Not all table header cells refer to data cells',
						incomplete: 'Table data cells are missing or empty'
					}
				},
				description: {
					impact: 'critical',
					messages: {
						pass: 'The multimedia element has an audio description track',
						incomplete:
							'Check that audio description is available for the element'
					}
				}
			},
			failureSummaries: {
				any: {
					failureMessage: function anonymous(it) {
						var out = 'Fix any of the following:';
						var arr1 = it;

						if (arr1) {
							var value,
								i1 = -1,
								l1 = arr1.length - 1;

							while (i1 < l1) {
								value = arr1[(i1 += 1)];
								out += '\n  ' + value.split('\n').join('\n  ');
							}
						}

						return out;
					}
				},
				none: {
					failureMessage: function anonymous(it) {
						var out = 'Fix all of the following:';
						var arr1 = it;

						if (arr1) {
							var value,
								i1 = -1,
								l1 = arr1.length - 1;

							while (i1 < l1) {
								value = arr1[(i1 += 1)];
								out += '\n  ' + value.split('\n').join('\n  ');
							}
						}

						return out;
					}
				}
			},
			incompleteFallbackMessage: {}
		},
		rules: [
			{
				id: 'accesskeys',
				selector: '[accesskey]',
				excludeHidden: false,
				tags: ['best-practice', 'cat.keyboard'],
				all: [],
				any: [],
				none: ['accesskeys']
			},
			{
				id: 'area-alt',
				selector: 'map area[href]',
				excludeHidden: false,
				tags: [
					'cat.text-alternatives',
					'wcag2a',
					'wcag111',
					'section508',
					'section508.22.a'
				],
				all: [],
				any: [
					'non-empty-alt',
					'non-empty-title',
					'aria-label',
					'aria-labelledby'
				],
				none: []
			},
			{
				id: 'aria-allowed-attr',
				matches: function matches(node, virtualNode, context) {
					var aria = /^aria-/;

					if (node.hasAttributes()) {
						var attrs = axe.utils.getNodeAttributes(node);

						for (var i = 0, l = attrs.length; i < l; i++) {
							if (aria.test(attrs[i].name)) {
								return true;
							}
						}
					}

					return false;
				},
				tags: ['cat.aria', 'wcag2a', 'wcag412'],
				all: [],
				any: ['aria-allowed-attr'],
				none: ['aria-unsupported-attr']
			},
			{
				id: 'aria-allowed-role',
				excludeHidden: false,
				selector: '[role]',
				matches: function matches(node, virtualNode, context) {
					return (
						axe.commons.aria.getRole(node, {
							noImplicit: true,
							dpub: true,
							fallback: true
						}) !== null
					);
				},
				tags: ['cat.aria', 'best-practice'],
				all: [],
				any: [
					{
						options: {
							allowImplicit: true,
							ignoredTags: []
						},
						id: 'aria-allowed-role'
					}
				],
				none: []
			},
			{
				id: 'aria-dpub-role-fallback',
				selector: '[role]',
				matches: function matches(node, virtualNode, context) {
					var role = node.getAttribute('role');
					return [
						'doc-backlink',
						'doc-biblioentry',
						'doc-biblioref',
						'doc-cover',
						'doc-endnote',
						'doc-glossref',
						'doc-noteref'
					].includes(role);
				},
				tags: ['cat.aria', 'wcag2a', 'wcag131', 'deprecated'],
				enabled: false,
				all: ['implicit-role-fallback'],
				any: [],
				none: []
			},
			{
				id: 'aria-hidden-body',
				selector: 'body',
				excludeHidden: false,
				tags: ['cat.aria', 'wcag2a', 'wcag412'],
				all: [],
				any: ['aria-hidden-body'],
				none: []
			},
			{
				id: 'aria-hidden-focus',
				selector: '[aria-hidden="true"]',
				matches: function matches(node, virtualNode, context) {
					var getComposedParent = axe.commons.dom.getComposedParent;
					/**
					 * Only match the outer-most `aria-hidden=true` element
					 * @param {HTMLElement} el the HTMLElement to verify
					 * @return {Boolean}
					 */

					function shouldMatchElement(el) {
						if (!el) {
							return true;
						}

						if (el.getAttribute('aria-hidden') === 'true') {
							return false;
						}

						return shouldMatchElement(getComposedParent(el));
					}

					return shouldMatchElement(getComposedParent(node));
				},
				excludeHidden: false,
				tags: ['cat.name-role-value', 'wcag2a', 'wcag412', 'wcag131'],
				all: ['focusable-disabled', 'focusable-not-tabbable'],
				any: [],
				none: []
			},
			{
				id: 'aria-input-field-name',
				selector:
					'[role="combobox"], [role="listbox"], [role="searchbox"], [role="slider"], [role="spinbutton"], [role="textbox"]',
				matches: function matches(node, virtualNode, context) {
					/**
					 * Note:
					 * This rule filters elements with 'role=*' attribute via 'selector'
					 * see relevant rule spec for details of 'role(s)' being filtered.
					 */
					var aria = axe.commons.aria;
					var nodeName = node.nodeName.toUpperCase();
					var role = aria.getRole(node, {
						noImplicit: true
					});
					/**
					 * Ignore elements from rule -> 'area-alt'
					 */

					if (nodeName === 'AREA' && !!node.getAttribute('href')) {
						return false;
					}
					/**
					 * Ignore elements from rule -> 'label'
					 */

					if (['INPUT', 'SELECT', 'TEXTAREA'].includes(nodeName)) {
						return false;
					}
					/**
					 * Ignore elements from rule -> 'image-alt'
					 */

					if (nodeName === 'IMG' || (role === 'img' && nodeName !== 'SVG')) {
						return false;
					}
					/**
					 * Ignore elements from rule -> 'button-name'
					 */

					if (nodeName === 'BUTTON' || role === 'button') {
						return false;
					}
					/**
					 * Ignore combobox elements if they have a child input
					 * (ARIA 1.1 pattern)
					 */

					if (
						role === 'combobox' &&
						axe.utils.querySelectorAll(
							virtualNode,
							'input:not([type="hidden"])'
						).length
					) {
						return false;
					}

					return true;
				},
				tags: ['wcag2a', 'wcag412'],
				all: [],
				any: ['aria-label', 'aria-labelledby', 'non-empty-title'],
				none: ['no-implicit-explicit-label']
			},
			{
				id: 'aria-required-attr',
				selector: '[role]',
				tags: ['cat.aria', 'wcag2a', 'wcag412'],
				all: [],
				any: ['aria-required-attr'],
				none: []
			},
			{
				id: 'aria-required-children',
				selector: '[role]',
				tags: ['cat.aria', 'wcag2a', 'wcag131'],
				all: [],
				any: [
					{
						options: {
							reviewEmpty: [
								'doc-bibliography',
								'doc-endnotes',
								'grid',
								'list',
								'listbox',
								'table',
								'tablist',
								'tree',
								'treegrid',
								'rowgroup'
							]
						},
						id: 'aria-required-children'
					}
				],
				none: []
			},
			{
				id: 'aria-required-parent',
				selector: '[role]',
				tags: ['cat.aria', 'wcag2a', 'wcag131'],
				all: [],
				any: ['aria-required-parent'],
				none: []
			},
			{
				id: 'aria-roledescription',
				selector: '[aria-roledescription]',
				tags: ['cat.aria', 'wcag2a', 'wcag412'],
				all: [],
				any: [
					{
						options: {
							supportedRoles: [
								'button',
								'img',
								'checkbox',
								'radio',
								'combobox',
								'menuitemcheckbox',
								'menuitemradio'
							]
						},
						id: 'aria-roledescription'
					}
				],
				none: []
			},
			{
				id: 'aria-roles',
				selector: '[role]',
				tags: ['cat.aria', 'wcag2a', 'wcag412'],
				all: [],
				any: [],
				none: ['invalidrole', 'abstractrole', 'unsupportedrole']
			},
			{
				id: 'aria-toggle-field-name',
				selector:
					'[role="checkbox"], [role="menuitemcheckbox"], [role="menuitemradio"], [role="radio"], [role="switch"]',
				matches: function matches(node, virtualNode, context) {
					/**
					 * Note:
					 * This rule filters elements with 'role=*' attribute via 'selector'
					 * see relevant rule spec for details of 'role(s)' being filtered.
					 */
					var aria = axe.commons.aria;
					var nodeName = node.nodeName.toUpperCase();
					var role = aria.getRole(node, {
						noImplicit: true
					});
					/**
					 * Ignore elements from rule -> 'area-alt'
					 */

					if (nodeName === 'AREA' && !!node.getAttribute('href')) {
						return false;
					}
					/**
					 * Ignore elements from rule -> 'label'
					 */

					if (['INPUT', 'SELECT', 'TEXTAREA'].includes(nodeName)) {
						return false;
					}
					/**
					 * Ignore elements from rule -> 'image-alt'
					 */

					if (nodeName === 'IMG' || (role === 'img' && nodeName !== 'SVG')) {
						return false;
					}
					/**
					 * Ignore elements from rule -> 'button-name'
					 */

					if (nodeName === 'BUTTON' || role === 'button') {
						return false;
					}
					/**
					 * Ignore combobox elements if they have a child input
					 * (ARIA 1.1 pattern)
					 */

					if (
						role === 'combobox' &&
						axe.utils.querySelectorAll(
							virtualNode,
							'input:not([type="hidden"])'
						).length
					) {
						return false;
					}

					return true;
				},
				tags: ['wcag2a', 'wcag412'],
				all: [],
				any: [
					'aria-label',
					'aria-labelledby',
					'non-empty-title',
					'has-visible-text'
				],
				none: ['no-implicit-explicit-label']
			},
			{
				id: 'aria-valid-attr-value',
				matches: function matches(node, virtualNode, context) {
					var aria = /^aria-/;

					if (node.hasAttributes()) {
						var attrs = axe.utils.getNodeAttributes(node);

						for (var i = 0, l = attrs.length; i < l; i++) {
							if (aria.test(attrs[i].name)) {
								return true;
							}
						}
					}

					return false;
				},
				tags: ['cat.aria', 'wcag2a', 'wcag412'],
				all: [
					{
						options: [],
						id: 'aria-valid-attr-value'
					},
					'aria-errormessage'
				],
				any: [],
				none: []
			},
			{
				id: 'aria-valid-attr',
				matches: function matches(node, virtualNode, context) {
					var aria = /^aria-/;

					if (node.hasAttributes()) {
						var attrs = axe.utils.getNodeAttributes(node);

						for (var i = 0, l = attrs.length; i < l; i++) {
							if (aria.test(attrs[i].name)) {
								return true;
							}
						}
					}

					return false;
				},
				tags: ['cat.aria', 'wcag2a', 'wcag412'],
				all: [],
				any: [
					{
						options: [],
						id: 'aria-valid-attr'
					}
				],
				none: []
			},
			{
				id: 'audio-caption',
				selector: 'audio',
				enabled: false,
				excludeHidden: false,
				tags: [
					'cat.time-and-media',
					'wcag2a',
					'wcag121',
					'section508',
					'section508.22.a'
				],
				all: [],
				any: [],
				none: ['caption']
			},
			{
				id: 'autocomplete-valid',
				matches: function matches(node, virtualNode, context) {
					var _axe$commons = axe.commons,
						text = _axe$commons.text,
						aria = _axe$commons.aria,
						dom = _axe$commons.dom;
					var autocomplete = virtualNode.attr('autocomplete');

					if (!autocomplete || text.sanitize(autocomplete) === '') {
						return false;
					}

					var nodeName = virtualNode.props.nodeName;

					if (['textarea', 'input', 'select'].includes(nodeName) === false) {
						return false;
					} // The element is an `input` element a `type` of `hidden`, `button`, `submit` or `reset`

					var excludedInputTypes = ['submit', 'reset', 'button', 'hidden'];

					if (
						nodeName === 'input' &&
						excludedInputTypes.includes(virtualNode.props.type)
					) {
						return false;
					} // The element has a `disabled` or `aria-disabled="true"` attribute

					var ariaDisabled = virtualNode.attr('aria-disabled') || 'false';

					if (
						virtualNode.hasAttr('disabled') ||
						ariaDisabled.toLowerCase() === 'true'
					) {
						return false;
					} // The element has `tabindex="-1"` and has a [[semantic role]] that is
					//   not a [widget](https://www.w3.org/TR/wai-aria-1.1/#widget_roles)

					var role = virtualNode.attr('role');
					var tabIndex = virtualNode.attr('tabindex');

					if (tabIndex === '-1' && role) {
						var roleDef = aria.lookupTable.role[role];

						if (roleDef === undefined || roleDef.type !== 'widget') {
							return false;
						}
					} // The element is **not** visible on the page or exposed to assistive technologies

					if (
						tabIndex === '-1' &&
						virtualNode.actualNode &&
						!dom.isVisible(virtualNode.actualNode, false) &&
						!dom.isVisible(virtualNode.actualNode, true)
					) {
						return false;
					}

					return true;
				},
				tags: ['cat.forms', 'wcag21aa', 'wcag135'],
				all: ['autocomplete-valid', 'autocomplete-appropriate'],
				any: [],
				none: []
			},
			{
				id: 'avoid-inline-spacing',
				selector: '[style]',
				tags: ['wcag21aa', 'wcag1412'],
				all: ['avoid-inline-spacing'],
				any: [],
				none: []
			},
			{
				id: 'blink',
				selector: 'blink',
				excludeHidden: false,
				tags: [
					'cat.time-and-media',
					'wcag2a',
					'wcag222',
					'section508',
					'section508.22.j'
				],
				all: [],
				any: [],
				none: ['is-on-screen']
			},
			{
				id: 'button-name',
				selector: 'button, [role="button"]:not(input)',
				tags: [
					'cat.name-role-value',
					'wcag2a',
					'wcag412',
					'section508',
					'section508.22.a'
				],
				all: [],
				any: [
					'button-has-visible-text',
					'aria-label',
					'aria-labelledby',
					'role-presentation',
					'role-none',
					'non-empty-title'
				],
				none: []
			},
			{
				id: 'bypass',
				selector: 'html',
				pageLevel: true,
				matches: function matches(node, virtualNode, context) {
					return !!node.querySelector('a[href]');
				},
				tags: [
					'cat.keyboard',
					'wcag2a',
					'wcag241',
					'section508',
					'section508.22.o'
				],
				all: [],
				any: ['internal-link-present', 'header-present', 'landmark'],
				none: []
			},
			{
				id: 'checkboxgroup',
				selector: 'input[type=checkbox][name]',
				tags: ['cat.forms', 'best-practice', 'deprecated'],
				enabled: false,
				all: [],
				any: ['group-labelledby', 'fieldset'],
				none: []
			},
			{
				id: 'color-contrast',
				matches: function matches(node, virtualNode, context) {
					/* global document */
					var nodeName = node.nodeName.toUpperCase();
					var nodeType = node.type;

					if (
						node.getAttribute('aria-disabled') === 'true' ||
						axe.commons.dom.findUpVirtual(virtualNode, '[aria-disabled="true"]')
					) {
						return false;
					}

					if (nodeName === 'INPUT') {
						return (
							[
								'hidden',
								'range',
								'color',
								'checkbox',
								'radio',
								'image'
							].indexOf(nodeType) === -1 && !node.disabled
						);
					}

					if (nodeName === 'SELECT') {
						return !!node.options.length && !node.disabled;
					}

					if (nodeName === 'TEXTAREA') {
						return !node.disabled;
					}

					if (nodeName === 'OPTION') {
						return false;
					}

					if (
						(nodeName === 'BUTTON' && node.disabled) ||
						axe.commons.dom.findUpVirtual(virtualNode, 'button[disabled]')
					) {
						return false;
					}

					if (
						(nodeName === 'FIELDSET' && node.disabled) ||
						axe.commons.dom.findUpVirtual(virtualNode, 'fieldset[disabled]')
					) {
						return false;
					} // check if the element is a label or label descendant for a disabled control

					var nodeParentLabel = axe.commons.dom.findUpVirtual(
						virtualNode,
						'label'
					);

					if (nodeName === 'LABEL' || nodeParentLabel) {
						var relevantNode = node;
						var relevantVirtualNode = virtualNode;

						if (nodeParentLabel) {
							relevantNode = nodeParentLabel; // we need an input candidate from a parent to account for label children

							relevantVirtualNode = axe.utils.getNodeFromTree(nodeParentLabel);
						} // explicit label of disabled input

						var doc = axe.commons.dom.getRootNode(relevantNode);
						var candidate =
							relevantNode.htmlFor && doc.getElementById(relevantNode.htmlFor);
						var candidateVirtualNode = axe.utils.getNodeFromTree(candidate);

						if (
							candidate &&
							(candidate.disabled ||
								candidate.getAttribute('aria-disabled') === 'true' ||
								axe.commons.dom.findUpVirtual(
									candidateVirtualNode,
									'[aria-disabled="true"]'
								))
						) {
							return false;
						}

						candidate = axe.utils.querySelectorAll(
							relevantVirtualNode,
							'input:not([type="hidden"]):not([type="image"])' +
								':not([type="button"]):not([type="submit"]):not([type="reset"]), select, textarea'
						);

						if (candidate.length && candidate[0].actualNode.disabled) {
							return false;
						}
					} // label of disabled control associated w/ aria-labelledby

					if (node.getAttribute('id')) {
						var id = axe.utils.escapeSelector(node.getAttribute('id'));

						var _doc = axe.commons.dom.getRootNode(node);

						var _candidate = _doc.querySelector(
							'[aria-labelledby~=' + id + ']'
						);

						if (_candidate && _candidate.disabled) {
							return false;
						}
					}

					var visibleText = axe.commons.text.visibleVirtual(
						virtualNode,
						false,
						true
					);

					if (
						visibleText === '' ||
						axe.commons.text.removeUnicode(visibleText, {
							emoji: true,
							nonBmp: true,
							punctuations: true
						}) === ''
					) {
						return false;
					}

					var range = document.createRange();
					var childNodes = virtualNode.children;
					var length = childNodes.length;
					var child = null;
					var index = 0;

					for (index = 0; index < length; index++) {
						child = childNodes[index];

						if (
							child.actualNode.nodeType === 3 &&
							axe.commons.text.sanitize(child.actualNode.nodeValue) !== ''
						) {
							range.selectNodeContents(child.actualNode);
						}
					}

					var rects = range.getClientRects();
					length = rects.length;

					for (index = 0; index < length; index++) {
						//check to see if the rectangle impinges
						if (axe.commons.dom.visuallyOverlaps(rects[index], node)) {
							return true;
						}
					}

					return false;
				},
				excludeHidden: false,
				options: {
					noScroll: false
				},
				tags: ['cat.color', 'wcag2aa', 'wcag143'],
				all: [],
				any: ['color-contrast'],
				none: []
			},
			{
				id: 'css-orientation-lock',
				selector: 'html',
				tags: ['cat.structure', 'wcag134', 'wcag21aa', 'experimental'],
				all: [
					{
						options: {
							degreeThreshold: 2
						},
						id: 'css-orientation-lock'
					}
				],
				any: [],
				none: [],
				preload: true
			},
			{
				id: 'definition-list',
				selector: 'dl',
				matches: function matches(node, virtualNode, context) {
					return !node.getAttribute('role');
				},
				tags: ['cat.structure', 'wcag2a', 'wcag131'],
				all: [],
				any: [],
				none: ['structured-dlitems', 'only-dlitems']
			},
			{
				id: 'dlitem',
				selector: 'dd, dt',
				matches: function matches(node, virtualNode, context) {
					return !node.getAttribute('role');
				},
				tags: ['cat.structure', 'wcag2a', 'wcag131'],
				all: [],
				any: ['dlitem'],
				none: []
			},
			{
				id: 'document-title',
				selector: 'html',
				matches: function matches(node, virtualNode, context) {
					return (
						node.ownerDocument.defaultView.self ===
						node.ownerDocument.defaultView.top
					);
				},
				tags: ['cat.text-alternatives', 'wcag2a', 'wcag242'],
				all: [],
				any: ['doc-has-title'],
				none: []
			},
			{
				id: 'duplicate-id-active',
				selector: '[id]',
				matches: function matches(node, virtualNode, context) {
					var _axe$commons2 = axe.commons,
						dom = _axe$commons2.dom,
						aria = _axe$commons2.aria;
					var id = node.getAttribute('id').trim();
					var idSelector = '*[id="'.concat(axe.utils.escapeSelector(id), '"]');
					var idMatchingElms = Array.from(
						dom.getRootNode(node).querySelectorAll(idSelector)
					);
					return (
						!aria.isAccessibleRef(node) && idMatchingElms.some(dom.isFocusable)
					);
				},
				excludeHidden: false,
				tags: ['cat.parsing', 'wcag2a', 'wcag411'],
				all: [],
				any: ['duplicate-id-active'],
				none: []
			},
			{
				id: 'duplicate-id-aria',
				selector: '[id]',
				matches: function matches(node, virtualNode, context) {
					return axe.commons.aria.isAccessibleRef(node);
				},
				excludeHidden: false,
				tags: ['cat.parsing', 'wcag2a', 'wcag411'],
				all: [],
				any: ['duplicate-id-aria'],
				none: []
			},
			{
				id: 'duplicate-id',
				selector: '[id]',
				matches: function matches(node, virtualNode, context) {
					var _axe$commons3 = axe.commons,
						dom = _axe$commons3.dom,
						aria = _axe$commons3.aria;
					var id = node.getAttribute('id').trim();
					var idSelector = '*[id="'.concat(axe.utils.escapeSelector(id), '"]');
					var idMatchingElms = Array.from(
						dom.getRootNode(node).querySelectorAll(idSelector)
					);
					return (
						!aria.isAccessibleRef(node) &&
						idMatchingElms.every(function(elm) {
							return !dom.isFocusable(elm);
						})
					);
				},
				excludeHidden: false,
				tags: ['cat.parsing', 'wcag2a', 'wcag411'],
				all: [],
				any: ['duplicate-id'],
				none: []
			},
			{
				id: 'empty-heading',
				selector: 'h1, h2, h3, h4, h5, h6, [role="heading"]',
				matches: function matches(node, virtualNode, context) {
					// Get all valid roles
					var explicitRoles;

					if (node.hasAttribute('role')) {
						explicitRoles = node
							.getAttribute('role')
							.split(/\s+/i)
							.filter(axe.commons.aria.isValidRole);
					} // Check valid roles if there are any, otherwise fall back to the inherited role

					if (explicitRoles && explicitRoles.length > 0) {
						return explicitRoles.includes('heading');
					} else {
						return axe.commons.aria.implicitRole(node) === 'heading';
					}
				},
				tags: ['cat.name-role-value', 'best-practice'],
				all: [],
				any: ['has-visible-text'],
				none: []
			},
			{
				id: 'filename-is-valid-accessible-name',
				matches: function matches(node, virtualNode, context) {
					/**
					 * Matches the below:
					 * - `HTMLInputElement` with `type=image`
					 * - any element with a semantic role of `img`
					 * - is not `aria-hidden`
					 * - has `accessible name`
					 */
					var _axe = axe,
						utils = _axe.utils,
						commons = _axe.commons;
					var aria = commons.aria,
						text = commons.text;
					var isHidden = utils.isHidden(node);

					if (isHidden) {
						return false;
					}

					var accText = text.accessibleText(node);

					if (!accText) {
						return false;
					}

					var srcValue = node.getAttribute('src');

					if (!srcValue) {
						return false;
					}

					var nodeName = node.nodeName.toUpperCase();

					if (nodeName === 'INPUT' && node.type === 'image') {
						return true;
					}

					var role = aria.getRole(node);

					if (role !== 'img') {
						return false;
					}

					return true;
				},
				tags: ['wcag2', 'wcag111', 'experimental'],
				all: ['filename-is-valid-accessible-name'],
				any: [],
				none: []
			},
			{
				id: 'focus-order-semantics',
				selector: 'div, h1, h2, h3, h4, h5, h6, [role=heading], p, span',
				matches: function matches(node, virtualNode, context) {
					return axe.commons.dom.insertedIntoFocusOrder(node);
				},
				tags: ['cat.keyboard', 'best-practice', 'experimental'],
				all: [],
				any: [
					{
						options: [],
						id: 'has-widget-role'
					},
					{
						options: [],
						id: 'valid-scrollable-semantics'
					}
				],
				none: []
			},
			{
				id: 'form-field-multiple-labels',
				selector: 'input, select, textarea',
				matches: function matches(node, virtualNode, context) {
					if (
						node.nodeName.toLowerCase() !== 'input' ||
						node.hasAttribute('type') === false
					) {
						return true;
					}

					var type = node.getAttribute('type').toLowerCase();
					return (
						['hidden', 'image', 'button', 'submit', 'reset'].includes(type) ===
						false
					);
				},
				tags: ['cat.forms', 'wcag2a', 'wcag332'],
				all: [],
				any: [],
				none: ['multiple-label']
			},
			{
				id: 'frame-tested',
				selector: 'frame, iframe',
				tags: ['cat.structure', 'review-item', 'best-practice'],
				all: [
					{
						options: {
							isViolation: false
						},
						id: 'frame-tested'
					}
				],
				any: [],
				none: []
			},
			{
				id: 'frame-title-unique',
				selector: 'frame, iframe',
				matches: function matches(node, virtualNode, context) {
					var text = axe.commons.text;
					var name = !!text.sanitize(text.accessibleTextVirtual(virtualNode));

					if (!name) {
						return false;
					}

					return true;
				},
				tags: ['cat.text-alternatives', 'best-practice'],
				all: ['unique-frame-title'],
				any: [],
				none: []
			},
			{
				id: 'frame-title',
				selector: 'frame, iframe',
				tags: [
					'cat.text-alternatives',
					'wcag2a',
					'wcag241',
					'wcag412',
					'section508',
					'section508.22.i'
				],
				all: [],
				any: [
					'aria-label',
					'aria-labelledby',
					'non-empty-title',
					'role-presentation',
					'role-none'
				],
				none: []
			},
			{
				id: 'heading-order',
				selector: 'h1, h2, h3, h4, h5, h6, [role=heading]',
				matches: function matches(node, virtualNode, context) {
					// Get all valid roles
					var explicitRoles;

					if (node.hasAttribute('role')) {
						explicitRoles = node
							.getAttribute('role')
							.split(/\s+/i)
							.filter(axe.commons.aria.isValidRole);
					} // Check valid roles if there are any, otherwise fall back to the inherited role

					if (explicitRoles && explicitRoles.length > 0) {
						return explicitRoles.includes('heading');
					} else {
						return axe.commons.aria.implicitRole(node) === 'heading';
					}
				},
				tags: ['cat.semantics', 'best-practice'],
				all: [],
				any: ['heading-order'],
				none: []
			},
			{
				id: 'hidden-content',
				selector: '*',
				excludeHidden: false,
				tags: ['cat.structure', 'experimental', 'review-item', 'best-practice'],
				all: [],
				any: ['hidden-content'],
				none: []
			},
			{
				id: 'html-has-lang',
				selector: 'html',
				matches: function matches(node, virtualNode, context) {
					return (
						node.ownerDocument.defaultView.self ===
						node.ownerDocument.defaultView.top
					);
				},
				tags: ['cat.language', 'wcag2a', 'wcag311'],
				all: [],
				any: ['has-lang'],
				none: []
			},
			{
				id: 'html-lang-valid',
				selector: 'html[lang], html[xml\\:lang]',
				tags: ['cat.language', 'wcag2a', 'wcag311'],
				all: [],
				any: [],
				none: ['valid-lang']
			},
			{
				id: 'html-xml-lang-mismatch',
				selector: 'html[lang][xml\\:lang]',
				matches: function matches(node, virtualNode, context) {
					// using -> "selector": "html[lang][xml\\:lang]" to narrow down html with lang and xml:lang attributes
					// get primary base language for each of the attributes
					var getBaseLang = axe.utils.getBaseLang;
					var primaryLangValue = getBaseLang(node.getAttribute('lang'));
					var primaryXmlLangValue = getBaseLang(node.getAttribute('xml:lang')); // ensure that the value specified is valid lang for both `lang` and `xml:lang`

					return (
						axe.utils.validLangs().includes(primaryLangValue) &&
						axe.utils.validLangs().includes(primaryXmlLangValue)
					);
				},
				tags: ['cat.language', 'wcag2a', 'wcag311'],
				all: ['xml-lang-mismatch'],
				any: [],
				none: []
			},
			{
				id: 'identical-links-same-purpose',
				selector: 'a[href], area[href], [role="link"]',
				excludeHidden: false,
				matches: function matches(node, virtualNode, context) {
					var _axe$commons4 = axe.commons,
						aria = _axe$commons4.aria,
						text = _axe$commons4.text;
					var hasAccName = !!text.accessibleTextVirtual(virtualNode);

					if (!hasAccName) {
						return false;
					}

					var role = aria.getRole(node);

					if (role && role !== 'link') {
						return false;
					}

					return true;
				},
				tags: ['wcag2aaa', 'wcag249', 'best-practice', 'experimental'],
				all: ['identical-links-same-purpose'],
				any: [],
				none: []
			},
			{
				id: 'image-alt',
				selector: 'img',
				tags: [
					'cat.text-alternatives',
					'wcag2a',
					'wcag111',
					'section508',
					'section508.22.a'
				],
				all: [],
				any: [
					'has-alt',
					'aria-label',
					'aria-labelledby',
					'non-empty-title',
					'role-presentation',
					'role-none'
				],
				none: ['alt-space-value']
			},
			{
				id: 'image-redundant-alt',
				selector: 'img',
				tags: ['cat.text-alternatives', 'best-practice'],
				all: [],
				any: [],
				none: ['duplicate-img-label']
			},
			{
				id: 'input-button-name',
				selector:
					'input[type="button"], input[type="submit"], input[type="reset"]',
				tags: [
					'cat.name-role-value',
					'wcag2a',
					'wcag412',
					'section508',
					'section508.22.a'
				],
				all: [],
				any: [
					'non-empty-if-present',
					'non-empty-value',
					'aria-label',
					'aria-labelledby',
					'role-presentation',
					'role-none',
					'non-empty-title'
				],
				none: []
			},
			{
				id: 'input-image-alt',
				selector: 'input[type="image"]',
				tags: [
					'cat.text-alternatives',
					'wcag2a',
					'wcag111',
					'section508',
					'section508.22.a'
				],
				all: [],
				any: [
					'non-empty-alt',
					'aria-label',
					'aria-labelledby',
					'non-empty-title'
				],
				none: []
			},
			{
				id: 'label-content-name-mismatch',
				matches: function matches(node, virtualNode, context) {
					/**
					 * Applicability:
					 * Rule applies to any element that has
					 * a) a semantic role that is `widget` that supports name from content
					 * b) has visible text content
					 * c) has accessible name (eg: `aria-label`)
					 */
					var _axe$commons5 = axe.commons,
						aria = _axe$commons5.aria,
						text = _axe$commons5.text;
					var role = aria.getRole(node);

					if (!role) {
						return false;
					}

					var isWidgetType = aria.lookupTable.rolesOfType.widget.includes(role);

					if (!isWidgetType) {
						return false;
					}

					var rolesWithNameFromContents = aria.getRolesWithNameFromContents();

					if (!rolesWithNameFromContents.includes(role)) {
						return false;
					}
					/**
					 * if no `aria-label` or `aria-labelledby` attribute - ignore `node`
					 */

					if (
						!text.sanitize(aria.arialabelText(virtualNode)) &&
						!text.sanitize(aria.arialabelledbyText(node))
					) {
						return false;
					}
					/**
					 * if no `contentText` - ignore `node`
					 */

					if (!text.sanitize(text.visibleVirtual(virtualNode))) {
						return false;
					}

					return true;
				},
				tags: ['wcag21a', 'wcag253', 'experimental'],
				all: [],
				any: [
					{
						options: {
							pixelThreshold: 0.1,
							occuranceThreshold: 3
						},
						id: 'label-content-name-mismatch'
					}
				],
				none: []
			},
			{
				id: 'label-title-only',
				selector: 'input, select, textarea',
				matches: function matches(node, virtualNode, context) {
					if (
						node.nodeName.toLowerCase() !== 'input' ||
						node.hasAttribute('type') === false
					) {
						return true;
					}

					var type = node.getAttribute('type').toLowerCase();
					return (
						['hidden', 'image', 'button', 'submit', 'reset'].includes(type) ===
						false
					);
				},
				tags: ['cat.forms', 'best-practice'],
				all: [],
				any: [],
				none: ['title-only']
			},
			{
				id: 'label',
				selector: 'input, select, textarea',
				matches: function matches(node, virtualNode, context) {
					if (
						node.nodeName.toLowerCase() !== 'input' ||
						node.hasAttribute('type') === false
					) {
						return true;
					}

					var type = node.getAttribute('type').toLowerCase();
					return (
						['hidden', 'image', 'button', 'submit', 'reset'].includes(type) ===
						false
					);
				},
				tags: [
					'cat.forms',
					'wcag2a',
					'wcag332',
					'wcag131',
					'section508',
					'section508.22.n'
				],
				all: [],
				any: [
					'aria-label',
					'aria-labelledby',
					'implicit-label',
					'explicit-label',
					'non-empty-title'
				],
				none: ['help-same-as-label', 'hidden-explicit-label']
			},
			{
				id: 'landmark-banner-is-top-level',
				selector: 'header:not([role]), [role=banner]',
				matches: function matches(node, virtualNode, context) {
					var nativeScopeFilter = 'article, aside, main, nav, section'; // Filter elements that, within certain contexts, don't map their role.
					// e.g. a <header> inside a <main> is not a banner, but in the <body> context it is

					return (
						node.hasAttribute('role') ||
						!axe.commons.dom.findUpVirtual(virtualNode, nativeScopeFilter)
					);
				},
				tags: ['cat.semantics', 'best-practice'],
				all: [],
				any: ['landmark-is-top-level'],
				none: []
			},
			{
				id: 'landmark-complementary-is-top-level',
				selector: 'aside:not([role]), [role=complementary]',
				tags: ['cat.semantics', 'best-practice'],
				all: [],
				any: ['landmark-is-top-level'],
				none: []
			},
			{
				id: 'landmark-contentinfo-is-top-level',
				selector: 'footer:not([role]), [role=contentinfo]',
				matches: function matches(node, virtualNode, context) {
					var nativeScopeFilter = 'article, aside, main, nav, section'; // Filter elements that, within certain contexts, don't map their role.
					// e.g. a <header> inside a <main> is not a banner, but in the <body> context it is

					return (
						node.hasAttribute('role') ||
						!axe.commons.dom.findUpVirtual(virtualNode, nativeScopeFilter)
					);
				},
				tags: ['cat.semantics', 'best-practice'],
				all: [],
				any: ['landmark-is-top-level'],
				none: []
			},
			{
				id: 'landmark-main-is-top-level',
				selector: 'main:not([role]), [role=main]',
				tags: ['cat.semantics', 'best-practice'],
				all: [],
				any: ['landmark-is-top-level'],
				none: []
			},
			{
				id: 'landmark-no-duplicate-banner',
				selector: 'html',
				tags: ['cat.semantics', 'best-practice'],
				all: [],
				any: [
					{
						options: {
							selector: 'header:not([role]), [role=banner]',
							nativeScopeFilter: 'article, aside, main, nav, section'
						},
						id: 'page-no-duplicate-banner'
					}
				],
				none: []
			},
			{
				id: 'landmark-no-duplicate-contentinfo',
				selector: 'html',
				tags: ['cat.semantics', 'best-practice'],
				all: [],
				any: [
					{
						options: {
							selector: 'footer:not([role]), [role=contentinfo]',
							nativeScopeFilter: 'article, aside, main, nav, section'
						},
						id: 'page-no-duplicate-contentinfo'
					}
				],
				none: []
			},
			{
				id: 'landmark-one-main',
				selector: 'html',
				tags: ['cat.semantics', 'best-practice'],
				all: [
					{
						options: {
							selector: "main:not([role]), [role='main']"
						},
						id: 'page-has-main'
					},
					{
						options: {
							selector: "main:not([role]), [role='main']"
						},
						id: 'page-no-duplicate-main'
					}
				],
				any: [],
				none: []
			},
			{
				id: 'landmark-unique',
				selector:
					'[role=banner], [role=complementary], [role=contentinfo], [role=main], [role=navigation], [role=region], [role=search], [role=form], form, footer, header, aside, main, nav, section',
				tags: ['cat.semantics', 'best-practice'],
				matches: function matches(node, virtualNode, context) {
					/*
					 * Since this is a best-practice rule, we are filtering elements as dictated by ARIA 1.1 Practices regardless of treatment by browser/AT combinations.
					 *
					 * Info: https://www.w3.org/TR/wai-aria-practices-1.1/#aria_landmark
					 */
					var excludedParentsForHeaderFooterLandmarks = [
						'article',
						'aside',
						'main',
						'nav',
						'section'
					].join(',');

					function isHeaderFooterLandmark(headerFooterElement) {
						return !axe.commons.dom.findUpVirtual(
							headerFooterElement,
							excludedParentsForHeaderFooterLandmarks
						);
					}

					function isLandmarkVirtual(virtualNode) {
						var actualNode = virtualNode.actualNode;
						var landmarkRoles = axe.commons.aria.getRolesByType('landmark');
						var role = axe.commons.aria.getRole(actualNode);

						if (!role) {
							return false;
						}

						var nodeName = actualNode.nodeName.toUpperCase();

						if (nodeName === 'HEADER' || nodeName === 'FOOTER') {
							return isHeaderFooterLandmark(virtualNode);
						}

						if (nodeName === 'SECTION' || nodeName === 'FORM') {
							var accessibleText = axe.commons.text.accessibleTextVirtual(
								virtualNode
							);
							return !!accessibleText;
						}

						return landmarkRoles.indexOf(role) >= 0 || role === 'region';
					}

					return (
						isLandmarkVirtual(virtualNode) &&
						axe.commons.dom.isVisible(node, true)
					);
				},
				all: [],
				any: ['landmark-is-unique'],
				none: []
			},
			{
				id: 'layout-table',
				selector: 'table',
				matches: function matches(node, virtualNode, context) {
					var role = (node.getAttribute('role') || '').toLowerCase();
					return (
						!(
							(role === 'presentation' || role === 'none') &&
							!axe.commons.dom.isFocusable(node)
						) && !axe.commons.table.isDataTable(node)
					);
				},
				tags: ['cat.semantics', 'wcag2a', 'wcag131', 'deprecated'],
				enabled: false,
				all: [],
				any: [],
				none: ['has-th', 'has-caption', 'has-summary']
			},
			{
				id: 'link-in-text-block',
				selector: 'a[href], [role=link]',
				matches: function matches(node, virtualNode, context) {
					var text = axe.commons.text.sanitize(node.textContent);
					var role = node.getAttribute('role');

					if (role && role !== 'link') {
						return false;
					}

					if (!text) {
						return false;
					}

					if (!axe.commons.dom.isVisible(node, false)) {
						return false;
					}

					return axe.commons.dom.isInTextBlock(node);
				},
				excludeHidden: false,
				tags: ['cat.color', 'experimental', 'wcag2a', 'wcag141'],
				all: ['link-in-text-block'],
				any: [],
				none: []
			},
			{
				id: 'link-name',
				selector: 'a[href]:not([role=button]), [role=link]',
				tags: [
					'cat.name-role-value',
					'wcag2a',
					'wcag412',
					'wcag244',
					'section508',
					'section508.22.a'
				],
				all: [],
				any: [
					'has-visible-text',
					'aria-label',
					'aria-labelledby',
					'role-presentation',
					'role-none'
				],
				none: ['focusable-no-name']
			},
			{
				id: 'list',
				selector: 'ul, ol',
				matches: function matches(node, virtualNode, context) {
					return !node.getAttribute('role');
				},
				tags: ['cat.structure', 'wcag2a', 'wcag131'],
				all: [],
				any: [],
				none: ['only-listitems']
			},
			{
				id: 'listitem',
				selector: 'li',
				matches: function matches(node, virtualNode, context) {
					return !node.getAttribute('role');
				},
				tags: ['cat.structure', 'wcag2a', 'wcag131'],
				all: [],
				any: ['listitem'],
				none: []
			},
			{
				id: 'marquee',
				selector: 'marquee',
				excludeHidden: false,
				tags: ['cat.parsing', 'wcag2a', 'wcag222'],
				all: [],
				any: [],
				none: ['is-on-screen']
			},
			{
				id: 'meta-refresh',
				selector: 'meta[http-equiv="refresh"]',
				excludeHidden: false,
				tags: [
					'cat.time-and-media',
					'wcag2a',
					'wcag2aaa',
					'wcag221',
					'wcag224',
					'wcag325'
				],
				all: [],
				any: ['meta-refresh'],
				none: []
			},
			{
				id: 'meta-viewport-large',
				selector: 'meta[name="viewport"]',
				excludeHidden: false,
				tags: ['cat.sensory-and-visual-cues', 'best-practice'],
				all: [],
				any: [
					{
						options: {
							scaleMinimum: 5,
							lowerBound: 2
						},
						id: 'meta-viewport-large'
					}
				],
				none: []
			},
			{
				id: 'meta-viewport',
				selector: 'meta[name="viewport"]',
				excludeHidden: false,
				tags: ['cat.sensory-and-visual-cues', 'wcag2aa', 'wcag144'],
				all: [],
				any: [
					{
						options: {
							scaleMinimum: 2
						},
						id: 'meta-viewport'
					}
				],
				none: []
			},
			{
				id: 'no-autoplay-audio',
				selector: 'audio[autoplay="true"], video[autoplay="true"]',
				matches: function matches(node, virtualNode, context) {
					/**
					 * Ignore media nodes without `src`
					 */
					if (!node.currentSrc) {
						return false;
					}
					/**
					 * Ignore media nodes which are `paused` or `muted`
					 */

					if (node.hasAttribute('paused') || node.hasAttribute('muted')) {
						return false;
					}
					/**
					 * Ignore media nodes where `duration` is less than 3 seconds & not looping
					 */

					if (
						node.duration &&
						node.duration < 3 &&
						!node.hasAttribute('loop')
					) {
						return false;
					}

					return true;
				},
				tags: ['wcag2a', 'wcag142', 'experimental'],
				preload: true,
				all: [
					{
						options: {
							allowedDuration: 3
						},
						id: 'no-autoplay-audio'
					}
				],
				any: [],
				none: []
			},
			{
				id: 'object-alt',
				selector: 'object',
				tags: [
					'cat.text-alternatives',
					'wcag2a',
					'wcag111',
					'section508',
					'section508.22.a'
				],
				all: [],
				any: [
					'has-visible-text',
					'aria-label',
					'aria-labelledby',
					'non-empty-title',
					'role-presentation',
					'role-none'
				],
				none: []
			},
			{
				id: 'p-as-heading',
				selector: 'p',
				matches: function matches(node, virtualNode, context) {
					var children = Array.from(node.parentNode.childNodes);
					var nodeText = node.textContent.trim();
					var isSentence = /[.!?:;](?![.!?:;])/g; // Check that there is text, and it is not more than a single sentence

					if (
						nodeText.length === 0 ||
						(nodeText.match(isSentence) || []).length >= 2
					) {
						return false;
					} // Grab sibling p element following the current node

					var siblingsAfter = children
						.slice(children.indexOf(node) + 1)
						.filter(function(elm) {
							return (
								elm.nodeName.toUpperCase() === 'P' &&
								elm.textContent.trim() !== ''
							);
						});
					return siblingsAfter.length !== 0;
				},
				tags: ['cat.semantics', 'wcag2a', 'wcag131', 'experimental'],
				all: [
					{
						options: {
							margins: [
								{
									weight: 150,
									italic: true
								},
								{
									weight: 150,
									size: 1.15
								},
								{
									italic: true,
									size: 1.15
								},
								{
									size: 1.4
								}
							]
						},
						id: 'p-as-heading'
					}
				],
				any: [],
				none: []
			},
			{
				id: 'page-has-heading-one',
				selector: 'html',
				tags: ['cat.semantics', 'best-practice'],
				all: [
					{
						options: {
							selector: 'h1:not([role]), [role="heading"][aria-level="1"]'
						},
						id: 'page-has-heading-one'
					}
				],
				any: [],
				none: []
			},
			{
				id: 'radiogroup',
				selector: 'input[type=radio][name]',
				tags: ['cat.forms', 'best-practice', 'deprecated'],
				enabled: false,
				all: [],
				any: ['group-labelledby', 'fieldset'],
				none: []
			},
			{
				id: 'region',
				selector: 'html',
				pageLevel: true,
				tags: ['cat.keyboard', 'best-practice'],
				all: [],
				any: ['region'],
				none: []
			},
			{
				id: 'role-img-alt',
				selector: "[role='img']:not(img):not(area):not(input):not(object)",
				matches: function matches(node, virtualNode, context) {
					return node.namespaceURI === 'http://www.w3.org/1999/xhtml';
				},
				tags: [
					'cat.text-alternatives',
					'wcag2a',
					'wcag111',
					'section508',
					'section508.22.a'
				],
				all: [],
				any: ['aria-label', 'aria-labelledby', 'non-empty-title'],
				none: []
			},
			{
				id: 'scope-attr-valid',
				selector: 'td[scope], th[scope]',
				tags: ['cat.tables', 'best-practice'],
				all: ['html5-scope', 'scope-value'],
				any: [],
				none: []
			},
			{
				id: 'scrollable-region-focusable',
				matches: function matches(node, virtualNode, context) {
					/**
					 * Note:
					 * `excludeHidden=true` for this rule, thus considering only elements in the accessibility tree.
					 */
					var querySelectorAll = axe.utils.querySelectorAll;
					var hasContentVirtual = axe.commons.dom.hasContentVirtual;
					/**
					 * if not scrollable -> `return`
					 */

					if (!!axe.utils.getScroll(node, 13) === false) {
						return false;
					}
					/**
					 * check if node has visible contents
					 */

					var nodeAndDescendents = querySelectorAll(virtualNode, '*');
					var hasVisibleChildren = nodeAndDescendents.some(function(elm) {
						return hasContentVirtual(
							elm,
							true, // noRecursion
							true // ignoreAria
						);
					});

					if (!hasVisibleChildren) {
						return false;
					}

					return true;
				},
				tags: ['wcag2a', 'wcag211'],
				all: [],
				any: ['focusable-content', 'focusable-element'],
				none: []
			},
			{
				id: 'server-side-image-map',
				selector: 'img[ismap]',
				tags: [
					'cat.text-alternatives',
					'wcag2a',
					'wcag211',
					'section508',
					'section508.22.f'
				],
				all: [],
				any: [],
				none: ['exists']
			},
			{
				id: 'skip-link',
				selector: 'a[href^="#"], a[href^="/#"]',
				matches: function matches(node, virtualNode, context) {
					return axe.commons.dom.isSkipLink(node);
				},
				tags: ['cat.keyboard', 'best-practice'],
				all: [],
				any: ['skip-link'],
				none: []
			},
			{
				id: 'svg-img-alt',
				selector:
					'[role="img"], [role="graphics-symbol"], svg[role="graphics-document"]',
				matches: function matches(node, virtualNode, context) {
					return node.namespaceURI === 'http://www.w3.org/2000/svg';
				},
				tags: [
					'cat.text-alternatives',
					'wcag2a',
					'wcag111',
					'section508',
					'section508.22.a'
				],
				all: [],
				any: [
					'svg-non-empty-title',
					'aria-label',
					'aria-labelledby',
					'non-empty-title'
				],
				none: []
			},
			{
				id: 'tabindex',
				selector: '[tabindex]',
				tags: ['cat.keyboard', 'best-practice'],
				all: [],
				any: ['tabindex'],
				none: []
			},
			{
				id: 'table-duplicate-name',
				selector: 'table',
				tags: ['cat.tables', 'best-practice'],
				all: [],
				any: [],
				none: ['same-caption-summary']
			},
			{
				id: 'table-fake-caption',
				selector: 'table',
				matches: function matches(node, virtualNode, context) {
					return axe.commons.table.isDataTable(node);
				},
				tags: [
					'cat.tables',
					'experimental',
					'wcag2a',
					'wcag131',
					'section508',
					'section508.22.g'
				],
				all: ['caption-faked'],
				any: [],
				none: []
			},
			{
				id: 'td-has-header',
				selector: 'table',
				matches: function matches(node, virtualNode, context) {
					if (axe.commons.table.isDataTable(node)) {
						var tableArray = axe.commons.table.toArray(node);
						return (
							tableArray.length >= 3 &&
							tableArray[0].length >= 3 &&
							tableArray[1].length >= 3 &&
							tableArray[2].length >= 3
						);
					}

					return false;
				},
				tags: [
					'cat.tables',
					'experimental',
					'wcag2a',
					'wcag131',
					'section508',
					'section508.22.g'
				],
				all: ['td-has-header'],
				any: [],
				none: []
			},
			{
				id: 'td-headers-attr',
				selector: 'table',
				tags: [
					'cat.tables',
					'wcag2a',
					'wcag131',
					'section508',
					'section508.22.g'
				],
				all: ['td-headers-attr'],
				any: [],
				none: []
			},
			{
				id: 'th-has-data-cells',
				selector: 'table',
				matches: function matches(node, virtualNode, context) {
					return axe.commons.table.isDataTable(node);
				},
				tags: [
					'cat.tables',
					'wcag2a',
					'wcag131',
					'section508',
					'section508.22.g'
				],
				all: ['th-has-data-cells'],
				any: [],
				none: []
			},
			{
				id: 'valid-lang',
				selector: '[lang], [xml\\:lang]',
				matches: function matches(node, virtualNode, context) {
					return node.nodeName.toLowerCase() !== 'html';
				},
				tags: ['cat.language', 'wcag2aa', 'wcag312'],
				all: [],
				any: [],
				none: ['valid-lang']
			},
			{
				id: 'video-caption',
				selector: 'video',
				excludeHidden: false,
				tags: [
					'cat.text-alternatives',
					'wcag2a',
					'wcag122',
					'section508',
					'section508.22.a'
				],
				all: [],
				any: [],
				none: ['caption']
			},
			{
				id: 'video-description',
				selector: 'video',
				excludeHidden: false,
				tags: [
					'cat.text-alternatives',
					'wcag2aa',
					'wcag125',
					'section508',
					'section508.22.b',
					'deprecated'
				],
				enabled: false,
				all: [],
				any: [],
				none: ['description']
			}
		],
		checks: [
			{
				id: 'abstractrole',
				evaluate: function evaluate(node, options, virtualNode, context) {
					return (
						axe.commons.aria.getRoleType(node.getAttribute('role')) ===
						'abstract'
					);
				}
			},
			{
				id: 'aria-allowed-attr',
				evaluate: function evaluate(node, options, virtualNode, context) {
					options = options || {};
					var invalid = [];
					var attr,
						attrName,
						allowed,
						role = node.getAttribute('role'),
						attrs = axe.utils.getNodeAttributes(node);

					if (!role) {
						role = axe.commons.aria.implicitRole(node);
					}

					allowed = axe.commons.aria.allowedAttr(role);

					if (Array.isArray(options[role])) {
						allowed = axe.utils.uniqueArray(options[role].concat(allowed));
					}

					if (role && allowed) {
						for (var i = 0, l = attrs.length; i < l; i++) {
							attr = attrs[i];
							attrName = attr.name;

							if (
								axe.commons.aria.validateAttr(attrName) &&
								!allowed.includes(attrName)
							) {
								invalid.push(attrName + '="' + attr.nodeValue + '"');
							}
						}
					}

					if (invalid.length) {
						this.data(invalid);
						return false;
					}

					return true;
				}
			},
			{
				id: 'aria-allowed-role',
				evaluate: function evaluate(node, options, virtualNode, context) {
					/**
					 * Implements allowed roles defined at:
					 * https://www.w3.org/TR/html-aria/#docconformance
					 * https://www.w3.org/TR/SVG2/struct.html#implicit-aria-semantics
					 */
					var dom = axe.commons.dom;

					var _ref = options || {},
						_ref$allowImplicit = _ref.allowImplicit,
						allowImplicit =
							_ref$allowImplicit === void 0 ? true : _ref$allowImplicit,
						_ref$ignoredTags = _ref.ignoredTags,
						ignoredTags = _ref$ignoredTags === void 0 ? [] : _ref$ignoredTags;

					var tagName = node.nodeName.toUpperCase(); // check if the element should be ignored, by an user setting

					if (
						ignoredTags
							.map(function(t) {
								return t.toUpperCase();
							})
							.includes(tagName)
					) {
						return true;
					}

					var unallowedRoles = axe.commons.aria.getElementUnallowedRoles(
						node,
						allowImplicit
					);

					if (unallowedRoles.length) {
						this.data(unallowedRoles);

						if (!dom.isVisible(node, true)) {
							// flag hidden elements for review
							return undefined;
						}

						return false;
					}

					return true;
				},
				options: {
					allowImplicit: true,
					ignoredTags: []
				}
			},
			{
				id: 'aria-hidden-body',
				evaluate: function evaluate(node, options, virtualNode, context) {
					return node.getAttribute('aria-hidden') !== 'true';
				}
			},
			{
				id: 'aria-roledescription',
				evaluate: function evaluate(node, options, virtualNode, context) {
					options = options || {};
					var role = axe.commons.aria.getRole(node);
					var supportedRoles = options.supportedRoles || [];

					if (supportedRoles.includes(role)) {
						return true;
					}

					if (role && role !== 'presentation' && role !== 'none') {
						return undefined;
					}

					return false;
				},
				options: {
					supportedRoles: [
						'button',
						'img',
						'checkbox',
						'radio',
						'combobox',
						'menuitemcheckbox',
						'menuitemradio'
					]
				}
			},
			{
				id: 'aria-errormessage',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var _axe$commons6 = axe.commons,
						aria = _axe$commons6.aria,
						dom = _axe$commons6.dom;
					options = Array.isArray(options) ? options : [];
					var attr = node.getAttribute('aria-errormessage');
					var hasAttr = node.hasAttribute('aria-errormessage');
					var doc = dom.getRootNode(node);

					function validateAttrValue(attr) {
						if (attr.trim() === '') {
							return aria.lookupTable.attributes['aria-errormessage']
								.allowEmpty;
						}

						var idref = attr && doc.getElementById(attr);

						if (idref) {
							return (
								idref.getAttribute('role') === 'alert' ||
								idref.getAttribute('aria-live') === 'assertive' ||
								axe.utils
									.tokenList(node.getAttribute('aria-describedby') || '')
									.indexOf(attr) > -1
							);
						}
					} // limit results to elements that actually have this attribute

					if (options.indexOf(attr) === -1 && hasAttr) {
						if (!validateAttrValue(attr)) {
							this.data(axe.utils.tokenList(attr));
							return false;
						}
					}

					return true;
				}
			},
			{
				id: 'has-widget-role',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var role = node.getAttribute('role');

					if (role === null) {
						return false;
					}

					var roleType = axe.commons.aria.getRoleType(role);
					return roleType === 'widget' || roleType === 'composite';
				},
				options: []
			},
			{
				id: 'implicit-role-fallback',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var role = node.getAttribute('role');

					if (role === null || !axe.commons.aria.isValidRole(role)) {
						return true;
					}

					var roleType = axe.commons.aria.getRoleType(role);
					return axe.commons.aria.implicitRole(node) === roleType;
				},
				deprecated: true
			},
			{
				id: 'invalidrole',
				evaluate: function evaluate(node, options, virtualNode, context) {
					return !axe.commons.aria.isValidRole(node.getAttribute('role'), {
						allowAbstract: true
					});
				}
			},
			{
				id: 'no-implicit-explicit-label',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var _axe$commons7 = axe.commons,
						aria = _axe$commons7.aria,
						text = _axe$commons7.text;
					var role = aria.getRole(node, {
						noImplicit: true
					});
					this.data(role);
					var labelText = text
						.sanitize(text.labelText(virtualNode))
						.toLowerCase();
					var accText = text.sanitize(text.accessibleText(node)).toLowerCase();

					if (!accText && !labelText) {
						return false;
					}

					if (!accText && labelText) {
						return undefined;
					}

					if (!accText.includes(labelText)) {
						return undefined;
					}

					return false;
				}
			},
			{
				id: 'aria-required-attr',
				evaluate: function evaluate(node, options, virtualNode, context) {
					options = options || {};
					var missing = [];
					var _axe$commons$forms = axe.commons.forms,
						isNativeTextbox = _axe$commons$forms.isNativeTextbox,
						isNativeSelect = _axe$commons$forms.isNativeSelect,
						isAriaTextbox = _axe$commons$forms.isAriaTextbox,
						isAriaListbox = _axe$commons$forms.isAriaListbox,
						isAriaCombobox = _axe$commons$forms.isAriaCombobox,
						isAriaRange = _axe$commons$forms.isAriaRange; // aria-valuenow should fail if element does not have a value property
					// @see https://github.com/dequelabs/axe-core/issues/1501

					var preChecks = {
						'aria-valuenow': function ariaValuenow() {
							return !(
								isNativeTextbox(node) ||
								isNativeSelect(node) ||
								isAriaTextbox(node) ||
								isAriaListbox(node) ||
								isAriaCombobox(node) ||
								(isAriaRange(node) && node.hasAttribute('aria-valuenow'))
							);
						}
					};

					if (node.hasAttributes()) {
						var role = node.getAttribute('role');
						var required = axe.commons.aria.requiredAttr(role);

						if (Array.isArray(options[role])) {
							required = axe.utils.uniqueArray(options[role], required);
						}

						if (role && required) {
							for (var i = 0, l = required.length; i < l; i++) {
								var attr = required[i];

								if (
									!node.getAttribute(attr) &&
									(preChecks[attr] ? preChecks[attr]() : true)
								) {
									missing.push(attr);
								}
							}
						}
					}

					if (missing.length) {
						this.data(missing);
						return false;
					}

					return true;
				}
			},
			{
				id: 'aria-required-children',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var requiredOwned = axe.commons.aria.requiredOwned;
					var implicitNodes = axe.commons.aria.implicitNodes;
					var matchesSelector = axe.utils.matchesSelector;
					var idrefs = axe.commons.dom.idrefs;
					var hasContentVirtual = axe.commons.dom.hasContentVirtual;
					var reviewEmpty =
						options && Array.isArray(options.reviewEmpty)
							? options.reviewEmpty
							: [];

					function owns(node, virtualTree, role, ariaOwned) {
						if (node === null) {
							return false;
						}

						var implicit = implicitNodes(role),
							selector = ['[role="' + role + '"]'];

						if (implicit) {
							selector = selector.concat(
								implicit.map(function(implicitSelector) {
									return implicitSelector + ':not([role])';
								})
							);
						}

						selector = selector.join(',');
						return ariaOwned
							? matchesSelector(node, selector) ||
									!!axe.utils.querySelectorAll(virtualTree, selector)[0]
							: !!axe.utils.querySelectorAll(virtualTree, selector)[0];
					}

					function ariaOwns(nodes, role) {
						var index, length;

						for (index = 0, length = nodes.length; index < length; index++) {
							if (nodes[index] === null) {
								continue;
							}

							var virtualTree = axe.utils.getNodeFromTree(nodes[index]);

							if (owns(nodes[index], virtualTree, role, true)) {
								return true;
							}
						}

						return false;
					}

					function missingRequiredChildren(node, childRoles, all, role) {
						var index,
							length = childRoles.length,
							missing = [],
							ownedElements = idrefs(node, 'aria-owns');

						for (index = 0; index < length; index++) {
							var childRole = childRoles[index];

							if (
								owns(node, virtualNode, childRole) ||
								ariaOwns(ownedElements, childRole)
							) {
								if (!all) {
									return null;
								}
							} else {
								if (all) {
									missing.push(childRole);
								}
							}
						} // combobox exceptions

						if (role === 'combobox') {
							// remove 'textbox' from missing roles if combobox is a native text-type input or owns a 'searchbox'
							var textboxIndex = missing.indexOf('textbox');
							var textTypeInputs = ['text', 'search', 'email', 'url', 'tel'];

							if (
								(textboxIndex >= 0 &&
									node.nodeName.toUpperCase() === 'INPUT' &&
									textTypeInputs.includes(node.type)) ||
								owns(node, virtualNode, 'searchbox') ||
								ariaOwns(ownedElements, 'searchbox')
							) {
								missing.splice(textboxIndex, 1);
							} // remove 'listbox' from missing roles if combobox is collapsed

							var listboxIndex = missing.indexOf('listbox');
							var expanded = node.getAttribute('aria-expanded');

							if (listboxIndex >= 0 && (!expanded || expanded === 'false')) {
								missing.splice(listboxIndex, 1);
							}
						}

						if (missing.length) {
							return missing;
						}

						if (!all && childRoles.length) {
							return childRoles;
						}

						return null;
					}

					function hasDecendantWithRole(node) {
						return (
							node.children &&
							node.children.some(function(child) {
								var role = axe.commons.aria.getRole(child);
								return (
									!['presentation', 'none', null].includes(role) ||
									hasDecendantWithRole(child)
								);
							})
						);
					}

					var role = node.getAttribute('role');
					var required = requiredOwned(role);

					if (!required) {
						return true;
					}

					var all = false;
					var childRoles = required.one;

					if (!childRoles) {
						var all = true;
						childRoles = required.all;
					}

					var missing = missingRequiredChildren(node, childRoles, all, role);

					if (!missing) {
						return true;
					}

					this.data(missing); // Only review empty nodes when a node is both empty and does not have an aria-owns relationship

					if (
						reviewEmpty.includes(role) &&
						!hasContentVirtual(virtualNode, false, true) &&
						!hasDecendantWithRole(virtualNode) &&
						idrefs(node, 'aria-owns').length === 0
					) {
						return undefined;
					} else {
						return false;
					}
				},
				options: {
					reviewEmpty: [
						'doc-bibliography',
						'doc-endnotes',
						'grid',
						'list',
						'listbox',
						'table',
						'tablist',
						'tree',
						'treegrid',
						'rowgroup'
					]
				}
			},
			{
				id: 'aria-required-parent',
				evaluate: function evaluate(node, options, virtualNode, context) {
					function getSelector(role) {
						var impliedNative = axe.commons.aria.implicitNodes(role) || [];
						return impliedNative.concat('[role="' + role + '"]').join(',');
					}

					function getMissingContext(
						virtualNode,
						requiredContext,
						includeElement
					) {
						var index,
							length,
							role = virtualNode.actualNode.getAttribute('role'),
							missing = [];

						if (!requiredContext) {
							requiredContext = axe.commons.aria.requiredContext(role);
						}

						if (!requiredContext) {
							return null;
						}

						for (
							index = 0, length = requiredContext.length;
							index < length;
							index++
						) {
							if (
								includeElement &&
								axe.utils.matchesSelector(
									virtualNode.actualNode,
									getSelector(requiredContext[index])
								)
							) {
								return null;
							}

							if (
								axe.commons.dom.findUpVirtual(
									virtualNode,
									getSelector(requiredContext[index])
								)
							) {
								//if one matches, it passes
								return null;
							} else {
								missing.push(requiredContext[index]);
							}
						}

						return missing;
					}

					function getAriaOwners(element) {
						var owners = [],
							o = null;

						while (element) {
							if (element.getAttribute('id')) {
								var id = axe.utils.escapeSelector(element.getAttribute('id'));
								var doc = axe.commons.dom.getRootNode(element);
								o = doc.querySelector('[aria-owns~='.concat(id, ']'));

								if (o) {
									owners.push(o);
								}
							}

							element = element.parentElement;
						}

						return owners.length ? owners : null;
					}

					var missingParents = getMissingContext(virtualNode);

					if (!missingParents) {
						return true;
					}

					var owners = getAriaOwners(node);

					if (owners) {
						for (var i = 0, l = owners.length; i < l; i++) {
							missingParents = getMissingContext(
								axe.utils.getNodeFromTree(owners[i]),
								missingParents,
								true
							);

							if (!missingParents) {
								return true;
							}
						}
					}

					this.data(missingParents);
					return false;
				}
			},
			{
				id: 'aria-unsupported-attr',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var nodeName = node.nodeName.toUpperCase();
					var lookupTable = axe.commons.aria.lookupTable;
					var role = axe.commons.aria.getRole(node);
					var unsupportedAttrs = Array.from(axe.utils.getNodeAttributes(node))
						.filter(function(_ref2) {
							var name = _ref2.name;
							var attribute = lookupTable.attributes[name];

							if (!axe.commons.aria.validateAttr(name)) {
								return false;
							}

							var unsupported = attribute.unsupported;

							if (_typeof(unsupported) !== 'object') {
								return !!unsupported;
							} // validate attributes and conditions (if any) from allowedElement to given node

							var isException = axe.commons.matches(
								node,
								unsupported.exceptions
							);

							if (
								!Object.keys(lookupTable.evaluateRoleForElement).includes(
									nodeName
								)
							) {
								return !isException;
							} // evaluate a given aria-role, execute the same

							return !lookupTable.evaluateRoleForElement[nodeName]({
								node: node,
								role: role,
								out: isException
							});
						})
						.map(function(candidate) {
							return candidate.name.toString();
						});

					if (unsupportedAttrs.length) {
						this.data(unsupportedAttrs);
						return true;
					}

					return false;
				}
			},
			{
				id: 'unsupportedrole',
				evaluate: function evaluate(node, options, virtualNode, context) {
					return axe.commons.aria.isUnsupportedRole(
						axe.commons.aria.getRole(node)
					);
				}
			},
			{
				id: 'aria-valid-attr-value',
				evaluate: function evaluate(node, options, virtualNode, context) {
					options = Array.isArray(options) ? options : [];
					var needsReview = [];
					var invalid = [];
					var aria = /^aria-/;
					var attrs = axe.utils.getNodeAttributes(node);
					var skipAttrs = ['aria-errormessage'];
					var preChecks = {
						// aria-controls should only check if element exists if the element
						// doesn't have aria-expanded=false or aria-selected=false (tabs)
						// @see https://github.com/dequelabs/axe-core/issues/1463
						'aria-controls': function ariaControls() {
							return (
								node.getAttribute('aria-expanded') !== 'false' &&
								node.getAttribute('aria-selected') !== 'false'
							);
						},
						// aria-owns should only check if element exists if the element
						// doesn't have aria-expanded=false (combobox)
						// @see https://github.com/dequelabs/axe-core/issues/1524
						'aria-owns': function ariaOwns() {
							return node.getAttribute('aria-expanded') !== 'false';
						},
						// aria-describedby should not mark missing element as violation but
						// instead as needs review
						// @see https://github.com/dequelabs/axe-core/issues/1151
						'aria-describedby': function ariaDescribedby() {
							if (
								!axe.commons.aria.validateAttrValue(node, 'aria-describedby')
							) {
								needsReview.push(
									'aria-describedby="'.concat(
										node.getAttribute('aria-describedby'),
										'"'
									)
								);
							}

							return;
						}
					};

					for (var i = 0, l = attrs.length; i < l; i++) {
						var attr = attrs[i];
						var attrName = attr.name; // skip any attributes handled elsewhere

						if (
							!skipAttrs.includes(attrName) &&
							options.indexOf(attrName) === -1 &&
							aria.test(attrName) &&
							(preChecks[attrName] ? preChecks[attrName]() : true) &&
							!axe.commons.aria.validateAttrValue(node, attrName)
						) {
							invalid.push(
								''.concat(attrName, '="').concat(attr.nodeValue, '"')
							);
						}
					}

					if (needsReview.length) {
						this.data(needsReview);
						return undefined;
					}

					if (invalid.length) {
						this.data(invalid);
						return false;
					}

					return true;
				},
				options: []
			},
			{
				id: 'aria-valid-attr',
				evaluate: function evaluate(node, options, virtualNode, context) {
					options = Array.isArray(options) ? options : [];
					var invalid = [],
						aria = /^aria-/;
					var attr,
						attrs = axe.utils.getNodeAttributes(node);

					for (var i = 0, l = attrs.length; i < l; i++) {
						attr = attrs[i].name;

						if (
							options.indexOf(attr) === -1 &&
							aria.test(attr) &&
							!axe.commons.aria.validateAttr(attr)
						) {
							invalid.push(attr);
						}
					}

					if (invalid.length) {
						this.data(invalid);
						return false;
					}

					return true;
				},
				options: []
			},
			{
				id: 'valid-scrollable-semantics',
				evaluate: function evaluate(node, options, virtualNode, context) {
					/**
					 * A map from HTML tag names to a boolean which reflects whether it is
					 * appropriate for scrollable elements found in the focus order.
					 */
					var VALID_TAG_NAMES_FOR_SCROLLABLE_REGIONS = {
						ARTICLE: true,
						ASIDE: true,
						NAV: true,
						SECTION: true
					};
					/**
					 * A map from each landmark role to a boolean which reflects whether it is
					 * appropriate for scrollable elements found in the focus order.
					 */

					var VALID_ROLES_FOR_SCROLLABLE_REGIONS = {
						application: true,
						banner: false,
						complementary: true,
						contentinfo: true,
						form: true,
						main: true,
						navigation: true,
						region: true,
						search: false
					};
					/**
					 * @param {HTMLElement} node
					 * @return {Boolean} Whether the element has a tag appropriate for a scrollable
					 *		 region.
					 */

					function validScrollableTagName(node) {
						// Some elements with nonsensical roles will pass this check, but should be
						// flagged by other checks.
						var nodeName = node.nodeName.toUpperCase();
						return VALID_TAG_NAMES_FOR_SCROLLABLE_REGIONS[nodeName] || false;
					}
					/**
					 * @param {HTMLElement} node
					 * @return {Boolean} Whether the node has a role appropriate for a scrollable
					 *		 region.
					 */

					function validScrollableRole(node) {
						var role = node.getAttribute('role');

						if (!role) {
							return false;
						}

						return (
							VALID_ROLES_FOR_SCROLLABLE_REGIONS[role.toLowerCase()] || false
						);
					}
					/**
					 * @param {HTMLElement} node
					 * @return {Boolean} Whether the element would have valid semantics if it were a
					 *			scrollable region.
					 */

					function validScrollableSemantics(node) {
						return validScrollableRole(node) || validScrollableTagName(node);
					}

					return validScrollableSemantics(node);
				},
				options: []
			},
			{
				id: 'color-contrast',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var _axe$commons8 = axe.commons,
						dom = _axe$commons8.dom,
						color = _axe$commons8.color,
						text = _axe$commons8.text;

					if (!dom.isVisible(node, false)) {
						return true;
					}

					var noScroll = !!(options || {}).noScroll;
					var bgNodes = [];
					var bgColor = color.getBackgroundColor(node, bgNodes, noScroll);
					var fgColor = color.getForegroundColor(node, noScroll, bgColor);
					var nodeStyle = window.getComputedStyle(node);
					var fontSize = parseFloat(nodeStyle.getPropertyValue('font-size'));
					var fontWeight = nodeStyle.getPropertyValue('font-weight');
					var bold =
						['bold', 'bolder', '600', '700', '800', '900'].indexOf(
							fontWeight
						) !== -1;
					var cr = color.hasValidContrastRatio(
						bgColor,
						fgColor,
						fontSize,
						bold
					); // truncate ratio to three digits while rounding down
					// 4.499 = 4.49, 4.019 = 4.01

					var truncatedResult = Math.floor(cr.contrastRatio * 100) / 100; // if fgColor or bgColor are missing, get more information.

					var missing;

					if (bgColor === null) {
						missing = color.incompleteData.get('bgColor');
					}

					var equalRatio = truncatedResult === 1;
					var shortTextContent =
						text.visibleVirtual(virtualNode, false, true).length === 1;

					if (equalRatio) {
						missing = color.incompleteData.set('bgColor', 'equalRatio');
					} else if (shortTextContent) {
						// Check that the text content is a single character long
						missing = 'shortTextContent';
					} // need both independently in case both are missing

					var data = {
						fgColor: fgColor ? fgColor.toHexString() : undefined,
						bgColor: bgColor ? bgColor.toHexString() : undefined,
						contrastRatio: cr ? truncatedResult : undefined,
						fontSize: ''
							.concat(((fontSize * 72) / 96).toFixed(1), 'pt (')
							.concat(fontSize, 'px)'),
						fontWeight: bold ? 'bold' : 'normal',
						messageKey: missing,
						expectedContrastRatio: cr.expectedContrastRatio + ':1'
					};
					this.data(data); // We don't know, so we'll put it into Can't Tell

					if (
						fgColor === null ||
						bgColor === null ||
						equalRatio ||
						(shortTextContent && !cr.isValid)
					) {
						missing = null;
						color.incompleteData.clear();
						this.relatedNodes(bgNodes);
						return undefined;
					}

					if (!cr.isValid) {
						this.relatedNodes(bgNodes);
					}

					return cr.isValid;
				}
			},
			{
				id: 'link-in-text-block',
				evaluate: function evaluate(node, options, virtualNode, context) {
					/* global axe*/
					var _axe$commons9 = axe.commons,
						color = _axe$commons9.color,
						dom = _axe$commons9.dom;

					function getContrast(color1, color2) {
						var c1lum = color1.getRelativeLuminance();
						var c2lum = color2.getRelativeLuminance();
						return (
							(Math.max(c1lum, c2lum) + 0.05) / (Math.min(c1lum, c2lum) + 0.05)
						);
					}

					var blockLike = [
						'block',
						'list-item',
						'table',
						'flex',
						'grid',
						'inline-block'
					];

					function isBlock(elm) {
						var display = window
							.getComputedStyle(elm)
							.getPropertyValue('display');
						return (
							blockLike.indexOf(display) !== -1 ||
							display.substr(0, 6) === 'table-'
						);
					}

					if (isBlock(node)) {
						return false;
					}

					var parentBlock = dom.getComposedParent(node);

					while (parentBlock.nodeType === 1 && !isBlock(parentBlock)) {
						parentBlock = dom.getComposedParent(parentBlock);
					}

					this.relatedNodes([parentBlock]); // TODO: Check the :visited state of the link

					if (color.elementIsDistinct(node, parentBlock)) {
						return true;
					} else {
						// Check if contrast of foreground is sufficient
						var nodeColor, parentColor;
						nodeColor = color.getForegroundColor(node);
						parentColor = color.getForegroundColor(parentBlock);

						if (!nodeColor || !parentColor) {
							return undefined;
						}

						var contrast = getContrast(nodeColor, parentColor);

						if (contrast === 1) {
							return true;
						} else if (contrast >= 3.0) {
							axe.commons.color.incompleteData.set('fgColor', 'bgContrast');
							this.data({
								messageKey: axe.commons.color.incompleteData.get('fgColor')
							});
							axe.commons.color.incompleteData.clear(); // User needs to check whether there is a hover and a focus style

							return undefined;
						} // Check if contrast of background is sufficient

						nodeColor = color.getBackgroundColor(node);
						parentColor = color.getBackgroundColor(parentBlock);

						if (
							!nodeColor ||
							!parentColor ||
							getContrast(nodeColor, parentColor) >= 3.0
						) {
							var reason;

							if (!nodeColor || !parentColor) {
								reason = axe.commons.color.incompleteData.get('bgColor');
							} else {
								reason = 'bgContrast';
							}

							axe.commons.color.incompleteData.set('fgColor', reason);
							this.data({
								messageKey: axe.commons.color.incompleteData.get('fgColor')
							});
							axe.commons.color.incompleteData.clear();
							return undefined;
						}
					} // TODO: We should check the focus / hover style too

					return false;
				}
			},
			{
				id: 'autocomplete-appropriate',
				evaluate: function evaluate(node, options, virtualNode, context) {
					// Select and textarea is always allowed
					if (virtualNode.props.nodeName !== 'input') {
						return true;
					}

					var number = ['text', 'search', 'number'];
					var url = ['text', 'search', 'url'];
					var allowedTypesMap = {
						bday: ['text', 'search', 'date'],
						email: ['text', 'search', 'email'],
						'cc-exp': ['text', 'search', 'month'],
						'street-address': ['text'],
						// Issue: https://github.com/dequelabs/axe-core/issues/1161
						tel: ['text', 'search', 'tel'],
						'cc-exp-month': number,
						'cc-exp-year': number,
						'transaction-amount': number,
						'bday-day': number,
						'bday-month': number,
						'bday-year': number,
						'new-password': ['text', 'search', 'password'],
						'current-password': ['text', 'search', 'password'],
						url: url,
						photo: url,
						impp: url
					};

					if (_typeof(options) === 'object') {
						// Merge in options
						Object.keys(options).forEach(function(key) {
							if (!allowedTypesMap[key]) {
								allowedTypesMap[key] = [];
							}

							allowedTypesMap[key] = allowedTypesMap[key].concat(options[key]);
						});
					}

					var autocomplete = virtualNode.attr('autocomplete');
					var autocompleteTerms = autocomplete
						.split(/\s+/g)
						.map(function(term) {
							return term.toLowerCase();
						});
					var purposeTerm = autocompleteTerms[autocompleteTerms.length - 1];

					if (axe.commons.text.autocomplete.stateTerms.includes(purposeTerm)) {
						return true;
					}

					var allowedTypes = allowedTypesMap[purposeTerm];
					/**
					 * Note:
					 * Inconsistent response for `node.type` across browsers, hence resolving and sanitizing using getAttribute
					 * Example:
					 * Firefox returns `node.type` as `text` for `type='month'`
					 *
					 * Reference HTML Spec - https://html.spec.whatwg.org/multipage/input.html#the-input-element to filter allowed values for `type`
					 * and sanitize (https://html.spec.whatwg.org/multipage/input.html#value-sanitization-algorithm)
					 */

					var type = virtualNode.hasAttr('type')
						? axe.commons.text.sanitize(virtualNode.attr('type')).toLowerCase()
						: 'text';
					type = axe.utils.validInputTypes().includes(type) ? type : 'text';

					if (typeof allowedTypes === 'undefined') {
						return type === 'text';
					}

					return allowedTypes.includes(type);
				}
			},
			{
				id: 'autocomplete-valid',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var autocomplete = virtualNode.attr('autocomplete') || '';
					return axe.commons.text.isValidAutocomplete(autocomplete, options);
				}
			},
			{
				id: 'fieldset',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var failureCode,
						self = this;

					function getUnrelatedElements(parent, name) {
						return axe.utils.toArray(
							parent.querySelectorAll(
								'select,textarea,button,input:not([name="' +
									name +
									'"]):not([type="hidden"])'
							)
						);
					}

					function checkFieldset(group, name) {
						var firstNode = group.firstElementChild;

						if (!firstNode || firstNode.nodeName.toUpperCase() !== 'LEGEND') {
							self.relatedNodes([group]);
							failureCode = 'no-legend';
							return false;
						}

						if (!axe.commons.text.accessibleText(firstNode)) {
							self.relatedNodes([firstNode]);
							failureCode = 'empty-legend';
							return false;
						}

						var otherElements = getUnrelatedElements(group, name);

						if (otherElements.length) {
							self.relatedNodes(otherElements);
							failureCode = 'mixed-inputs';
							return false;
						}

						return true;
					}

					function checkARIAGroup(group, name) {
						var hasLabelledByText = axe.commons.dom
							.idrefs(group, 'aria-labelledby')
							.some(function(element) {
								return element && axe.commons.text.accessibleText(element);
							});
						var ariaLabel = group.getAttribute('aria-label');

						if (
							!hasLabelledByText &&
							!(ariaLabel && axe.commons.text.sanitize(ariaLabel))
						) {
							self.relatedNodes(group);
							failureCode = 'no-group-label';
							return false;
						}

						var otherElements = getUnrelatedElements(group, name);

						if (otherElements.length) {
							self.relatedNodes(otherElements);
							failureCode = 'group-mixed-inputs';
							return false;
						}

						return true;
					}

					function spliceCurrentNode(nodes, current) {
						return axe.utils.toArray(nodes).filter(function(candidate) {
							return candidate !== current;
						});
					}

					function runCheck(virtualNode) {
						var name = axe.utils.escapeSelector(virtualNode.actualNode.name);
						var root = axe.commons.dom.getRootNode(virtualNode.actualNode);
						var matchingNodes = root.querySelectorAll(
							'input[type="' +
								axe.utils.escapeSelector(virtualNode.actualNode.type) +
								'"][name="' +
								name +
								'"]'
						);

						if (matchingNodes.length < 2) {
							return true;
						}

						var fieldset = axe.commons.dom.findUpVirtual(
							virtualNode,
							'fieldset'
						);
						var group = axe.commons.dom.findUpVirtual(
							virtualNode,
							'[role="group"]' +
								(virtualNode.actualNode.type === 'radio'
									? ',[role="radiogroup"]'
									: '')
						);

						if (!group && !fieldset) {
							failureCode = 'no-group';
							self.relatedNodes(
								spliceCurrentNode(matchingNodes, virtualNode.actualNode)
							);
							return false;
						} else if (fieldset) {
							return checkFieldset(fieldset, name);
						} else {
							return checkARIAGroup(group, name);
						}
					}

					var data = {
						name: node.getAttribute('name'),
						type: node.getAttribute('type')
					};
					var result = runCheck(virtualNode);

					if (!result) {
						data.messageKey = failureCode;
					}

					this.data(data);
					return result;
				},
				after: function after(results, options) {
					var seen = {};
					return results.filter(function(result) {
						// passes can pass through
						if (result.result) {
							return true;
						}

						var data = result.data;

						if (data) {
							seen[data.type] = seen[data.type] || {};

							if (!seen[data.type][data.name]) {
								seen[data.type][data.name] = [data];
								return true;
							}

							var hasBeenSeen = seen[data.type][data.name].some(function(
								candidate
							) {
								return candidate.failureCode === data.failureCode;
							});

							if (!hasBeenSeen) {
								seen[data.type][data.name].push(data);
							}

							return !hasBeenSeen;
						}

						return false;
					});
				},
				deprecated: true
			},
			{
				id: 'group-labelledby',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var _axe$commons10 = axe.commons,
						dom = _axe$commons10.dom,
						text = _axe$commons10.text;
					var type = axe.utils.escapeSelector(node.type);
					var name = axe.utils.escapeSelector(node.name);
					var doc = dom.getRootNode(node);
					var data = {
						name: node.name,
						type: node.type
					};
					var matchingNodes = Array.from(
						doc.querySelectorAll(
							'input[type="'.concat(type, '"][name="').concat(name, '"]')
						)
					); // There is only one node with this name & type, so there's no need for a group

					if (matchingNodes.length <= 1) {
						this.data(data);
						return true;
					}

					var sharedLabels = dom
						.idrefs(node, 'aria-labelledby')
						.filter(function(label) {
							return !!label;
						}); // Filter for "null" labels

					var uniqueLabels = sharedLabels.slice(); // Figure out which labels are unique, which are shared by all items, or neither

					matchingNodes.forEach(function(groupItem) {
						if (groupItem === node) {
							return;
						} // Find new labels associated with current groupItem

						var labels = dom
							.idrefs(groupItem, 'aria-labelledby')
							.filter(function(newLabel) {
								return newLabel;
							});
						sharedLabels = sharedLabels.filter(function(sharedLabel) {
							return labels.includes(sharedLabel);
						});
						uniqueLabels = uniqueLabels.filter(function(uniqueLabel) {
							return !labels.includes(uniqueLabel);
						});
					});
					var accessibleTextOptions = {
						// Prevent following further aria-labelledby refs:
						inLabelledByContext: true
					}; // filter items with no accessible name, do this last for performance reasons

					uniqueLabels = uniqueLabels.filter(function(labelNode) {
						return text.accessibleText(labelNode, accessibleTextOptions);
					});
					sharedLabels = sharedLabels.filter(function(labelNode) {
						return text.accessibleText(labelNode, accessibleTextOptions);
					});

					if (uniqueLabels.length > 0 && sharedLabels.length > 0) {
						this.data(data);
						return true;
					}

					if (uniqueLabels.length > 0 && sharedLabels.length === 0) {
						data.messageKey = 'no-shared-label';
					} else if (uniqueLabels.length === 0 && sharedLabels.length > 0) {
						data.messageKey = 'no-unique-label';
					}

					this.data(data);
					return false;
				},
				after: function after(results, options) {
					var seen = {}; // Filter out nodes that have the same type and name.
					// If you have two `<input type="radio" name="foo" />` elements
					// only the first one can pass / fail the rule.

					return results.filter(function(result) {
						var data = result.data;

						if (data) {
							seen[data.type] = seen[data.type] || {};

							if (!seen[data.type][data.name]) {
								seen[data.type][data.name] = true;
								return true;
							}
						}

						return false;
					});
				},
				deprecated: true
			},
			{
				id: 'accesskeys',
				evaluate: function evaluate(node, options, virtualNode, context) {
					if (axe.commons.dom.isVisible(node, false)) {
						this.data(node.getAttribute('accesskey'));
						this.relatedNodes([node]);
					}

					return true;
				},
				after: function after(results, options) {
					var seen = {};
					return results
						.filter(function(r) {
							if (!r.data) {
								return false;
							}

							var key = r.data.toUpperCase();

							if (!seen[key]) {
								seen[key] = r;
								r.relatedNodes = [];
								return true;
							}

							seen[key].relatedNodes.push(r.relatedNodes[0]);
							return false;
						})
						.map(function(r) {
							r.result = !!r.relatedNodes.length;
							return r;
						});
				}
			},
			{
				id: 'focusable-content',
				evaluate: function evaluate(node, options, virtualNode, context) {
					/**
					 * Note:
					 * Check if given node contains focusable elements (excluding thyself)
					 */
					var tabbableElements = virtualNode.tabbableElements;

					if (!tabbableElements) {
						return false;
					} // remove thyself from tabbable elements (if exists)

					var tabbableContentElements = tabbableElements.filter(function(el) {
						return el !== virtualNode;
					});
					return tabbableContentElements.length > 0;
				}
			},
			{
				id: 'focusable-disabled',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var elementsThatCanBeDisabled = [
						'BUTTON',
						'FIELDSET',
						'INPUT',
						'SELECT',
						'TEXTAREA'
					];
					var tabbableElements = virtualNode.tabbableElements;

					if (!tabbableElements || !tabbableElements.length) {
						return true;
					}

					var relatedNodes = tabbableElements.reduce(function(out, _ref3) {
						var el = _ref3.actualNode;
						var nodeName = el.nodeName.toUpperCase(); // populate nodes that can be disabled

						if (elementsThatCanBeDisabled.includes(nodeName)) {
							out.push(el);
						}

						return out;
					}, []);
					this.relatedNodes(relatedNodes);
					return relatedNodes.length === 0;
				}
			},
			{
				id: 'focusable-element',
				evaluate: function evaluate(node, options, virtualNode, context) {
					/**
					 * Note:
					 * Check
					 * - if element is focusable
					 * - if element is in focus order via `tabindex`
					 */
					var isFocusable = virtualNode.isFocusable;
					var tabIndex = parseInt(
						virtualNode.actualNode.getAttribute('tabindex'),
						10
					);
					tabIndex = !isNaN(tabIndex) ? tabIndex : null;
					return tabIndex ? isFocusable && tabIndex >= 0 : isFocusable;
				}
			},
			{
				id: 'focusable-no-name',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var tabIndex = node.getAttribute('tabindex'),
						inFocusOrder = axe.commons.dom.isFocusable(node) && tabIndex > -1;

					if (!inFocusOrder) {
						return false;
					}

					return !axe.commons.text.accessibleTextVirtual(virtualNode);
				}
			},
			{
				id: 'focusable-not-tabbable',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var elementsThatCanBeDisabled = [
						'BUTTON',
						'FIELDSET',
						'INPUT',
						'SELECT',
						'TEXTAREA'
					];
					var tabbableElements = virtualNode.tabbableElements;

					if (!tabbableElements || !tabbableElements.length) {
						return true;
					}

					var relatedNodes = tabbableElements.reduce(function(out, _ref4) {
						var el = _ref4.actualNode;
						var nodeName = el.nodeName.toUpperCase(); // populate nodes that cannot be disabled

						if (!elementsThatCanBeDisabled.includes(nodeName)) {
							out.push(el);
						}

						return out;
					}, []);
					this.relatedNodes(relatedNodes);
					return relatedNodes.length === 0;
				}
			},
			{
				id: 'landmark-is-top-level',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var landmarks = axe.commons.aria.getRolesByType('landmark');
					var parent = axe.commons.dom.getComposedParent(node);
					this.data({
						role:
							node.getAttribute('role') || axe.commons.aria.implicitRole(node)
					});

					while (parent) {
						var role = parent.getAttribute('role');

						if (!role && parent.nodeName.toUpperCase() !== 'FORM') {
							role = axe.commons.aria.implicitRole(parent);
						}

						if (role && landmarks.includes(role)) {
							return false;
						}

						parent = axe.commons.dom.getComposedParent(parent);
					}

					return true;
				}
			},
			{
				id: 'page-has-heading-one',
				evaluate: function evaluate(node, options, virtualNode, context) {
					if (
						!options ||
						!options.selector ||
						typeof options.selector !== 'string'
					) {
						throw new TypeError(
							'visible-in-page requires options.selector to be a string'
						);
					}

					var matchingElms = axe.utils.querySelectorAll(
						virtualNode,
						options.selector
					);
					this.relatedNodes(
						matchingElms.map(function(vNode) {
							return vNode.actualNode;
						})
					);
					return matchingElms.length > 0;
				},
				after: function after(results, options) {
					var elmUsedAnywhere = results.some(function(frameResult) {
						return frameResult.result === true;
					}); // If the element exists in any frame, set them all to true

					if (elmUsedAnywhere) {
						results.forEach(function(result) {
							result.result = true;
						});
					}

					return results;
				},
				options: {
					selector: 'h1:not([role]), [role="heading"][aria-level="1"]'
				}
			},
			{
				id: 'page-has-main',
				evaluate: function evaluate(node, options, virtualNode, context) {
					if (
						!options ||
						!options.selector ||
						typeof options.selector !== 'string'
					) {
						throw new TypeError(
							'visible-in-page requires options.selector to be a string'
						);
					}

					var matchingElms = axe.utils.querySelectorAll(
						virtualNode,
						options.selector
					);
					this.relatedNodes(
						matchingElms.map(function(vNode) {
							return vNode.actualNode;
						})
					);
					return matchingElms.length > 0;
				},
				after: function after(results, options) {
					var elmUsedAnywhere = results.some(function(frameResult) {
						return frameResult.result === true;
					}); // If the element exists in any frame, set them all to true

					if (elmUsedAnywhere) {
						results.forEach(function(result) {
							result.result = true;
						});
					}

					return results;
				},
				options: {
					selector: "main:not([role]), [role='main']"
				}
			},
			{
				id: 'page-no-duplicate-banner',
				evaluate: function evaluate(node, options, virtualNode, context) {
					if (
						!options ||
						!options.selector ||
						typeof options.selector !== 'string'
					) {
						throw new TypeError(
							'visible-in-page requires options.selector to be a string'
						);
					}

					var elms = axe.utils.querySelectorAll(virtualNode, options.selector); // Filter elements that, within certain contexts, don't map their role.
					// e.g. a <footer> inside a <main> is not a banner, but in the <body> context it is

					if (typeof options.nativeScopeFilter === 'string') {
						elms = elms.filter(function(elm) {
							return (
								elm.actualNode.hasAttribute('role') ||
								!axe.commons.dom.findUpVirtual(elm, options.nativeScopeFilter)
							);
						});
					}

					this.relatedNodes(
						elms.map(function(elm) {
							return elm.actualNode;
						})
					);
					return elms.length <= 1;
				},
				options: {
					selector: 'header:not([role]), [role=banner]',
					nativeScopeFilter: 'article, aside, main, nav, section'
				}
			},
			{
				id: 'page-no-duplicate-contentinfo',
				evaluate: function evaluate(node, options, virtualNode, context) {
					if (
						!options ||
						!options.selector ||
						typeof options.selector !== 'string'
					) {
						throw new TypeError(
							'visible-in-page requires options.selector to be a string'
						);
					}

					var elms = axe.utils.querySelectorAll(virtualNode, options.selector); // Filter elements that, within certain contexts, don't map their role.
					// e.g. a <footer> inside a <main> is not a banner, but in the <body> context it is

					if (typeof options.nativeScopeFilter === 'string') {
						elms = elms.filter(function(elm) {
							return (
								elm.actualNode.hasAttribute('role') ||
								!axe.commons.dom.findUpVirtual(elm, options.nativeScopeFilter)
							);
						});
					}

					this.relatedNodes(
						elms.map(function(elm) {
							return elm.actualNode;
						})
					);
					return elms.length <= 1;
				},
				options: {
					selector: 'footer:not([role]), [role=contentinfo]',
					nativeScopeFilter: 'article, aside, main, nav, section'
				}
			},
			{
				id: 'page-no-duplicate-main',
				evaluate: function evaluate(node, options, virtualNode, context) {
					if (
						!options ||
						!options.selector ||
						typeof options.selector !== 'string'
					) {
						throw new TypeError(
							'visible-in-page requires options.selector to be a string'
						);
					}

					var elms = axe.utils.querySelectorAll(virtualNode, options.selector); // Filter elements that, within certain contexts, don't map their role.
					// e.g. a <footer> inside a <main> is not a banner, but in the <body> context it is

					if (typeof options.nativeScopeFilter === 'string') {
						elms = elms.filter(function(elm) {
							return (
								elm.actualNode.hasAttribute('role') ||
								!axe.commons.dom.findUpVirtual(elm, options.nativeScopeFilter)
							);
						});
					}

					this.relatedNodes(
						elms.map(function(elm) {
							return elm.actualNode;
						})
					);
					return elms.length <= 1;
				},
				options: {
					selector: "main:not([role]), [role='main']"
				}
			},
			{
				id: 'tabindex',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var tabIndex = parseInt(node.getAttribute('tabindex'), 10); // an invalid tabindex will either return 0 or -1 (based on the element) so
					// will never be above 0
					// @see https://www.w3.org/TR/html51/editing.html#the-tabindex-attribute

					return isNaN(tabIndex) ? true : tabIndex <= 0;
				}
			},
			{
				id: 'alt-space-value',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var alt = virtualNode.attr('alt');
					var isOnlySpace = /^\s+$/;
					return typeof alt === 'string' && isOnlySpace.test(alt);
				}
			},
			{
				id: 'duplicate-img-label',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var _axe$commons11 = axe.commons,
						aria = _axe$commons11.aria,
						text = _axe$commons11.text,
						dom = _axe$commons11.dom;

					if (['none', 'presentation'].includes(aria.getRole(node))) {
						return false;
					}

					var parent = dom.findUpVirtual(
						virtualNode,
						'button, [role="button"], a[href], p, li, td, th'
					);

					if (!parent) {
						return false;
					}

					var parentVNode = axe.utils.getNodeFromTree(parent);
					var visibleText = text
						.visibleVirtual(parentVNode, true)
						.toLowerCase();

					if (visibleText === '') {
						return false;
					}

					return (
						visibleText ===
						text.accessibleTextVirtual(virtualNode).toLowerCase()
					);
				}
			},
			{
				id: 'explicit-label',
				evaluate: function evaluate(node, options, virtualNode, context) {
					if (node.getAttribute('id')) {
						var root = axe.commons.dom.getRootNode(node);
						var id = axe.utils.escapeSelector(node.getAttribute('id'));
						var label = root.querySelector('label[for="'.concat(id, '"]'));

						if (label) {
							// defer to hidden-explicit-label check for better messaging
							if (!axe.commons.dom.isVisible(label)) {
								return true;
							} else {
								return !!axe.commons.text.accessibleText(label);
							}
						}
					}

					return false;
				}
			},
			{
				id: 'help-same-as-label',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var labelText = axe.commons.text.labelVirtual(virtualNode),
						check = node.getAttribute('title');

					if (!labelText) {
						return false;
					}

					if (!check) {
						check = '';

						if (node.getAttribute('aria-describedby')) {
							var ref = axe.commons.dom.idrefs(node, 'aria-describedby');
							check = ref
								.map(function(thing) {
									return thing ? axe.commons.text.accessibleText(thing) : '';
								})
								.join('');
						}
					}

					return (
						axe.commons.text.sanitize(check) ===
						axe.commons.text.sanitize(labelText)
					);
				},
				enabled: false
			},
			{
				id: 'hidden-explicit-label',
				evaluate: function evaluate(node, options, virtualNode, context) {
					if (node.getAttribute('id')) {
						var root = axe.commons.dom.getRootNode(node);
						var id = axe.utils.escapeSelector(node.getAttribute('id'));
						var label = root.querySelector('label[for="'.concat(id, '"]'));

						if (label && !axe.commons.dom.isVisible(label, true)) {
							var name = axe.commons.text
								.accessibleTextVirtual(virtualNode)
								.trim();
							var isNameEmpty = name === '';
							return isNameEmpty;
						}
					}

					return false;
				}
			},
			{
				id: 'implicit-label',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var _axe$commons12 = axe.commons,
						dom = _axe$commons12.dom,
						text = _axe$commons12.text;
					var label = dom.findUpVirtual(virtualNode, 'label');

					if (label) {
						return !!text.accessibleText(label, {
							inControlContext: true
						});
					}

					return false;
				}
			},
			{
				id: 'label-content-name-mismatch',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var text = axe.commons.text;

					var _ref5 = options || {},
						pixelThreshold = _ref5.pixelThreshold,
						occuranceThreshold = _ref5.occuranceThreshold;

					var accText = text.accessibleText(node).toLowerCase();

					if (text.isHumanInterpretable(accText) < 1) {
						return undefined;
					}

					var textVNodes = text.visibleTextNodes(virtualNode);
					var nonLigatureText = textVNodes
						.filter(function(textVNode) {
							return !text.isIconLigature(
								textVNode,
								pixelThreshold,
								occuranceThreshold
							);
						})
						.map(function(textVNode) {
							return textVNode.actualNode.nodeValue;
						})
						.join('');
					var visibleText = text.sanitize(nonLigatureText).toLowerCase();

					if (!visibleText) {
						return true;
					}

					if (text.isHumanInterpretable(visibleText) < 1) {
						if (isStringContained(visibleText, accText)) {
							return true;
						}

						return undefined;
					}

					return isStringContained(visibleText, accText);
					/**
					 * Check if a given text exists in another
					 *
					 * @param {String} compare given text to check
					 * @param {String} compareWith text against which to be compared
					 * @returns {Boolean}
					 */

					function isStringContained(compare, compareWith) {
						var curatedCompareWith = curateString(compareWith);
						var curatedCompare = curateString(compare);

						if (!curatedCompareWith || !curatedCompare) {
							return false;
						}

						return curatedCompareWith.includes(curatedCompare);
					}
					/**
					 * Curate given text, by removing emoji's, punctuations, unicode and trim whitespace.
					 *
					 * @param {String} str given text to curate
					 * @returns {String}
					 */

					function curateString(str) {
						var noUnicodeStr = text.removeUnicode(str, {
							emoji: true,
							nonBmp: true,
							punctuations: true
						});
						return text.sanitize(noUnicodeStr);
					}
				},
				options: {
					pixelThreshold: 0.1,
					occuranceThreshold: 3
				}
			},
			{
				id: 'multiple-label',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var id = axe.utils.escapeSelector(node.getAttribute('id'));
					var parent = node.parentNode;
					var root = axe.commons.dom.getRootNode(node);
					root = root.documentElement || root;
					var labels = Array.from(
						root.querySelectorAll('label[for="'.concat(id, '"]'))
					);

					if (labels.length) {
						// filter out CSS hidden labels because they're fine
						labels = labels.filter(function(label) {
							return axe.commons.dom.isVisible(label);
						});
					}

					while (parent) {
						if (
							parent.nodeName.toUpperCase() === 'LABEL' &&
							labels.indexOf(parent) === -1
						) {
							labels.push(parent);
						}

						parent = parent.parentNode;
					}

					this.relatedNodes(labels); // more than 1 CSS visible label

					if (labels.length > 1) {
						var ATVisibleLabels = labels.filter(function(label) {
							return axe.commons.dom.isVisible(label, true);
						}); // more than 1 AT visible label will fail IOS/Safari/VO even with aria-labelledby

						if (ATVisibleLabels.length > 1) {
							return undefined;
						} // make sure the ONE AT visible label is in the list of idRefs of aria-labelledby

						var labelledby = axe.commons.dom.idrefs(node, 'aria-labelledby');
						return !labelledby.includes(ATVisibleLabels[0]) ? undefined : false;
					} // only 1 CSS visible label

					return false;
				}
			},
			{
				id: 'title-only',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var labelText = axe.commons.text.labelVirtual(virtualNode);
					return (
						!labelText &&
						!!(
							node.getAttribute('title') ||
							node.getAttribute('aria-describedby')
						)
					);
				}
			},
			{
				id: 'landmark-is-unique',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var role = axe.commons.aria.getRole(node);
					var accessibleText = axe.commons.text.accessibleTextVirtual(
						virtualNode
					);
					accessibleText = accessibleText ? accessibleText.toLowerCase() : null;
					this.data({
						role: role,
						accessibleText: accessibleText
					});
					this.relatedNodes([node]);
					return true;
				},
				after: function after(results, options) {
					var uniqueLandmarks = []; // filter out landmark elements that share the same role and accessible text
					// so every non-unique landmark isn't reported as a failure (just the first)

					return results.filter(function(currentResult) {
						var findMatch = function findMatch(someResult) {
							return (
								currentResult.data.role === someResult.data.role &&
								currentResult.data.accessibleText ===
									someResult.data.accessibleText
							);
						};

						var matchedResult = uniqueLandmarks.find(findMatch);

						if (matchedResult) {
							matchedResult.result = false;
							matchedResult.relatedNodes.push(currentResult.relatedNodes[0]);
							return false;
						}

						uniqueLandmarks.push(currentResult);
						currentResult.relatedNodes = [];
						return true;
					});
				}
			},
			{
				id: 'has-lang',
				evaluate: function evaluate(node, options, virtualNode, context) {
					return !!(
						node.getAttribute('lang') ||
						node.getAttribute('xml:lang') ||
						''
					).trim();
				}
			},
			{
				id: 'valid-lang',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var langs, invalid;
					langs = (options ? options : axe.utils.validLangs()).map(
						axe.utils.getBaseLang
					);
					invalid = ['lang', 'xml:lang'].reduce(function(invalid, langAttr) {
						var langVal = node.getAttribute(langAttr);

						if (typeof langVal !== 'string') {
							return invalid;
						}

						var baselangVal = axe.utils.getBaseLang(langVal); // Edge sets lang to an empty string when xml:lang is set
						// so we need to ignore empty strings here

						if (baselangVal !== '' && langs.indexOf(baselangVal) === -1) {
							invalid.push(langAttr + '="' + node.getAttribute(langAttr) + '"');
						}

						return invalid;
					}, []);

					if (invalid.length) {
						this.data(invalid);
						return true;
					}

					return false;
				}
			},
			{
				id: 'xml-lang-mismatch',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var getBaseLang = axe.utils.getBaseLang;
					var primaryLangValue = getBaseLang(node.getAttribute('lang'));
					var primaryXmlLangValue = getBaseLang(node.getAttribute('xml:lang'));
					return primaryLangValue === primaryXmlLangValue;
				}
			},
			{
				id: 'dlitem',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var parent = axe.commons.dom.getComposedParent(node);
					var parentTagName = parent.nodeName.toUpperCase();
					var parentRole = axe.commons.aria.getRole(parent, {
						noImplicit: true
					});

					if (
						parentTagName === 'DIV' &&
						['presentation', 'none', null].includes(parentRole)
					) {
						parent = axe.commons.dom.getComposedParent(parent);
						parentTagName = parent.nodeName.toUpperCase();
						parentRole = axe.commons.aria.getRole(parent, {
							noImplicit: true
						});
					} // Unlike with UL|OL+LI, DT|DD must be in a DL

					if (parentTagName !== 'DL') {
						return false;
					}

					if (!parentRole || parentRole === 'list') {
						return true;
					}

					return false;
				}
			},
			{
				id: 'listitem',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var parent = axe.commons.dom.getComposedParent(node);

					if (!parent) {
						// Can only happen with detached DOM nodes and roots:
						return undefined;
					}

					var parentTagName = parent.nodeName.toUpperCase();
					var parentRole = (parent.getAttribute('role') || '').toLowerCase();

					if (parentRole === 'list') {
						return true;
					}

					if (parentRole && axe.commons.aria.isValidRole(parentRole)) {
						this.data({
							messageKey: 'roleNotValid'
						});
						return false;
					}

					return ['UL', 'OL'].includes(parentTagName);
				}
			},
			{
				id: 'only-dlitems',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var _axe$commons13 = axe.commons,
						dom = _axe$commons13.dom,
						aria = _axe$commons13.aria;
					var ALLOWED_ROLES = ['definition', 'term', 'list'];
					var base = {
						badNodes: [],
						hasNonEmptyTextNode: false
					};
					var content = virtualNode.children.reduce(function(content, child) {
						var actualNode = child.actualNode;

						if (
							actualNode.nodeName.toUpperCase() === 'DIV' &&
							aria.getRole(actualNode) === null
						) {
							return content.concat(child.children);
						}

						return content.concat(child);
					}, []);
					var result = content.reduce(function(out, childNode) {
						var actualNode = childNode.actualNode;
						var tagName = actualNode.nodeName.toUpperCase();

						if (
							actualNode.nodeType === 1 &&
							dom.isVisible(actualNode, true, false)
						) {
							var explicitRole = aria.getRole(actualNode, {
								noImplicit: true
							});

							if ((tagName !== 'DT' && tagName !== 'DD') || explicitRole) {
								if (!ALLOWED_ROLES.includes(explicitRole)) {
									// handle comment - https://github.com/dequelabs/axe-core/pull/518/files#r139284668
									out.badNodes.push(actualNode);
								}
							}
						} else if (
							actualNode.nodeType === 3 &&
							actualNode.nodeValue.trim() !== ''
						) {
							out.hasNonEmptyTextNode = true;
						}

						return out;
					}, base);

					if (result.badNodes.length) {
						this.relatedNodes(result.badNodes);
					}

					return !!result.badNodes.length || result.hasNonEmptyTextNode;
				}
			},
			{
				id: 'only-listitems',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var dom = axe.commons.dom;

					var getIsListItemRole = function getIsListItemRole(role, tagName) {
						return role === 'listitem' || (tagName === 'LI' && !role);
					};

					var getHasListItem = function getHasListItem(
						hasListItem,
						tagName,
						isListItemRole
					) {
						return (
							hasListItem ||
							(tagName === 'LI' && isListItemRole) ||
							isListItemRole
						);
					};

					var base = {
						badNodes: [],
						isEmpty: true,
						hasNonEmptyTextNode: false,
						hasListItem: false,
						liItemsWithRole: 0
					};
					var out = virtualNode.children.reduce(function(out, _ref6) {
						var actualNode = _ref6.actualNode;
						var tagName = actualNode.nodeName.toUpperCase();

						if (
							actualNode.nodeType === 1 &&
							dom.isVisible(actualNode, true, false)
						) {
							var role = (actualNode.getAttribute('role') || '').toLowerCase();
							var isListItemRole = getIsListItemRole(role, tagName);
							out.hasListItem = getHasListItem(
								out.hasListItem,
								tagName,
								isListItemRole
							);

							if (isListItemRole) {
								out.isEmpty = false;
							}

							if (tagName === 'LI' && !isListItemRole) {
								out.liItemsWithRole++;
							}

							if (tagName !== 'LI' && !isListItemRole) {
								out.badNodes.push(actualNode);
							}
						}

						if (actualNode.nodeType === 3) {
							if (actualNode.nodeValue.trim() !== '') {
								out.hasNonEmptyTextNode = true;
							}
						}

						return out;
					}, base);
					var virtualNodeChildrenOfTypeLi = virtualNode.children.filter(
						function(_ref7) {
							var actualNode = _ref7.actualNode;
							return actualNode.nodeName.toUpperCase() === 'LI';
						}
					);
					var allLiItemsHaveRole =
						out.liItemsWithRole > 0 &&
						virtualNodeChildrenOfTypeLi.length === out.liItemsWithRole;

					if (out.badNodes.length) {
						this.relatedNodes(out.badNodes);
					}

					var isInvalidListItem = !(
						out.hasListItem ||
						(out.isEmpty && !allLiItemsHaveRole)
					);
					return (
						isInvalidListItem ||
						!!out.badNodes.length ||
						out.hasNonEmptyTextNode
					);
				}
			},
			{
				id: 'structured-dlitems',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var children = virtualNode.children;

					if (!children || !children.length) {
						return false;
					}

					var hasDt = false,
						hasDd = false,
						nodeName;

					for (var i = 0; i < children.length; i++) {
						nodeName = children[i].actualNode.nodeName.toUpperCase();

						if (nodeName === 'DT') {
							hasDt = true;
						}

						if (hasDt && nodeName === 'DD') {
							return false;
						}

						if (nodeName === 'DD') {
							hasDd = true;
						}
					}

					return hasDt || hasDd;
				}
			},
			{
				id: 'caption',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var tracks = axe.utils.querySelectorAll(virtualNode, 'track');
					var hasCaptions = tracks.some(function(_ref8) {
						var actualNode = _ref8.actualNode;
						return (
							(actualNode.getAttribute('kind') || '').toLowerCase() ===
							'captions'
						);
					}); // Undefined if there are no tracks - media may use another caption method

					return hasCaptions ? false : undefined;
				}
			},
			{
				id: 'description',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var tracks = axe.utils.querySelectorAll(virtualNode, 'track');
					var hasDescriptions = tracks.some(function(_ref9) {
						var actualNode = _ref9.actualNode;
						return (
							(actualNode.getAttribute('kind') || '').toLowerCase() ===
							'descriptions'
						);
					}); // Undefined if there are no tracks - media may have another description method

					return hasDescriptions ? false : undefined;
				}
			},
			{
				id: 'frame-tested',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var resolve = this.async();

					var _Object$assign = Object.assign(
							{
								isViolation: false,
								timeout: 500
							},
							options
						),
						isViolation = _Object$assign.isViolation,
						timeout = _Object$assign.timeout; // give the frame .5s to respond to 'axe.ping', else log failed response

					var timer = setTimeout(function() {
						// This double timeout is important for allowing iframes to respond
						// DO NOT REMOVE
						timer = setTimeout(function() {
							timer = null;
							resolve(isViolation ? false : undefined);
						}, 0);
					}, timeout);
					axe.utils.respondable(
						node.contentWindow,
						'axe.ping',
						null,
						undefined,
						function() {
							if (timer !== null) {
								clearTimeout(timer);
								resolve(true);
							}
						}
					);
				},
				options: {
					isViolation: false
				}
			},
			{
				id: 'no-autoplay-audio',
				evaluate: function evaluate(node, options, virtualNode, context) {
					/**
					 * if duration cannot be read, this means `preloadMedia` has failed
					 * todo:jey
					 * -> discuss if this needs to be handled?
					 */
					if (!node.duration || Number.isNaN(node.duration)) {
						console.warn('axe.utils.preloadMedia did not load metadata');
						return undefined;
					}
					/**
					 * Compute playable duration and verify if it within allowed duration
					 */

					var playableDuration = getPlayableDuration(node);

					if (
						playableDuration <= options.allowedDuration &&
						!node.hasAttribute('loop')
					) {
						return true;
					}
					/**
					 * if media element does not provide controls mechanism
					 * -> fail
					 */

					if (!node.hasAttribute('controls')) {
						return false;
					}

					return true;
					/**
					 * Compute playback duration
					 * @param {HTMLMediaElement} elm media element
					 */

					function getPlayableDuration(_ref10) {
						var currentSrc = _ref10.currentSrc,
							duration = _ref10.duration;
						var playbackRange = getPlaybackRange(currentSrc);

						if (!playbackRange) {
							return Math.abs(node.duration - node.currentTime);
						}

						if (playbackRange.length === 1) {
							return Math.abs(duration - playbackRange[0]);
						}

						return Math.abs(playbackRange[1] - playbackRange[0]);
					}
					/**
					 * Get playback range from a media elements source, if specified
					 * See - https://developer.mozilla.org/de/docs/Web/HTML/Using_HTML5_audio_and_video#Specifying_playback_range
					 *
					 * Eg:
					 * src='....someMedia.mp3#t=8'
					 * 	-> should yeild [8]
					 * src='....someMedia.mp3#t=10,12'
					 *  -> should yeild [10,12]
					 * @param {String} src media src
					 * @returns {Array|undefined}
					 */

					function getPlaybackRange(src) {
						var match = src.match(/#t=(.*)/);

						if (!match) {
							return;
						}

						var _match = _slicedToArray(match, 2),
							value = _match[1];

						var ranges = value.split(',');
						return ranges.map(function(range) {
							// range is denoted in HH:MM:SS -> convert to seconds
							if (/:/.test(range)) {
								return convertHourMinSecToSeconds(range);
							}

							return parseFloat(range);
						});
					}
					/**
					 * Add HH, MM, SS to seconds
					 * @param {String} hhMmSs time expressed in HH:MM:SS
					 */

					function convertHourMinSecToSeconds(hhMmSs) {
						var parts = hhMmSs.split(':');
						var secs = 0;
						var mins = 1;

						while (parts.length > 0) {
							secs += mins * parseInt(parts.pop(), 10);
							mins *= 60;
						}

						return parseFloat(secs);
					}
				},
				options: {
					allowedDuration: 3
				}
			},
			{
				id: 'css-orientation-lock',
				evaluate: function evaluate(node, options, virtualNode, context) {
					/* global context */
					var _ref11 = context || {},
						_ref11$cssom = _ref11.cssom,
						cssom = _ref11$cssom === void 0 ? undefined : _ref11$cssom;

					var _ref12 = options || {},
						_ref12$degreeThreshol = _ref12.degreeThreshold,
						degreeThreshold =
							_ref12$degreeThreshol === void 0 ? 0 : _ref12$degreeThreshol;

					if (!cssom || !cssom.length) {
						return undefined;
					}

					var isLocked = false;
					var relatedElements = [];
					var rulesGroupByDocumentFragment = groupCssomByDocument(cssom);

					var _loop = function _loop() {
						var key = _Object$keys[_i2];
						var _rulesGroupByDocument = rulesGroupByDocumentFragment[key],
							root = _rulesGroupByDocument.root,
							rules = _rulesGroupByDocument.rules;
						var orientationRules = rules.filter(isMediaRuleWithOrientation);

						if (!orientationRules.length) {
							return 'continue';
						}

						orientationRules.forEach(function(_ref18) {
							var cssRules = _ref18.cssRules;
							Array.from(cssRules).forEach(function(cssRule) {
								var locked = getIsOrientationLocked(cssRule); // if locked and not root HTML, preserve as relatedNodes

								if (locked && cssRule.selectorText.toUpperCase() !== 'HTML') {
									var elms =
										Array.from(root.querySelectorAll(cssRule.selectorText)) ||
										[];
									relatedElements = relatedElements.concat(elms);
								}

								isLocked = isLocked || locked;
							});
						});
					};

					for (
						var _i2 = 0,
							_Object$keys = Object.keys(rulesGroupByDocumentFragment);
						_i2 < _Object$keys.length;
						_i2++
					) {
						var _ret = _loop();

						if (_ret === 'continue') continue;
					}

					if (!isLocked) {
						return true;
					}

					if (relatedElements.length) {
						this.relatedNodes(relatedElements);
					}

					return false;
					/**
					 * Group given cssom by document/ document fragment
					 * @param {Array<Object>} allCssom cssom
					 * @return {Object}
					 */

					function groupCssomByDocument(cssObjectModel) {
						return cssObjectModel.reduce(function(out, _ref13) {
							var sheet = _ref13.sheet,
								root = _ref13.root,
								shadowId = _ref13.shadowId;
							var key = shadowId ? shadowId : 'topDocument';

							if (!out[key]) {
								out[key] = {
									root: root,
									rules: []
								};
							}

							if (!sheet || !sheet.cssRules) {
								return out;
							}

							var rules = Array.from(sheet.cssRules);
							out[key].rules = out[key].rules.concat(rules);
							return out;
						}, {});
					}
					/**
					 * Filter CSS Rules that target Orientation CSS Media Features
					 * @param {Array<Object>} cssRules
					 * @returns {Array<Object>}
					 */

					function isMediaRuleWithOrientation(_ref14) {
						var type = _ref14.type,
							cssText = _ref14.cssText;

						/**
						 * Filter:
						 * CSSRule.MEDIA_Rule
						 * -> https://developer.mozilla.org/en-US/docs/Web/API/CSSMediaRule
						 */
						if (type !== 4) {
							return false;
						}
						/**
						 * Filter:
						 * CSSRule with conditionText of `orientation`
						 */

						return (
							/orientation:\s*landscape/i.test(cssText) ||
							/orientation:\s*portrait/i.test(cssText)
						);
					}
					/**
					 * Interpolate a given CSS Rule to ascertain if orientation is locked by use of any transformation functions that affect rotation along the Z Axis
					 * @param {Object} cssRule given CSS Rule
					 * @property {String} cssRule.selectorText selector text targetted by given cssRule
					 * @property {Object} cssRule.style style
					 * @return {Boolean}
					 */

					function getIsOrientationLocked(_ref15) {
						var selectorText = _ref15.selectorText,
							style = _ref15.style;

						if (!selectorText || style.length <= 0) {
							return false;
						}

						var transformStyle =
							style.transform ||
							style.webkitTransform ||
							style.msTransform ||
							false;

						if (!transformStyle) {
							return false;
						}
						/**
						 * get last match/occurence of a transformation function that can affect rotation along Z axis
						 */

						var matches = transformStyle.match(
							/(rotate|rotateZ|rotate3d|matrix|matrix3d)\(([^)]+)\)(?!.*(rotate|rotateZ|rotate3d|matrix|matrix3d))/
						);

						if (!matches) {
							return false;
						}

						var _matches = _slicedToArray(matches, 3),
							transformFn = _matches[1],
							transformFnValue = _matches[2];

						var degrees = getRotationInDegrees(transformFn, transformFnValue);

						if (!degrees) {
							return false;
						}

						degrees = Math.abs(degrees);
						/**
						 * When degree is a multiple of 180, it is not considered an orientation lock
						 */

						if (Math.abs(degrees - 180) % 180 <= degreeThreshold) {
							return false;
						}

						return Math.abs(degrees - 90) % 90 <= degreeThreshold;
					}
					/**
					 * Interpolate rotation along the z axis from a given value to a transform function
					 * @param {String} transformFunction CSS transformation function
					 * @param {String} transformFnValue value applied to a transform function (contains a unit)
					 * @returns {Number}
					 */

					function getRotationInDegrees(transformFunction, transformFnValue) {
						switch (transformFunction) {
							case 'rotate':
							case 'rotateZ':
								return getAngleInDegrees(transformFnValue);

							case 'rotate3d':
								var _transformFnValue$spl = transformFnValue
										.split(',')
										.map(function(value) {
											return value.trim();
										}),
									_transformFnValue$spl2 = _slicedToArray(
										_transformFnValue$spl,
										4
									),
									z = _transformFnValue$spl2[2],
									angleWithUnit = _transformFnValue$spl2[3];

								if (parseInt(z) === 0) {
									// no transform is applied along z axis -> ignore
									return;
								}

								return getAngleInDegrees(angleWithUnit);

							case 'matrix':
							case 'matrix3d':
								return getAngleInDegreesFromMatrixTransform(transformFnValue);

							default:
								return;
						}
					}
					/**
					 * Get angle in degrees from a transform value by interpolating the unit of measure
					 * @param {String} angleWithUnit value applied to a transform function (Eg: 1turn)
					 * @returns{Number|undefined}
					 */

					function getAngleInDegrees(angleWithUnit) {
						var _ref16 = angleWithUnit.match(/(deg|grad|rad|turn)/) || [],
							_ref17 = _slicedToArray(_ref16, 1),
							unit = _ref17[0];

						if (!unit) {
							return;
						}

						var angle = parseFloat(angleWithUnit.replace(unit, ''));

						switch (unit) {
							case 'rad':
								return convertRadToDeg(angle);

							case 'grad':
								return convertGradToDeg(angle);

							case 'turn':
								return convertTurnToDeg(angle);

							case 'deg':
							default:
								return parseInt(angle);
						}
					}
					/**
					 * Get angle in degrees from a transform value applied to `matrix` or `matrix3d` transform functions
					 * @param {String} transformFnValue value applied to a transform function (contains a unit)
					 * @returns {Number}
					 */

					function getAngleInDegreesFromMatrixTransform(transformFnValue) {
						var values = transformFnValue.split(',');
						/**
						 * Matrix 2D
						 * Notes: https://css-tricks.com/get-value-of-css-rotation-through-javascript/
						 */

						if (values.length <= 6) {
							var _values = _slicedToArray(values, 2),
								a = _values[0],
								_b = _values[1];

							var radians = Math.atan2(parseFloat(_b), parseFloat(a));
							return convertRadToDeg(radians);
						}
						/**
						 * Matrix 3D
						 * Notes: https://drafts.csswg.org/css-transforms-2/#decomposing-a-3d-matrix
						 */

						var sinB = parseFloat(values[8]);
						var b = Math.asin(sinB);
						var cosB = Math.cos(b);
						var rotateZRadians = Math.acos(parseFloat(values[0]) / cosB);
						return convertRadToDeg(rotateZRadians);
					}
					/**
					 * Convert angle specified in unit radians to degrees
					 * See - https://drafts.csswg.org/css-values-3/#rad
					 * @param {Number} radians radians
					 * @return {Number}
					 */

					function convertRadToDeg(radians) {
						return Math.round(radians * (180 / Math.PI));
					}
					/**
					 * Convert angle specified in unit grad to degrees
					 * See - https://drafts.csswg.org/css-values-3/#grad
					 * @param {Number} grad grad
					 * @return {Number}
					 */

					function convertGradToDeg(grad) {
						grad = grad % 400;

						if (grad < 0) {
							grad += 400;
						}

						return Math.round((grad / 400) * 360);
					}
					/**
					 * Convert angle specifed in unit turn to degrees
					 * See - https://drafts.csswg.org/css-values-3/#turn
					 * @param {Number} turn
					 * @returns {Number}
					 */

					function convertTurnToDeg(turn) {
						return Math.round(360 / (1 / turn));
					}
				},
				options: {
					degreeThreshold: 2
				}
			},
			{
				id: 'meta-viewport-large',
				evaluate: function evaluate(node, options, virtualNode, context) {
					options = options || {};
					var params,
						content = node.getAttribute('content') || '',
						parsedParams = content.split(/[;,]/),
						result = {},
						minimum = options.scaleMinimum || 2,
						lowerBound = options.lowerBound || false;

					for (var i = 0, l = parsedParams.length; i < l; i++) {
						params = parsedParams[i].split('=');
						var key = params.shift().toLowerCase();

						if (key && params.length) {
							result[key.trim()] = params
								.shift()
								.trim()
								.toLowerCase();
						}
					}

					if (
						lowerBound &&
						result['maximum-scale'] &&
						parseFloat(result['maximum-scale']) < lowerBound
					) {
						return true;
					}

					if (!lowerBound && result['user-scalable'] === 'no') {
						this.data('user-scalable=no');
						return false;
					}

					if (
						result['maximum-scale'] &&
						parseFloat(result['maximum-scale']) < minimum
					) {
						this.data('maximum-scale');
						return false;
					}

					return true;
				},
				options: {
					scaleMinimum: 5,
					lowerBound: 2
				}
			},
			{
				id: 'meta-viewport',
				evaluate: function evaluate(node, options, virtualNode, context) {
					options = options || {};
					var params,
						content = node.getAttribute('content') || '',
						parsedParams = content.split(/[;,]/),
						result = {},
						minimum = options.scaleMinimum || 2,
						lowerBound = options.lowerBound || false;

					for (var i = 0, l = parsedParams.length; i < l; i++) {
						params = parsedParams[i].split('=');
						var key = params.shift().toLowerCase();

						if (key && params.length) {
							result[key.trim()] = params
								.shift()
								.trim()
								.toLowerCase();
						}
					}

					if (
						lowerBound &&
						result['maximum-scale'] &&
						parseFloat(result['maximum-scale']) < lowerBound
					) {
						return true;
					}

					if (!lowerBound && result['user-scalable'] === 'no') {
						this.data('user-scalable=no');
						return false;
					}

					if (
						result['maximum-scale'] &&
						parseFloat(result['maximum-scale']) < minimum
					) {
						this.data('maximum-scale');
						return false;
					}

					return true;
				},
				options: {
					scaleMinimum: 2
				}
			},
			{
				id: 'header-present',
				evaluate: function evaluate(node, options, virtualNode, context) {
					return !!axe.utils.querySelectorAll(
						virtualNode,
						'h1, h2, h3, h4, h5, h6, [role="heading"]'
					)[0];
				}
			},
			{
				id: 'heading-order',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var ariaHeadingLevel = node.getAttribute('aria-level');

					if (ariaHeadingLevel !== null) {
						this.data(parseInt(ariaHeadingLevel, 10));
						return true;
					}

					var headingLevel = node.nodeName.toUpperCase().match(/H(\d)/);

					if (headingLevel) {
						this.data(parseInt(headingLevel[1], 10));
						return true;
					}

					return true;
				},
				after: function after(results, options) {
					if (results.length < 2) {
						return results;
					}

					var prevLevel = results[0].data;

					for (var i = 1; i < results.length; i++) {
						if (results[i].result && results[i].data > prevLevel + 1) {
							results[i].result = false;
						}

						prevLevel = results[i].data;
					}

					return results;
				}
			},
			{
				id: 'identical-links-same-purpose',
				evaluate: function evaluate(node, options, virtualNode, context) {
					/**
					 * Note: `identical-links-same-purpose-after` fn, helps reconcile the results
					 */
					var _axe$commons14 = axe.commons,
						dom = _axe$commons14.dom,
						text = _axe$commons14.text;
					var accText = text.accessibleTextVirtual(virtualNode);
					var name = text
						.sanitize(
							text.removeUnicode(accText, {
								emoji: true,
								nonBmp: true,
								punctuations: true
							})
						)
						.toLowerCase();

					if (!name) {
						return undefined;
					}
					/**
					 * Set `data` and `relatedNodes` for use in `after` fn
					 */

					var afterData = {
						name: name,
						parsedResource: dom.getParsedResource(node, 'href')
					};
					this.data(afterData);
					this.relatedNodes([node]);
					return true;
				},
				after: function after(results, options) {
					/**
					 * Skip, as no results to curate
					 */
					if (results.length < 2) {
						return results;
					}
					/**
					 * for each result
					 * - get other results with matching accessible name
					 * - check if same purpose is served
					 * - if not change `result` to `undefined`
					 * - construct a list of unique results with relatedNodes to return
					 */

					var uniqueResults = [];
					var nameMap = {};

					for (var index = 0; index < results.length; index++) {
						var _currentResult$relate;

						var currentResult = results[index];
						var data = currentResult.data;
						var name = data.name,
							parsedResource = data.parsedResource;

						if (nameMap[name]) {
							continue;
						}
						/**
						 * when identical nodes exists,
						 * but do not resolve to same purpose -or- do not have parsedResource
						 * flag result as `incomplete`
						 */

						var identicalNodes = getIdenticalNodesWithSameName(
							results,
							name,
							index
						);

						if (
							identicalNodes.length &&
							(!parsedResource ||
								!isIdenticalResource(parsedResource, identicalNodes))
						) {
							currentResult.result = undefined;
						}
						/**
						 *  -> deduplicate results (for both `pass` or `incomplete`) and add `relatedNodes` if any
						 */

						currentResult.relatedNodes = [];

						(_currentResult$relate = currentResult.relatedNodes).push.apply(
							_currentResult$relate,
							_toConsumableArray(
								identicalNodes.map(function(node) {
									return node.relatedNodes[0];
								})
							)
						);

						uniqueResults.push(currentResult);
					}

					return uniqueResults;
					/**
					 * Get list of nodes from results which match a given accessible name
					 * @method getIdenticalNodesWithSameName
					 * @param {Array<Object>} afterResults results passed to the after fn
					 * @param {String} expectedName accessible name to be matched
					 * @param {Number} excludeIndex exclude `index` of result, that should not be taken into consideration
					 * @returns {Array<Object>}
					 */

					function getIdenticalNodesWithSameName(
						afterResults,
						expectedName,
						excludeIndex
					) {
						if (nameMap[expectedName]) {
							return nameMap[expectedName];
						}

						var nodes = afterResults.filter(function(_ref19, index) {
							var data = _ref19.data;
							var name = data.name;
							return index !== excludeIndex && name === expectedName;
						});
						nameMap[expectedName] = nodes;
						return nodes;
					}
					/**
					 * Verify if parsed resource match against all given identical nodes
					 * @method isIdenticalResource
					 * @param {Object} expectedResource parsed resource to be matched against
					 * @param {Array<Object>} identicalNodes nodes with identical accessible name whose parsed resource is checked for identity
					 * @returns {Boolean}
					 */

					function isIdenticalResource(expectedResource, identicalNodes) {
						return identicalNodes.every(function(_ref20) {
							var data = _ref20.data;
							var parsedResource = data.parsedResource;

							if (!parsedResource) {
								return false;
							} // remove key's whose values are undefined

							var keysWithValues = Object.keys(parsedResource).filter(function(
								key
							) {
								return !!parsedResource[key];
							}); // ensure every key/ value in resources match

							var result = keysWithValues.every(function(key) {
								var actual = parsedResource[key];
								var expected = expectedResource[key];
								return actual === expected;
							});
							return result;
						});
					}
				}
			},
			{
				id: 'internal-link-present',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var links = axe.utils.querySelectorAll(virtualNode, 'a[href]');
					return links.some(function(vLink) {
						return /^#[^/!]/.test(vLink.actualNode.getAttribute('href'));
					});
				}
			},
			{
				id: 'landmark',
				evaluate: function evaluate(node, options, virtualNode, context) {
					return (
						axe.utils.querySelectorAll(virtualNode, 'main, [role="main"]')
							.length > 0
					);
				}
			},
			{
				id: 'meta-refresh',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var content = node.getAttribute('content') || '',
						parsedParams = content.split(/[;,]/);
					return content === '' || parsedParams[0] === '0';
				}
			},
			{
				id: 'p-as-heading',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var siblings = Array.from(node.parentNode.children);
					var currentIndex = siblings.indexOf(node);
					options = options || {};
					var margins = options.margins || [];
					var nextSibling = siblings
						.slice(currentIndex + 1)
						.find(function(elm) {
							return elm.nodeName.toUpperCase() === 'P';
						});
					var prevSibling = siblings
						.slice(0, currentIndex)
						.reverse()
						.find(function(elm) {
							return elm.nodeName.toUpperCase() === 'P';
						});

					function getTextContainer(elm) {
						var nextNode = elm;
						var outerText = elm.textContent.trim();
						var innerText = outerText;

						while (innerText === outerText && nextNode !== undefined) {
							var i = -1;
							elm = nextNode;

							if (elm.children.length === 0) {
								return elm;
							}

							do {
								// find the first non-empty child
								i++;
								innerText = elm.children[i].textContent.trim();
							} while (innerText === '' && i + 1 < elm.children.length);

							nextNode = elm.children[i];
						}

						return elm;
					}

					function normalizeFontWeight(weight) {
						/* eslint indent: 0*/
						switch (weight) {
							case 'lighter':
								return 100;

							case 'normal':
								return 400;

							case 'bold':
								return 700;

							case 'bolder':
								return 900;
						}

						weight = parseInt(weight);
						return !isNaN(weight) ? weight : 400;
					}

					function getStyleValues(node) {
						var style = window.getComputedStyle(getTextContainer(node));
						return {
							fontWeight: normalizeFontWeight(
								style.getPropertyValue('font-weight')
							),
							fontSize: parseInt(style.getPropertyValue('font-size')),
							isItalic: style.getPropertyValue('font-style') === 'italic'
						};
					}

					function isHeaderStyle(styleA, styleB, margins) {
						return margins.reduce(function(out, margin) {
							return (
								out ||
								((!margin.size ||
									styleA.fontSize / margin.size > styleB.fontSize) &&
									(!margin.weight ||
										styleA.fontWeight - margin.weight > styleB.fontWeight) &&
									(!margin.italic || (styleA.isItalic && !styleB.isItalic)))
							);
						}, false);
					}

					var currStyle = getStyleValues(node);
					var nextStyle = nextSibling ? getStyleValues(nextSibling) : null;
					var prevStyle = prevSibling ? getStyleValues(prevSibling) : null;

					if (!nextStyle || !isHeaderStyle(currStyle, nextStyle, margins)) {
						return true;
					}

					var blockquote = axe.commons.dom.findUpVirtual(
						virtualNode,
						'blockquote'
					);

					if (
						blockquote &&
						blockquote.nodeName.toUpperCase() === 'BLOCKQUOTE'
					) {
						return undefined;
					}

					if (prevStyle && !isHeaderStyle(currStyle, prevStyle, margins)) {
						return undefined;
					}

					return false;
				},
				options: {
					margins: [
						{
							weight: 150,
							italic: true
						},
						{
							weight: 150,
							size: 1.15
						},
						{
							italic: true,
							size: 1.15
						},
						{
							size: 1.4
						}
					]
				}
			},
			{
				id: 'region',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var _axe$commons15 = axe.commons,
						dom = _axe$commons15.dom,
						aria = _axe$commons15.aria;
					var landmarkRoles = aria.getRolesByType('landmark'); // Create a list of nodeNames that have a landmark as an implicit role

					var implicitLandmarks = landmarkRoles
						.reduce(function(arr, role) {
							return arr.concat(aria.implicitNodes(role));
						}, [])
						.filter(function(r) {
							return r !== null;
						}); // Check if the current element is a landmark

					function isRegion(virtualNode) {
						var node = virtualNode.actualNode;
						var explicitRole = axe.commons.aria.getRole(node, {
							noImplicit: true
						});
						var ariaLive = (node.getAttribute('aria-live') || '')
							.toLowerCase()
							.trim();

						if (explicitRole) {
							return (
								explicitRole === 'dialog' ||
								landmarkRoles.includes(explicitRole)
							);
						} // Ignore content inside of aria-live

						if (['assertive', 'polite'].includes(ariaLive)) {
							return true;
						} // Check if the node matches any of the CSS selectors of implicit landmarks

						return implicitLandmarks.some(function(implicitSelector) {
							var matches = axe.utils.matchesSelector(node, implicitSelector);

							if (node.nodeName.toUpperCase() === 'FORM') {
								var titleAttr = node.getAttribute('title');
								var title =
									titleAttr && titleAttr.trim() !== ''
										? axe.commons.text.sanitize(titleAttr)
										: null;
								return matches && (!!aria.labelVirtual(virtualNode) || !!title);
							}

							return matches;
						});
					}
					/**
					 * Find all visible elements not wrapped inside a landmark or skiplink
					 */

					function findRegionlessElms(virtualNode) {
						var node = virtualNode.actualNode; // End recursion if the element is a landmark, skiplink, or hidden content

						if (
							isRegion(virtualNode) ||
							(dom.isSkipLink(virtualNode.actualNode) &&
								dom.getElementByReference(virtualNode.actualNode, 'href')) ||
							!dom.isVisible(node, true)
						) {
							return []; // Return the node is a content element
						} else if (
							dom.hasContent(
								node,
								/* noRecursion: */
								true
							)
						) {
							return [node]; // Recursively look at all child elements
						} else {
							return virtualNode.children
								.filter(function(_ref21) {
									var actualNode = _ref21.actualNode;
									return actualNode.nodeType === 1;
								})
								.map(findRegionlessElms)
								.reduce(function(a, b) {
									return a.concat(b);
								}, []); // flatten the results
						}
					}

					var regionlessNodes = findRegionlessElms(virtualNode);
					this.relatedNodes(regionlessNodes);
					return regionlessNodes.length === 0;
				},
				after: function after(results, options) {
					return [results[0]];
				}
			},
			{
				id: 'skip-link',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var target = axe.commons.dom.getElementByReference(node, 'href');

					if (target) {
						return axe.commons.dom.isVisible(target, true) || undefined;
					}

					return false;
				}
			},
			{
				id: 'unique-frame-title',
				evaluate: function evaluate(node, options, virtualNode, context) {
					/**
					 * Note:
					 * `unique-frame-title` fn, helps reconcile the results
					 */
					var text = axe.commons.text;
					var accText = text.accessibleTextVirtual(virtualNode);
					var name = curateText(accText, {
						emoji: true,
						nonBmp: true,
						punctuations: true,
						sanitize: true,
						lowercase: true
					});

					if (!name) {
						return undefined;
					}
					/**
					 * Set `data` and `relatedNodes` for use in `after` fn
					 */

					var afterData = {
						name: name,
						parsedResource: getParsedResource(node, 'src'),
						resourceFrameTitle: text
							.sanitize(node.contentDocument.title)
							.toLowerCase()
					};
					this.data(afterData);
					this.relatedNodes([node]);
					return true;
					/**
					 * Curate a given string
					 * @method curateText
					 * @param {String} str given string to curate
					 * @param {Object} options options to curate
					 * @property {Boolean} options.emoji remove emoji characters?
					 * @property {Boolean} options.nonBmp remove nonBmp characters?
					 * @property {Boolean} options.punctuations remove punctuation characters?
					 * @property {Boolean} options.sanitize santize given string?
					 * @property {Boolean} options.lowercase convert given string to lowercase?
					 * @returns {String}
					 */

					function curateText(str, options) {
						var _options$emoji = options.emoji,
							emoji = _options$emoji === void 0 ? false : _options$emoji,
							_options$nonBmp = options.nonBmp,
							nonBmp = _options$nonBmp === void 0 ? false : _options$nonBmp,
							_options$punctuations = options.punctuations,
							punctuations =
								_options$punctuations === void 0
									? false
									: _options$punctuations,
							_options$sanitize = options.sanitize,
							sanitize =
								_options$sanitize === void 0 ? false : _options$sanitize,
							_options$lowercase = options.lowercase,
							lowercase =
								_options$lowercase === void 0 ? false : _options$lowercase;
						var curatedText = text.removeUnicode(str, {
							emoji: emoji,
							nonBmp: nonBmp,
							punctuations: punctuations
						});

						if (sanitize) {
							curatedText = text.sanitize(curatedText);
						}

						if (lowercase) {
							curatedText = curatedText.toLowerCase();
						}

						return curatedText;
					}
					/**
					 * Construct a resource object for a given node fromt he attribute provided
					 * @method getParsedResource
					 * @param {HTMLElement} currentNode node
					 * @param {String} attribute of the node to be used for resolving resource
					 * @returns {Object}
					 */

					function getParsedResource(currentNode, attribute) {
						var value = currentNode[attribute];

						if (!value) {
							return undefined;
						}

						var parser = document.createElement('a');
						parser.href = value;

						var _getPathnameAndFilena = getPathnameAndFilename(parser.pathname),
							_getPathnameAndFilena2 = _slicedToArray(_getPathnameAndFilena, 2),
							pathname = _getPathnameAndFilena2[0],
							filename = _getPathnameAndFilena2[1];

						return {
							protocol: parser.protocol,
							hostname: parser.hostname,
							port: parser.port,
							pathname: pathname.replace(/^\/|\/$/g, ''),
							// revmove lead/trial(ing) slashes
							search: parser.search,
							hash: getHash(parser.hash),
							filename: filename
						};
					}
					/**
					 * Resolve if a given pathname has filename & resolve the same as parts
					 * @method getPathnameAndFilename
					 * @param {String} pathname pathname part of a given uri
					 * @returns {Array<String>}
					 */

					function getPathnameAndFilename(pathname) {
						if (!pathname) {
							return;
						}

						var filename = pathname.split('/').pop();

						if (!filename) {
							return [pathname];
						}

						if (filename.indexOf('.') === -1) {
							return [pathname];
						}

						var hasIndexInFilename = /index./.test(filename);

						if (hasIndexInFilename) {
							return [pathname.replace(filename, '')];
						}

						return [filename];
					}
					/**
					 * Interpret a given hash
					 * if `hash`
					 * -> is `hashbang` -or- `hash` is followed by `slash`
					 * -> it resolves to a different resource
					 * @method getHash
					 * @param {String} hash hash component of a parsed uri
					 * @returns {String|undefined}
					 */

					function getHash(hash) {
						if (!hash) {
							return undefined;
						}

						if (!(hash.includes('#!/') || hash.includes('#/'))) {
							return undefined;
						}

						return hash;
					}
				},
				after: function after(results, options) {
					/**
					 * Skip, as no results to curate
					 */
					if (results.length < 2) {
						return results;
					}
					/**
					 * for each result
					 * - get other results with matching accessible name
					 * - check if same purpose is served
					 * - if not change `result` to `undefined`
					 * - construct a list of unique results with relatedNodes to return
					 */

					var uniqueResults = [];
					var nameMap = {};

					for (var index = 0; index < results.length; index++) {
						var _currentResult$relate2;

						var currentResult = results[index];
						var data = currentResult.data;
						var name = data.name,
							parsedResource = data.parsedResource,
							resourceFrameTitle = data.resourceFrameTitle;

						if (nameMap[name]) {
							continue;
						}
						/**
						 * when identical nodes exists,
						 * but do not resolve to same purpose -or- do not have parsedResource
						 * flag result as `incomplete`
						 */

						var identicalNodes = getIdenticalNodesWithSameName(
							results,
							name,
							index
						);

						if (
							identicalNodes.length &&
							(!parsedResource ||
								!isIdenticalResource(
									parsedResource,
									resourceFrameTitle,
									identicalNodes
								))
						) {
							currentResult.result = undefined;
						}
						/**
						 *  -> deduplicate results (for both `pass` or `incomplete`) and add `relatedNodes` if any
						 */

						currentResult.relatedNodes = [];

						(_currentResult$relate2 = currentResult.relatedNodes).push.apply(
							_currentResult$relate2,
							_toConsumableArray(
								identicalNodes.map(function(node) {
									return node.relatedNodes[0];
								})
							)
						);

						uniqueResults.push(currentResult);
					}

					return uniqueResults;
					/**
					 * Get list of nodes from results which match a given accessible name
					 * @method getIdenticalNodesWithSameName
					 * @param {Array<Object>} afterResults results passed to the after fn
					 * @param {String} expectedName accessible name to be matched
					 * @param {Number} excludeIndex exclude `index` of result, that should not be taken into consideration
					 * @returns {Array<Object>}
					 */

					function getIdenticalNodesWithSameName(
						afterResults,
						expectedName,
						excludeIndex
					) {
						if (nameMap[expectedName]) {
							return nameMap[expectedName];
						}

						var nodes = afterResults.filter(function(_ref22, index) {
							var data = _ref22.data;
							var name = data.name;
							return index !== excludeIndex && name === expectedName;
						});
						nameMap[expectedName] = nodes;
						return nodes;
					}
					/**
					 * Verify if parsed resource match against all given identical nodes
					 * @method isIdenticalResource
					 * @param {Object} expectedResource parsed resource to be matched against
					 * @param {String} expectedResourceFrameTitle frame document title to be matched against
					 * @param {Array<Object>} identicalNodes nodes with identical accessible name whose parsed resource is checked for identity
					 * @returns {Boolean}
					 */

					function isIdenticalResource(
						expectedResource,
						expectedResourceFrameTitle,
						identicalNodes
					) {
						return identicalNodes.every(function(_ref23) {
							var data = _ref23.data;
							var parsedResource = data.parsedResource,
								resourceFrameTitle = data.resourceFrameTitle;

							if (!parsedResource) {
								return false;
							} // remove key's whose values are undefined

							var keysWithValues = Object.keys(parsedResource).filter(function(
								key
							) {
								return !!parsedResource[key];
							});
							/**
							 * ensure every key/ value in resources match
							 * keep an array of non matching keys, to verify if document titles have to be compared
							 */

							var nonMatchingKeys = [];

							for (var _index = 0; _index < keysWithValues.length; _index++) {
								var key = keysWithValues[_index];
								var actual = parsedResource[key];
								var expected = expectedResource[key];

								if (actual !== expected) {
									nonMatchingKeys.push(key);
								}
							} // no non-matching keys - pass

							if (!nonMatchingKeys.length) {
								return true;
							}
							/**
							 * Only validate frame document title if property `pathname` is a non matching key
							 */

							if (
								nonMatchingKeys.length === 1 &&
								nonMatchingKeys.includes('pathname')
							) {
								if (
									resourceFrameTitle === 'Error' ||
									expectedResourceFrameTitle === 'Error'
								) {
									return false;
								}

								return resourceFrameTitle === expectedResourceFrameTitle;
							}

							return false;
						});
					}
				}
			},
			{
				id: 'duplicate-id-active',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var id = node.getAttribute('id').trim(); // Since empty ID's are not meaningful and are ignored by Edge, we'll
					// let those pass.

					if (!id) {
						return true;
					}

					var root = axe.commons.dom.getRootNode(node);
					var matchingNodes = Array.from(
						root.querySelectorAll(
							'[id="'.concat(axe.utils.escapeSelector(id), '"]')
						)
					).filter(function(foundNode) {
						return foundNode !== node;
					});

					if (matchingNodes.length) {
						this.relatedNodes(matchingNodes);
					}

					this.data(id);
					return matchingNodes.length === 0;
				},
				after: function after(results, options) {
					var uniqueIds = [];
					return results.filter(function(r) {
						if (uniqueIds.indexOf(r.data) === -1) {
							uniqueIds.push(r.data);
							return true;
						}

						return false;
					});
				}
			},
			{
				id: 'duplicate-id-aria',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var id = node.getAttribute('id').trim(); // Since empty ID's are not meaningful and are ignored by Edge, we'll
					// let those pass.

					if (!id) {
						return true;
					}

					var root = axe.commons.dom.getRootNode(node);
					var matchingNodes = Array.from(
						root.querySelectorAll(
							'[id="'.concat(axe.utils.escapeSelector(id), '"]')
						)
					).filter(function(foundNode) {
						return foundNode !== node;
					});

					if (matchingNodes.length) {
						this.relatedNodes(matchingNodes);
					}

					this.data(id);
					return matchingNodes.length === 0;
				},
				after: function after(results, options) {
					var uniqueIds = [];
					return results.filter(function(r) {
						if (uniqueIds.indexOf(r.data) === -1) {
							uniqueIds.push(r.data);
							return true;
						}

						return false;
					});
				}
			},
			{
				id: 'duplicate-id',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var id = node.getAttribute('id').trim(); // Since empty ID's are not meaningful and are ignored by Edge, we'll
					// let those pass.

					if (!id) {
						return true;
					}

					var root = axe.commons.dom.getRootNode(node);
					var matchingNodes = Array.from(
						root.querySelectorAll(
							'[id="'.concat(axe.utils.escapeSelector(id), '"]')
						)
					).filter(function(foundNode) {
						return foundNode !== node;
					});

					if (matchingNodes.length) {
						this.relatedNodes(matchingNodes);
					}

					this.data(id);
					return matchingNodes.length === 0;
				},
				after: function after(results, options) {
					var uniqueIds = [];
					return results.filter(function(r) {
						if (uniqueIds.indexOf(r.data) === -1) {
							uniqueIds.push(r.data);
							return true;
						}

						return false;
					});
				}
			},
			{
				id: 'aria-label',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var _axe$commons16 = axe.commons,
						text = _axe$commons16.text,
						aria = _axe$commons16.aria;
					return !!text.sanitize(aria.arialabelText(virtualNode));
				}
			},
			{
				id: 'aria-labelledby',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var _axe$commons17 = axe.commons,
						text = _axe$commons17.text,
						aria = _axe$commons17.aria;
					return !!text.sanitize(aria.arialabelledbyText(node));
				}
			},
			{
				id: 'avoid-inline-spacing',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var inlineSpacingCssProperties = [
						'line-height',
						'letter-spacing',
						'word-spacing'
					];
					var overriddenProperties = inlineSpacingCssProperties.filter(function(
						property
					) {
						if (node.style.getPropertyPriority(property) === 'important') {
							return property;
						}
					});

					if (overriddenProperties.length > 0) {
						this.data(overriddenProperties);
						return false;
					}

					return true;
				}
			},
			{
				id: 'button-has-visible-text',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var nodeName = node.nodeName.toUpperCase();
					var role = node.getAttribute('role');
					var label;

					if (
						nodeName === 'BUTTON' ||
						(role === 'button' && nodeName !== 'INPUT')
					) {
						label = axe.commons.text.accessibleTextVirtual(virtualNode);
						this.data(label);
						return !!label;
					} else {
						return false;
					}
				}
			},
			{
				id: 'doc-has-title',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var title = document.title;
					return !!(title ? axe.commons.text.sanitize(title).trim() : '');
				}
			},
			{
				id: 'exists',
				evaluate: function evaluate(node, options, virtualNode, context) {
					return undefined;
				}
			},
			{
				id: 'filename-is-valid-accessible-name',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var text = axe.commons.text;
					var accText = text.accessibleText(node).toLowerCase();
					/**
					 * Check if accessible name, uses filename (along with file extension)
					 * eg: Download image of Tajmahal.jpg
					 */

					var fileExtn = /[.]/.exec(accText)
						? /[^.]+$/.exec(accText)[0].toLowerCase()
						: undefined;
					var allowedExtns = ['jpg', 'jpeg', 'png', 'gif', 'tif', 'webp'];

					if (fileExtn && allowedExtns.includes(fileExtn)) {
						return undefined;
					}
					/**
					 * Get source value & check of filename is used in accessible name
					 */

					var srcValue = node.getAttribute('src').toLowerCase();
					var fileName = text.sanitize(srcValue.split('/').pop());
					var fileNameWithoutExtn = fileName.split('.').shift();

					if (accText.includes(fileNameWithoutExtn)) {
						return true;
					}

					return undefined;
				}
			},
			{
				id: 'has-alt',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var nodeName = virtualNode.props.nodeName;

					if (!['img', 'input', 'area'].includes(nodeName)) {
						return false;
					}

					return virtualNode.hasAttr('alt');
				}
			},
			{
				id: 'has-visible-text',
				evaluate: function evaluate(node, options, virtualNode, context) {
					return axe.commons.text.accessibleTextVirtual(virtualNode).length > 0;
				}
			},
			{
				id: 'is-on-screen',
				evaluate: function evaluate(node, options, virtualNode, context) {
					// From a visual perspective
					return (
						axe.commons.dom.isVisible(node, false) &&
						!axe.commons.dom.isOffscreen(node)
					);
				}
			},
			{
				id: 'non-empty-alt',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var label = virtualNode.attr('alt');
					return !!(label ? axe.commons.text.sanitize(label).trim() : '');
				}
			},
			{
				id: 'non-empty-if-present',
				evaluate: function evaluate(node, options, virtualNode, context) {
					// Check for 'default' names, which are given to reset and submit buttons
					var nodeName = node.nodeName.toUpperCase();
					var type = (node.getAttribute('type') || '').toLowerCase();
					var label = node.getAttribute('value');

					if (label) {
						this.data({
							messageKey: 'has-label'
						});
					}

					if (nodeName === 'INPUT' && ['submit', 'reset'].includes(type)) {
						return label === null;
					}

					return false;
				}
			},
			{
				id: 'non-empty-title',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var text = axe.commons.text;
					return !!text.sanitize(text.titleText(node));
				}
			},
			{
				id: 'non-empty-value',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var label = node.getAttribute('value');
					return !!(label ? axe.commons.text.sanitize(label).trim() : '');
				}
			},
			{
				id: 'role-none',
				evaluate: function evaluate(node, options, virtualNode, context) {
					return node.getAttribute('role') === 'none';
				}
			},
			{
				id: 'role-presentation',
				evaluate: function evaluate(node, options, virtualNode, context) {
					return node.getAttribute('role') === 'presentation';
				}
			},
			{
				id: 'svg-non-empty-title',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var title = virtualNode.children.find(function(_ref24) {
						var props = _ref24.props;
						return props.nodeName === 'title';
					});
					return !!title && title.actualNode.textContent.trim() !== '';
				}
			},
			{
				id: 'caption-faked',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var table = axe.commons.table.toGrid(node);
					var firstRow = table[0];

					if (
						table.length <= 1 ||
						firstRow.length <= 1 ||
						node.rows.length <= 1
					) {
						return true;
					}

					return firstRow.reduce(function(out, curr, i) {
						return (
							out || (curr !== firstRow[i + 1] && firstRow[i + 1] !== undefined)
						);
					}, false);
				}
			},
			{
				id: 'has-caption',
				evaluate: function evaluate(node, options, virtualNode, context) {
					return !!node.caption;
				},
				deprecated: true
			},
			{
				id: 'has-summary',
				evaluate: function evaluate(node, options, virtualNode, context) {
					return !!node.summary;
				},
				deprecated: true
			},
			{
				id: 'has-th',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var row,
						cell,
						badCells = [];

					for (
						var rowIndex = 0, rowLength = node.rows.length;
						rowIndex < rowLength;
						rowIndex++
					) {
						row = node.rows[rowIndex];

						for (
							var cellIndex = 0, cellLength = row.cells.length;
							cellIndex < cellLength;
							cellIndex++
						) {
							cell = row.cells[cellIndex];

							if (
								cell.nodeName.toUpperCase() === 'TH' ||
								['rowheader', 'columnheader'].indexOf(
									cell.getAttribute('role')
								) !== -1
							) {
								badCells.push(cell);
							}
						}
					}

					if (badCells.length) {
						this.relatedNodes(badCells);
						return true;
					}

					return false;
				},
				deprecated: true
			},
			{
				id: 'html5-scope',
				evaluate: function evaluate(node, options, virtualNode, context) {
					if (!axe.commons.dom.isHTML5(document)) {
						return true;
					}

					return node.nodeName.toUpperCase() === 'TH';
				}
			},
			{
				id: 'same-caption-summary',
				evaluate: function evaluate(node, options, virtualNode, context) {
					// passing node.caption to accessibleText instead of using
					// the logic in accessibleTextVirtual on virtualNode
					return (
						!!(node.summary && node.caption) &&
						node.summary.toLowerCase() ===
							axe.commons.text.accessibleText(node.caption).toLowerCase()
					);
				}
			},
			{
				id: 'scope-value',
				evaluate: function evaluate(node, options, virtualNode, context) {
					options = options || {};
					var value = node.getAttribute('scope').toLowerCase();
					var validVals =
						['row', 'col', 'rowgroup', 'colgroup'] || options.values;
					return validVals.indexOf(value) !== -1;
				}
			},
			{
				id: 'td-has-header',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var tableUtils = axe.commons.table;
					var badCells = [];
					var cells = tableUtils.getAllCells(node);
					var tableGrid = tableUtils.toGrid(node);
					cells.forEach(function(cell) {
						// For each non-empty data cell that doesn't have an aria label
						if (
							axe.commons.dom.hasContent(cell) &&
							tableUtils.isDataCell(cell) &&
							!axe.commons.aria.label(cell)
						) {
							// Check if it has any headers
							var hasHeaders = tableUtils
								.getHeaders(cell, tableGrid)
								.some(function(header) {
									return (
										header !== null && !!axe.commons.dom.hasContent(header)
									);
								}); // If no headers, put it on the naughty list

							if (!hasHeaders) {
								badCells.push(cell);
							}
						}
					});

					if (badCells.length) {
						this.relatedNodes(badCells);
						return false;
					}

					return true;
				}
			},
			{
				id: 'td-headers-attr',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var cells = [];

					for (
						var rowIndex = 0, rowLength = node.rows.length;
						rowIndex < rowLength;
						rowIndex++
					) {
						var row = node.rows[rowIndex];

						for (
							var cellIndex = 0, cellLength = row.cells.length;
							cellIndex < cellLength;
							cellIndex++
						) {
							cells.push(row.cells[cellIndex]);
						}
					}

					var ids = cells.reduce(function(ids, cell) {
						if (cell.getAttribute('id')) {
							ids.push(cell.getAttribute('id'));
						}

						return ids;
					}, []);
					var badCells = cells.reduce(function(badCells, cell) {
						var isSelf, notOfTable; // Get a list all the values of the headers attribute

						var headers = (cell.getAttribute('headers') || '')
							.split(/\s/)
							.reduce(function(headers, header) {
								header = header.trim();

								if (header) {
									headers.push(header);
								}

								return headers;
							}, []);

						if (headers.length !== 0) {
							// Check if the cell's id is in this list
							if (cell.getAttribute('id')) {
								isSelf = headers.indexOf(cell.getAttribute('id').trim()) !== -1;
							} // Check if the headers are of cells inside the table

							notOfTable = headers.reduce(function(fail, header) {
								return fail || ids.indexOf(header) === -1;
							}, false);

							if (isSelf || notOfTable) {
								badCells.push(cell);
							}
						}

						return badCells;
					}, []);

					if (badCells.length > 0) {
						this.relatedNodes(badCells);
						return false;
					} else {
						return true;
					}
				}
			},
			{
				id: 'th-has-data-cells',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var tableUtils = axe.commons.table;
					var cells = tableUtils.getAllCells(node);
					var checkResult = this; // Get a list of all headers reffed to in this rule

					var reffedHeaders = [];
					cells.forEach(function(cell) {
						var headers = cell.getAttribute('headers');

						if (headers) {
							reffedHeaders = reffedHeaders.concat(headers.split(/\s+/));
						}

						var ariaLabel = cell.getAttribute('aria-labelledby');

						if (ariaLabel) {
							reffedHeaders = reffedHeaders.concat(ariaLabel.split(/\s+/));
						}
					}); // Get all the headers

					var headers = cells.filter(function(cell) {
						if (axe.commons.text.sanitize(cell.textContent) === '') {
							return false;
						}

						return (
							cell.nodeName.toUpperCase() === 'TH' ||
							['rowheader', 'columnheader'].indexOf(
								cell.getAttribute('role')
							) !== -1
						);
					});
					var tableGrid = tableUtils.toGrid(node);
					var out = true;
					headers.forEach(function(header) {
						if (
							header.getAttribute('id') &&
							reffedHeaders.includes(header.getAttribute('id'))
						) {
							return;
						}

						var pos = tableUtils.getCellPosition(header, tableGrid); // ensure column header has at least 1 non-header cell

						var hasCell = false;

						if (tableUtils.isColumnHeader(header)) {
							hasCell = tableUtils
								.traverse('down', pos, tableGrid)
								.find(function(cell) {
									return !tableUtils.isColumnHeader(cell);
								});
						} // ensure row header has at least 1 non-header cell

						if (!hasCell && tableUtils.isRowHeader(header)) {
							hasCell = tableUtils
								.traverse('right', pos, tableGrid)
								.find(function(cell) {
									return !tableUtils.isRowHeader(cell);
								});
						} // report the node as having failed

						if (!hasCell) {
							checkResult.relatedNodes(header);
						}

						out = out && hasCell;
					});
					return out ? true : undefined;
				}
			},
			{
				id: 'hidden-content',
				evaluate: function evaluate(node, options, virtualNode, context) {
					var whitelist = [
						'SCRIPT',
						'HEAD',
						'TITLE',
						'NOSCRIPT',
						'STYLE',
						'TEMPLATE'
					];

					if (
						!whitelist.includes(node.nodeName.toUpperCase()) &&
						axe.commons.dom.hasContentVirtual(virtualNode)
					) {
						var styles = window.getComputedStyle(node);

						if (styles.getPropertyValue('display') === 'none') {
							return undefined;
						} else if (styles.getPropertyValue('visibility') === 'hidden') {
							// Check if visibility isn't inherited
							var parent = axe.commons.dom.getComposedParent(node);
							var parentStyle = parent && window.getComputedStyle(parent);

							if (
								!parentStyle ||
								parentStyle.getPropertyValue('visibility') !== 'hidden'
							) {
								return undefined;
							}
						}
					}

					return true;
				}
			}
		],
		commons: (function() {
			/*exported commons */

			/*eslint no-unused-vars: 0*/

			/** @namespace axe */

			/**
			 * Namespace for axe common methods.
			 * @namespace commons
			 * @memberof axe
			 */
			var commons = {};
			/**
			 * Namespace for aria-related utilities.
			 * @namespace commons.aria
			 * @memberof axe
			 */

			var aria = (commons.aria = {});
			var lookupTable = (aria.lookupTable = {});

			var isNull = function isNull(value) {
				return value === null;
			};

			var isNotNull = function isNotNull(value) {
				return value !== null;
			};

			lookupTable.attributes = {
				'aria-activedescendant': {
					type: 'idref',
					allowEmpty: true,
					unsupported: false
				},
				'aria-atomic': {
					type: 'boolean',
					values: ['true', 'false'],
					unsupported: false
				},
				'aria-autocomplete': {
					type: 'nmtoken',
					values: ['inline', 'list', 'both', 'none'],
					unsupported: false
				},
				'aria-busy': {
					type: 'boolean',
					values: ['true', 'false'],
					unsupported: false
				},
				'aria-checked': {
					type: 'nmtoken',
					values: ['true', 'false', 'mixed', 'undefined'],
					unsupported: false
				},
				'aria-colcount': {
					type: 'int',
					unsupported: false
				},
				'aria-colindex': {
					type: 'int',
					unsupported: false
				},
				'aria-colspan': {
					type: 'int',
					unsupported: false
				},
				'aria-controls': {
					type: 'idrefs',
					allowEmpty: true,
					unsupported: false
				},
				'aria-current': {
					type: 'nmtoken',
					allowEmpty: true,
					values: ['page', 'step', 'location', 'date', 'time', 'true', 'false'],
					unsupported: false
				},
				'aria-describedby': {
					type: 'idrefs',
					allowEmpty: true,
					unsupported: false
				},
				'aria-describedat': {
					unsupported: true,
					unstandardized: true
				},
				'aria-details': {
					unsupported: true
				},
				'aria-disabled': {
					type: 'boolean',
					values: ['true', 'false'],
					unsupported: false
				},
				'aria-dropeffect': {
					type: 'nmtokens',
					values: ['copy', 'move', 'reference', 'execute', 'popup', 'none'],
					unsupported: false
				},
				'aria-errormessage': {
					type: 'idref',
					allowEmpty: true,
					unsupported: false
				},
				'aria-expanded': {
					type: 'nmtoken',
					values: ['true', 'false', 'undefined'],
					unsupported: false
				},
				'aria-flowto': {
					type: 'idrefs',
					allowEmpty: true,
					unsupported: false
				},
				'aria-grabbed': {
					type: 'nmtoken',
					values: ['true', 'false', 'undefined'],
					unsupported: false
				},
				'aria-haspopup': {
					type: 'nmtoken',
					allowEmpty: true,
					values: [
						'true',
						'false',
						'menu',
						'listbox',
						'tree',
						'grid',
						'dialog'
					],
					unsupported: false
				},
				'aria-hidden': {
					type: 'boolean',
					values: ['true', 'false'],
					unsupported: false
				},
				'aria-invalid': {
					type: 'nmtoken',
					allowEmpty: true,
					values: ['true', 'false', 'spelling', 'grammar'],
					unsupported: false
				},
				'aria-keyshortcuts': {
					type: 'string',
					allowEmpty: true,
					unsupported: false
				},
				'aria-label': {
					type: 'string',
					allowEmpty: true,
					unsupported: false
				},
				'aria-labelledby': {
					type: 'idrefs',
					allowEmpty: true,
					unsupported: false
				},
				'aria-level': {
					type: 'int',
					unsupported: false
				},
				'aria-live': {
					type: 'nmtoken',
					values: ['off', 'polite', 'assertive'],
					unsupported: false
				},
				'aria-modal': {
					type: 'boolean',
					values: ['true', 'false'],
					unsupported: false
				},
				'aria-multiline': {
					type: 'boolean',
					values: ['true', 'false'],
					unsupported: false
				},
				'aria-multiselectable': {
					type: 'boolean',
					values: ['true', 'false'],
					unsupported: false
				},
				'aria-orientation': {
					type: 'nmtoken',
					values: ['horizontal', 'vertical'],
					unsupported: false
				},
				'aria-owns': {
					type: 'idrefs',
					allowEmpty: true,
					unsupported: false
				},
				'aria-placeholder': {
					type: 'string',
					allowEmpty: true,
					unsupported: false
				},
				'aria-posinset': {
					type: 'int',
					unsupported: false
				},
				'aria-pressed': {
					type: 'nmtoken',
					values: ['true', 'false', 'mixed', 'undefined'],
					unsupported: false
				},
				'aria-readonly': {
					type: 'boolean',
					values: ['true', 'false'],
					unsupported: false
				},
				'aria-relevant': {
					type: 'nmtokens',
					values: ['additions', 'removals', 'text', 'all'],
					unsupported: false
				},
				'aria-required': {
					type: 'boolean',
					values: ['true', 'false'],
					unsupported: false
				},
				'aria-roledescription': {
					type: 'string',
					allowEmpty: true,
					unsupported: false
				},
				'aria-rowcount': {
					type: 'int',
					unsupported: false
				},
				'aria-rowindex': {
					type: 'int',
					unsupported: false
				},
				'aria-rowspan': {
					type: 'int',
					unsupported: false
				},
				'aria-selected': {
					type: 'nmtoken',
					values: ['true', 'false', 'undefined'],
					unsupported: false
				},
				'aria-setsize': {
					type: 'int',
					unsupported: false
				},
				'aria-sort': {
					type: 'nmtoken',
					values: ['ascending', 'descending', 'other', 'none'],
					unsupported: false
				},
				'aria-valuemax': {
					type: 'decimal',
					unsupported: false
				},
				'aria-valuemin': {
					type: 'decimal',
					unsupported: false
				},
				'aria-valuenow': {
					type: 'decimal',
					unsupported: false
				},
				'aria-valuetext': {
					type: 'string',
					unsupported: false
				}
			};
			lookupTable.globalAttributes = [
				'aria-atomic',
				'aria-busy',
				'aria-controls',
				'aria-current',
				'aria-describedby',
				'aria-disabled',
				'aria-dropeffect',
				'aria-flowto',
				'aria-grabbed',
				'aria-haspopup',
				'aria-hidden',
				'aria-invalid',
				'aria-keyshortcuts',
				'aria-label',
				'aria-labelledby',
				'aria-live',
				'aria-owns',
				'aria-relevant',
				'aria-roledescription'
			];
			lookupTable.role = {
				// valid roles below
				alert: {
					type: 'widget',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				alertdialog: {
					type: 'widget',
					attributes: {
						allowed: ['aria-expanded', 'aria-modal', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['dialog', 'section']
				},
				application: {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: [
						'article',
						'audio',
						'embed',
						'iframe',
						'object',
						'section',
						'svg',
						'video'
					]
				},
				article: {
					type: 'structure',
					attributes: {
						allowed: [
							'aria-expanded',
							'aria-posinset',
							'aria-setsize',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['article'],
					unsupported: false
				},
				banner: {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['header'],
					unsupported: false,
					allowedElements: ['section']
				},
				button: {
					type: 'widget',
					attributes: {
						allowed: ['aria-expanded', 'aria-pressed', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: null,
					implicit: [
						'button',
						'input[type="button"]',
						'input[type="image"]',
						'input[type="reset"]',
						'input[type="submit"]',
						'summary'
					],
					unsupported: false,
					allowedElements: [
						{
							nodeName: 'a',
							attributes: {
								href: isNotNull
							}
						}
					]
				},
				cell: {
					type: 'structure',
					attributes: {
						allowed: [
							'aria-colindex',
							'aria-colspan',
							'aria-rowindex',
							'aria-rowspan',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: ['row'],
					implicit: ['td', 'th'],
					unsupported: false
				},
				checkbox: {
					type: 'widget',
					attributes: {
						allowed: [
							'aria-checked',
							'aria-required',
							'aria-readonly',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: null,
					implicit: ['input[type="checkbox"]'],
					unsupported: false,
					allowedElements: ['button']
				},
				columnheader: {
					type: 'structure',
					attributes: {
						allowed: [
							'aria-colindex',
							'aria-colspan',
							'aria-expanded',
							'aria-rowindex',
							'aria-rowspan',
							'aria-required',
							'aria-readonly',
							'aria-selected',
							'aria-sort',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: ['row'],
					implicit: ['th'],
					unsupported: false
				},
				combobox: {
					type: 'composite',
					attributes: {
						allowed: [
							'aria-autocomplete',
							'aria-required',
							'aria-activedescendant',
							'aria-orientation',
							'aria-errormessage'
						],
						required: ['aria-expanded']
					},
					owned: {
						all: ['listbox', 'textbox']
					},
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: [
						{
							nodeName: 'input',
							properties: {
								type: ['text', 'search', 'tel', 'url', 'email']
							}
						}
					]
				},
				command: {
					nameFrom: ['author'],
					type: 'abstract',
					unsupported: false
				},
				complementary: {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['aside'],
					unsupported: false,
					allowedElements: ['section']
				},
				composite: {
					nameFrom: ['author'],
					type: 'abstract',
					unsupported: false
				},
				contentinfo: {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['footer'],
					unsupported: false,
					allowedElements: ['section']
				},
				definition: {
					type: 'structure',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['dd', 'dfn'],
					unsupported: false
				},
				dialog: {
					type: 'widget',
					attributes: {
						allowed: ['aria-expanded', 'aria-modal', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['dialog'],
					unsupported: false,
					allowedElements: ['section']
				},
				directory: {
					type: 'structure',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: null,
					unsupported: false,
					allowedElements: ['ol', 'ul']
				},
				document: {
					type: 'structure',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['body'],
					unsupported: false,
					allowedElements: [
						'article',
						'embed',
						'iframe',
						'object',
						'section',
						'svg'
					]
				},
				'doc-abstract': {
					type: 'section',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-acknowledgments': {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-afterword': {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-appendix': {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-backlink': {
					type: 'link',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: null,
					unsupported: false,
					allowedElements: [
						{
							nodeName: 'a',
							attributes: {
								href: isNotNull
							}
						}
					]
				},
				'doc-biblioentry': {
					type: 'listitem',
					attributes: {
						allowed: [
							'aria-expanded',
							'aria-level',
							'aria-posinset',
							'aria-setsize',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author'],
					context: ['doc-bibliography'],
					unsupported: false,
					allowedElements: ['li']
				},
				'doc-bibliography': {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: {
						one: ['doc-biblioentry']
					},
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-biblioref': {
					type: 'link',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: null,
					unsupported: false,
					allowedElements: [
						{
							nodeName: 'a',
							attributes: {
								href: isNotNull
							}
						}
					]
				},
				'doc-chapter': {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-colophon': {
					type: 'section',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-conclusion': {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-cover': {
					type: 'img',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false
				},
				'doc-credit': {
					type: 'section',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-credits': {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-dedication': {
					type: 'section',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-endnote': {
					type: 'listitem',
					attributes: {
						allowed: [
							'aria-expanded',
							'aria-level',
							'aria-posinset',
							'aria-setsize',
							'aria-errormessage'
						]
					},
					owned: null,
					namefrom: ['author'],
					context: ['doc-endnotes'],
					unsupported: false,
					allowedElements: ['li']
				},
				'doc-endnotes': {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: {
						one: ['doc-endnote']
					},
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-epigraph': {
					type: 'section',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false
				},
				'doc-epilogue': {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-errata': {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-example': {
					type: 'section',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['aside', 'section']
				},
				'doc-footnote': {
					type: 'section',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['aside', 'footer', 'header']
				},
				'doc-foreword': {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-glossary': {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: ['term', 'definition'],
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['dl']
				},
				'doc-glossref': {
					type: 'link',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					namefrom: ['author', 'contents'],
					context: null,
					unsupported: false,
					allowedElements: [
						{
							nodeName: 'a',
							attributes: {
								href: isNotNull
							}
						}
					]
				},
				'doc-index': {
					type: 'navigation',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['nav', 'section']
				},
				'doc-introduction': {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-noteref': {
					type: 'link',
					attributes: {
						allowed: ['aria-expanded']
					},
					owned: null,
					namefrom: ['author', 'contents'],
					context: null,
					unsupported: false,
					allowedElements: [
						{
							nodeName: 'a',
							attributes: {
								href: isNotNull
							}
						}
					]
				},
				'doc-notice': {
					type: 'note',
					attributes: {
						allowed: ['aria-expanded']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-pagebreak': {
					type: 'separator',
					attributes: {
						allowed: ['aria-expanded']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['hr']
				},
				'doc-pagelist': {
					type: 'navigation',
					attributes: {
						allowed: ['aria-expanded']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['nav', 'section']
				},
				'doc-part': {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-preface': {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-prologue': {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-pullquote': {
					type: 'none',
					attributes: {
						allowed: ['aria-expanded']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['aside', 'section']
				},
				'doc-qna': {
					type: 'section',
					attributes: {
						allowed: ['aria-expanded']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				'doc-subtitle': {
					type: 'sectionhead',
					attributes: {
						allowed: ['aria-expanded']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: {
						nodeName: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']
					}
				},
				'doc-tip': {
					type: 'note',
					attributes: {
						allowed: ['aria-expanded']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['aside']
				},
				'doc-toc': {
					type: 'navigation',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					namefrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['nav', 'section']
				},
				feed: {
					type: 'structure',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: {
						one: ['article']
					},
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['article', 'aside', 'section']
				},
				figure: {
					type: 'structure',
					unsupported: false
				},
				form: {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['form'],
					unsupported: false
				},
				grid: {
					type: 'composite',
					attributes: {
						allowed: [
							'aria-activedescendant',
							'aria-expanded',
							'aria-colcount',
							'aria-level',
							'aria-multiselectable',
							'aria-readonly',
							'aria-rowcount',
							'aria-errormessage'
						]
					},
					owned: {
						one: ['rowgroup', 'row']
					},
					nameFrom: ['author'],
					context: null,
					implicit: ['table'],
					unsupported: false
				},
				gridcell: {
					type: 'widget',
					attributes: {
						allowed: [
							'aria-colindex',
							'aria-colspan',
							'aria-expanded',
							'aria-rowindex',
							'aria-rowspan',
							'aria-selected',
							'aria-readonly',
							'aria-required',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: ['row'],
					implicit: ['td', 'th'],
					unsupported: false
				},
				group: {
					type: 'structure',
					attributes: {
						allowed: [
							'aria-activedescendant',
							'aria-expanded',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['details', 'optgroup'],
					unsupported: false,
					allowedElements: [
						'dl',
						'figcaption',
						'fieldset',
						'figure',
						'footer',
						'header',
						'ol',
						'ul'
					]
				},
				heading: {
					type: 'structure',
					attributes: {
						required: ['aria-level'],
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: null,
					implicit: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
					unsupported: false
				},
				img: {
					type: 'structure',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['img'],
					unsupported: false,
					allowedElements: ['embed', 'iframe', 'object', 'svg']
				},
				input: {
					nameFrom: ['author'],
					type: 'abstract',
					unsupported: false
				},
				landmark: {
					nameFrom: ['author'],
					type: 'abstract',
					unsupported: false
				},
				link: {
					type: 'widget',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: null,
					implicit: ['a[href]'],
					unsupported: false,
					allowedElements: [
						'button',
						{
							nodeName: 'input',
							properties: {
								type: ['image', 'button']
							}
						}
					]
				},
				list: {
					type: 'structure',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: {
						all: ['listitem']
					},
					nameFrom: ['author'],
					context: null,
					implicit: ['ol', 'ul', 'dl'],
					unsupported: false
				},
				listbox: {
					type: 'composite',
					attributes: {
						allowed: [
							'aria-activedescendant',
							'aria-multiselectable',
							'aria-readonly',
							'aria-required',
							'aria-expanded',
							'aria-orientation',
							'aria-errormessage'
						]
					},
					owned: {
						all: ['option']
					},
					nameFrom: ['author'],
					context: null,
					implicit: ['select'],
					unsupported: false,
					allowedElements: ['ol', 'ul']
				},
				listitem: {
					type: 'structure',
					attributes: {
						allowed: [
							'aria-level',
							'aria-posinset',
							'aria-setsize',
							'aria-expanded',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: ['list'],
					implicit: ['li', 'dt'],
					unsupported: false
				},
				log: {
					type: 'widget',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				main: {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['main'],
					unsupported: false,
					allowedElements: ['article', 'section']
				},
				marquee: {
					type: 'widget',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				math: {
					type: 'structure',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['math'],
					unsupported: false
				},
				menu: {
					type: 'composite',
					attributes: {
						allowed: [
							'aria-activedescendant',
							'aria-expanded',
							'aria-orientation',
							'aria-errormessage'
						]
					},
					owned: {
						one: ['menuitem', 'menuitemradio', 'menuitemcheckbox']
					},
					nameFrom: ['author'],
					context: null,
					implicit: ['menu[type="context"]'],
					unsupported: false,
					allowedElements: ['ol', 'ul']
				},
				menubar: {
					type: 'composite',
					attributes: {
						allowed: [
							'aria-activedescendant',
							'aria-expanded',
							'aria-orientation',
							'aria-errormessage'
						]
					},
					owned: {
						one: ['menuitem', 'menuitemradio', 'menuitemcheckbox']
					},
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['ol', 'ul']
				},
				menuitem: {
					type: 'widget',
					attributes: {
						allowed: [
							'aria-posinset',
							'aria-setsize',
							'aria-expanded',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: ['menu', 'menubar'],
					implicit: ['menuitem[type="command"]'],
					unsupported: false,
					allowedElements: [
						'button',
						'li',
						{
							nodeName: 'iput',
							properties: {
								type: ['image', 'button']
							}
						},
						{
							nodeName: 'a',
							attributes: {
								href: isNotNull
							}
						}
					]
				},
				menuitemcheckbox: {
					type: 'widget',
					attributes: {
						allowed: [
							'aria-checked',
							'aria-posinset',
							'aria-setsize',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: ['menu', 'menubar'],
					implicit: ['menuitem[type="checkbox"]'],
					unsupported: false,
					allowedElements: [
						{
							nodeName: ['button', 'li']
						},
						{
							nodeName: 'input',
							properties: {
								type: ['checkbox', 'image', 'button']
							}
						},
						{
							nodeName: 'a',
							attributes: {
								href: isNotNull
							}
						}
					]
				},
				menuitemradio: {
					type: 'widget',
					attributes: {
						allowed: [
							'aria-checked',
							'aria-selected',
							'aria-posinset',
							'aria-setsize',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: ['menu', 'menubar'],
					implicit: ['menuitem[type="radio"]'],
					unsupported: false,
					allowedElements: [
						{
							nodeName: ['button', 'li']
						},
						{
							nodeName: 'input',
							properties: {
								type: ['image', 'button', 'radio']
							}
						},
						{
							nodeName: 'a',
							attributes: {
								href: isNotNull
							}
						}
					]
				},
				navigation: {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['nav'],
					unsupported: false,
					allowedElements: ['section']
				},
				none: {
					type: 'structure',
					attributes: null,
					owned: null,
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: [
						{
							nodeName: [
								'article',
								'aside',
								'dl',
								'embed',
								'figcaption',
								'fieldset',
								'figure',
								'footer',
								'form',
								'h1',
								'h2',
								'h3',
								'h4',
								'h5',
								'h6',
								'header',
								'iframe',
								'li',
								'ol',
								'section',
								'ul'
							]
						},
						{
							nodeName: 'img',
							attributes: {
								alt: isNotNull
							}
						}
					]
				},
				note: {
					type: 'structure',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['aside']
				},
				option: {
					type: 'widget',
					attributes: {
						allowed: [
							'aria-selected',
							'aria-posinset',
							'aria-setsize',
							'aria-checked',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: ['listbox'],
					implicit: ['option'],
					unsupported: false,
					allowedElements: [
						{
							nodeName: ['button', 'li']
						},
						{
							nodeName: 'input',
							properties: {
								type: ['checkbox', 'button']
							}
						},
						{
							nodeName: 'a',
							attributes: {
								href: isNotNull
							}
						}
					]
				},
				presentation: {
					type: 'structure',
					attributes: null,
					owned: null,
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: [
						{
							nodeName: [
								'article',
								'aside',
								'dl',
								'embed',
								'figcaption',
								'fieldset',
								'figure',
								'footer',
								'form',
								'h1',
								'h2',
								'h3',
								'h4',
								'h5',
								'h6',
								'header',
								'iframe',
								'li',
								'ol',
								'section',
								'ul'
							]
						},
						{
							nodeName: 'img',
							attributes: {
								alt: isNotNull
							}
						}
					]
				},
				progressbar: {
					type: 'widget',
					attributes: {
						allowed: [
							'aria-valuetext',
							'aria-valuenow',
							'aria-valuemax',
							'aria-valuemin',
							'aria-expanded',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['progress'],
					unsupported: false
				},
				radio: {
					type: 'widget',
					attributes: {
						allowed: [
							'aria-selected',
							'aria-posinset',
							'aria-setsize',
							'aria-required',
							'aria-errormessage',
							'aria-checked'
						]
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: null,
					implicit: ['input[type="radio"]'],
					unsupported: false,
					allowedElements: [
						{
							nodeName: ['button', 'li']
						},
						{
							nodeName: 'input',
							properties: {
								type: ['image', 'button']
							}
						}
					]
				},
				radiogroup: {
					type: 'composite',
					attributes: {
						allowed: [
							'aria-activedescendant',
							'aria-required',
							'aria-expanded',
							'aria-readonly',
							'aria-errormessage'
						]
					},
					owned: {
						all: ['radio']
					},
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: {
						nodeName: ['ol', 'ul']
					}
				},
				range: {
					nameFrom: ['author'],
					type: 'abstract',
					// @marcysutton, @wilco
					// - there is no unsupported here (noticed when resolving conflicts) from PR - https://github.com/dequelabs/axe-core/pull/1064
					// - https://github.com/dequelabs/axe-core/pull/1064/files#diff-ec67bb6113bfd9a900ee27ecef942f74R1229
					// - adding unsupported flag (false)
					unsupported: false
				},
				region: {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: [
						'section[aria-label]',
						'section[aria-labelledby]',
						'section[title]'
					],
					unsupported: false,
					allowedElements: {
						nodeName: ['article', 'aside']
					}
				},
				roletype: {
					type: 'abstract',
					unsupported: false
				},
				row: {
					type: 'structure',
					attributes: {
						allowed: [
							'aria-activedescendant',
							'aria-colindex',
							'aria-expanded',
							'aria-level',
							'aria-selected',
							'aria-rowindex',
							'aria-errormessage'
						]
					},
					owned: {
						one: ['cell', 'columnheader', 'rowheader', 'gridcell']
					},
					nameFrom: ['author', 'contents'],
					context: ['rowgroup', 'grid', 'treegrid', 'table'],
					implicit: ['tr'],
					unsupported: false
				},
				rowgroup: {
					type: 'structure',
					attributes: {
						allowed: [
							'aria-activedescendant',
							'aria-expanded',
							'aria-errormessage'
						]
					},
					owned: {
						all: ['row']
					},
					nameFrom: ['author', 'contents'],
					context: ['grid', 'table', 'treegrid'],
					implicit: ['tbody', 'thead', 'tfoot'],
					unsupported: false
				},
				rowheader: {
					type: 'structure',
					attributes: {
						allowed: [
							'aria-colindex',
							'aria-colspan',
							'aria-expanded',
							'aria-rowindex',
							'aria-rowspan',
							'aria-required',
							'aria-readonly',
							'aria-selected',
							'aria-sort',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: ['row'],
					implicit: ['th'],
					unsupported: false
				},
				scrollbar: {
					type: 'widget',
					attributes: {
						required: ['aria-controls', 'aria-valuenow'],
						allowed: [
							'aria-valuetext',
							'aria-orientation',
							'aria-errormessage',
							'aria-valuemax',
							'aria-valuemin'
						]
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					unsupported: false
				},
				search: {
					type: 'landmark',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: {
						nodeName: ['aside', 'form', 'section']
					}
				},
				searchbox: {
					type: 'widget',
					attributes: {
						allowed: [
							'aria-activedescendant',
							'aria-autocomplete',
							'aria-multiline',
							'aria-readonly',
							'aria-required',
							'aria-placeholder',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['input[type="search"]'],
					unsupported: false,
					allowedElements: {
						nodeName: 'input',
						properties: {
							type: 'text'
						}
					}
				},
				section: {
					nameFrom: ['author', 'contents'],
					type: 'abstract',
					unsupported: false
				},
				sectionhead: {
					nameFrom: ['author', 'contents'],
					type: 'abstract',
					unsupported: false
				},
				select: {
					nameFrom: ['author'],
					type: 'abstract',
					unsupported: false
				},
				separator: {
					type: 'structure',
					attributes: {
						allowed: [
							'aria-expanded',
							'aria-orientation',
							'aria-valuenow',
							'aria-valuemax',
							'aria-valuemin',
							'aria-valuetext',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['hr'],
					unsupported: false,
					allowedElements: ['li']
				},
				slider: {
					type: 'widget',
					attributes: {
						allowed: [
							'aria-valuetext',
							'aria-orientation',
							'aria-readonly',
							'aria-errormessage',
							'aria-valuemax',
							'aria-valuemin'
						],
						required: ['aria-valuenow']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['input[type="range"]'],
					unsupported: false
				},
				spinbutton: {
					type: 'widget',
					attributes: {
						allowed: [
							'aria-valuetext',
							'aria-required',
							'aria-readonly',
							'aria-errormessage',
							'aria-valuemax',
							'aria-valuemin'
						],
						required: ['aria-valuenow']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['input[type="number"]'],
					unsupported: false,
					allowedElements: {
						nodeName: 'input',
						properties: {
							type: 'text'
						}
					}
				},
				status: {
					type: 'widget',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['output'],
					unsupported: false,
					allowedElements: ['section']
				},
				structure: {
					type: 'abstract',
					unsupported: false
				},
				switch: {
					type: 'widget',
					attributes: {
						allowed: ['aria-errormessage'],
						required: ['aria-checked']
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: null,
					unsupported: false,
					allowedElements: [
						'button',
						{
							nodeName: 'input',
							properties: {
								type: ['checkbox', 'image', 'button']
							}
						},
						{
							nodeName: 'a',
							attributes: {
								href: isNotNull
							}
						}
					]
				},
				tab: {
					type: 'widget',
					attributes: {
						allowed: [
							'aria-selected',
							'aria-expanded',
							'aria-setsize',
							'aria-posinset',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: ['tablist'],
					unsupported: false,
					allowedElements: [
						{
							nodeName: ['button', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li']
						},
						{
							nodeName: 'input',
							properties: {
								type: 'button'
							}
						},
						{
							nodeName: 'a',
							attributes: {
								href: isNotNull
							}
						}
					]
				},
				table: {
					type: 'structure',
					attributes: {
						allowed: ['aria-colcount', 'aria-rowcount', 'aria-errormessage']
					},
					owned: {
						one: ['rowgroup', 'row']
					},
					nameFrom: ['author'],
					context: null,
					implicit: ['table'],
					unsupported: false
				},
				tablist: {
					type: 'composite',
					attributes: {
						allowed: [
							'aria-activedescendant',
							'aria-expanded',
							'aria-level',
							'aria-multiselectable',
							'aria-orientation',
							'aria-errormessage'
						]
					},
					owned: {
						all: ['tab']
					},
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['ol', 'ul']
				},
				tabpanel: {
					type: 'widget',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['section']
				},
				term: {
					type: 'structure',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: null,
					implicit: ['dt'],
					unsupported: false
				},
				textbox: {
					type: 'widget',
					attributes: {
						allowed: [
							'aria-activedescendant',
							'aria-autocomplete',
							'aria-multiline',
							'aria-readonly',
							'aria-required',
							'aria-placeholder',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: [
						'input[type="text"]',
						'input[type="email"]',
						'input[type="password"]',
						'input[type="tel"]',
						'input[type="url"]',
						'input:not([type])',
						'textarea'
					],
					unsupported: false
				},
				timer: {
					type: 'widget',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					unsupported: false
				},
				toolbar: {
					type: 'structure',
					attributes: {
						allowed: [
							'aria-activedescendant',
							'aria-expanded',
							'aria-orientation',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author'],
					context: null,
					implicit: ['menu[type="toolbar"]'],
					unsupported: false,
					allowedElements: ['ol', 'ul']
				},
				tooltip: {
					type: 'widget',
					attributes: {
						allowed: ['aria-expanded', 'aria-errormessage']
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: null,
					unsupported: false
				},
				tree: {
					type: 'composite',
					attributes: {
						allowed: [
							'aria-activedescendant',
							'aria-multiselectable',
							'aria-required',
							'aria-expanded',
							'aria-orientation',
							'aria-errormessage'
						]
					},
					owned: {
						all: ['treeitem']
					},
					nameFrom: ['author'],
					context: null,
					unsupported: false,
					allowedElements: ['ol', 'ul']
				},
				treegrid: {
					type: 'composite',
					attributes: {
						allowed: [
							'aria-activedescendant',
							'aria-colcount',
							'aria-expanded',
							'aria-level',
							'aria-multiselectable',
							'aria-readonly',
							'aria-required',
							'aria-rowcount',
							'aria-orientation',
							'aria-errormessage'
						]
					},
					owned: {
						one: ['rowgroup', 'row']
					},
					nameFrom: ['author'],
					context: null,
					unsupported: false
				},
				treeitem: {
					type: 'widget',
					attributes: {
						allowed: [
							'aria-checked',
							'aria-selected',
							'aria-expanded',
							'aria-level',
							'aria-posinset',
							'aria-setsize',
							'aria-errormessage'
						]
					},
					owned: null,
					nameFrom: ['author', 'contents'],
					context: ['group', 'tree'],
					unsupported: false,
					allowedElements: [
						'li',
						{
							nodeName: 'a',
							attributes: {
								href: isNotNull
							}
						}
					]
				},
				widget: {
					type: 'abstract',
					unsupported: false
				},
				window: {
					nameFrom: ['author'],
					type: 'abstract',
					unsupported: false
				}
			}; // Source: https://www.w3.org/TR/html-aria/

			lookupTable.elementsAllowedNoRole = [
				{
					// Plain HTML nodes
					nodeName: [
						'base',
						'body',
						'caption',
						'col',
						'colgroup',
						'datalist',
						'dd',
						'details',
						'dt',
						'head',
						'html',
						'keygen',
						'label',
						'legend',
						'main',
						'map',
						'math',
						'meta',
						'meter',
						'noscript',
						'optgroup',
						'param',
						'picture',
						'progress',
						'script',
						'source',
						'style',
						'template',
						'textarea',
						'title',
						'track'
					]
				},
				{
					nodeName: 'area',
					attributes: {
						href: isNotNull
					}
				},
				{
					nodeName: 'input',
					properties: {
						type: [
							'color',
							'data',
							'datatime',
							'file',
							'hidden',
							'month',
							'number',
							'password',
							'range',
							'reset',
							'submit',
							'time',
							'week'
						]
					}
				},
				{
					nodeName: 'link',
					attributes: {
						href: isNotNull
					}
				},
				{
					nodeName: 'menu',
					attributes: {
						type: 'context'
					}
				},
				{
					nodeName: 'menuitem',
					attributes: {
						type: ['command', 'checkbox', 'radio']
					}
				},
				{
					nodeName: 'select',
					condition: function condition(node) {
						return Number(node.getAttribute('size')) > 1;
					},
					properties: {
						multiple: true
					}
				}, // svg elements (below)
				{
					nodeName: [
						'clippath',
						'cursor',
						'defs',
						'desc',
						'feblend',
						'fecolormatrix',
						'fecomponenttransfer',
						'fecomposite',
						'feconvolvematrix',
						'fediffuselighting',
						'fedisplacementmap',
						'fedistantlight',
						'fedropshadow',
						'feflood',
						'fefunca',
						'fefuncb',
						'fefuncg',
						'fefuncr',
						'fegaussianblur',
						'feimage',
						'femerge',
						'femergenode',
						'femorphology',
						'feoffset',
						'fepointlight',
						'fespecularlighting',
						'fespotlight',
						'fetile',
						'feturbulence',
						'filter',
						'hatch',
						'hatchpath',
						'lineargradient',
						'marker',
						'mask',
						'meshgradient',
						'meshpatch',
						'meshrow',
						'metadata',
						'mpath',
						'pattern',
						'radialgradient',
						'solidcolor',
						'stop',
						'switch',
						'view'
					]
				}
			]; // Source: https://www.w3.org/TR/html-aria/

			lookupTable.elementsAllowedAnyRole = [
				{
					nodeName: 'a',
					attributes: {
						href: isNull
					}
				},
				{
					nodeName: 'img',
					attributes: {
						alt: isNull
					}
				},
				{
					nodeName: [
						'abbr',
						'address',
						'canvas',
						'div',
						'p',
						'pre',
						'blockquote',
						'ins',
						'del',
						'output',
						'span',
						'table',
						'tbody',
						'thead',
						'tfoot',
						'td',
						'em',
						'strong',
						'small',
						's',
						'cite',
						'q',
						'dfn',
						'abbr',
						'time',
						'code',
						'var',
						'samp',
						'kbd',
						'sub',
						'sup',
						'i',
						'b',
						'u',
						'mark',
						'ruby',
						'rt',
						'rp',
						'bdi',
						'bdo',
						'br',
						'wbr',
						'th',
						'tr'
					]
				}
			];
			lookupTable.evaluateRoleForElement = {
				A: function A(_ref25) {
					var node = _ref25.node,
						out = _ref25.out;

					if (node.namespaceURI === 'http://www.w3.org/2000/svg') {
						return true;
					}

					if (node.href.length) {
						return out;
					}

					return true;
				},
				AREA: function AREA(_ref26) {
					var node = _ref26.node;
					return !node.href;
				},
				BUTTON: function BUTTON(_ref27) {
					var node = _ref27.node,
						role = _ref27.role,
						out = _ref27.out;

					if (node.getAttribute('type') === 'menu') {
						return role === 'menuitem';
					}

					return out;
				},
				IMG: function IMG(_ref28) {
					var node = _ref28.node,
						role = _ref28.role,
						out = _ref28.out;

					switch (node.alt) {
						case null:
							return out;

						case '':
							return role === 'presentation' || role === 'none';

						default:
							return role !== 'presentation' && role !== 'none';
					}
				},
				INPUT: function INPUT(_ref29) {
					var node = _ref29.node,
						role = _ref29.role,
						out = _ref29.out;

					switch (node.type) {
						case 'button':
						case 'image':
							return out;

						case 'checkbox':
							if (role === 'button' && node.hasAttribute('aria-pressed')) {
								return true;
							}

							return out;

						case 'radio':
							return role === 'menuitemradio';

						case 'text':
							return (
								role === 'combobox' ||
								role === 'searchbox' ||
								role === 'spinbutton'
							);

						case 'tel':
						case 'url':
						case 'search':
						case 'email':
							return role === 'combobox';

						default:
							return false;
					}
				},
				LI: function LI(_ref30) {
					var node = _ref30.node,
						out = _ref30.out;
					var hasImplicitListitemRole = axe.utils.matchesSelector(
						node,
						'ol li, ul li'
					);

					if (hasImplicitListitemRole) {
						return out;
					}

					return true;
				},
				MENU: function MENU(_ref31) {
					var node = _ref31.node;

					if (node.getAttribute('type') === 'context') {
						return false;
					}

					return true;
				},
				OPTION: function OPTION(_ref32) {
					var node = _ref32.node;
					var withinOptionList = axe.utils.matchesSelector(
						node,
						'select > option, datalist > option, optgroup > option'
					);
					return !withinOptionList;
				},
				SELECT: function SELECT(_ref33) {
					var node = _ref33.node,
						role = _ref33.role;
					return !node.multiple && node.size <= 1 && role === 'menu';
				},
				SVG: function SVG(_ref34) {
					var node = _ref34.node,
						out = _ref34.out;

					// if in svg context it all roles may be used
					if (
						node.parentNode &&
						node.parentNode.namespaceURI === 'http://www.w3.org/2000/svg'
					) {
						return true;
					}

					return out;
				}
			};
			/**
			 * Reference -> https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques#Widget_roles
			 * The current lookupTable.role['widget'] widget, yeilds
			 * ->
			 * [
			 * 	"alert", "alertdialog", "button", "checkbox", "dialog", "gridcell", "link", "log", "marquee", "menuitem", "menuitemcheckbox",
			 * 	"menuitemradio", "option", "progressbar", "radio", "scrollbar", "searchbox", "slider", "spinbutton", "status", "switch", "tab", "tabpanel",
			 * 	"textbox", "timer", "tooltip", "treeitem"
			 * ]
			 * There are some differences against specs, hence the below listing was made
			 */

			lookupTable.rolesOfType = {
				widget: [
					'button',
					'checkbox',
					'dialog',
					'gridcell',
					'link',
					'log',
					'marquee',
					'menuitem',
					'menuitemcheckbox',
					'menuitemradio',
					'option',
					'progressbar',
					'radio',
					'scrollbar',
					'slider',
					'spinbutton',
					'status',
					'switch',
					'tab',
					'tabpanel',
					'textbox',
					'timer',
					'tooltip',
					'tree',
					'treeitem'
				]
			};
			/**
			 * Namespace for color-related utilities.
			 * @namespace commons.color
			 * @memberof axe
			 */

			var color = {};
			commons.color = color;
			/* exported dom */

			/*eslint no-unused-vars: 0*/

			/**
			 * Namespace for dom-related utilities.
			 * @namespace dom
			 * @memberof axe.commons
			 */

			var dom = (commons.dom = {});
			/**
			 * Namespace for forms-related utilities.
			 * @namespace commons.forms
			 * @memberof axe
			 */

			var forms = {};
			commons.forms = forms;
			/* exported matches */

			/**
			 * Check if a DOM element matches a definition
			 *
			 * Example:
			 * ```js
			 * // Match a single nodeName:
			 * axe.commons.matches(elm, 'div')
			 *
			 * // Match one of multiple nodeNames:
			 * axe.commons.matches(elm, ['ul', 'ol'])
			 *
			 * // Match a node with nodeName 'button' and with aria-hidden: true:
			 * axe.commons.matches(elm, {
			 * 	 nodeName: 'button',
			 * 	 attributes: { 'aria-hidden': 'true' }
			 * })
			 *
			 * // Mixed input. Match button nodeName, input[type=button] and input[type=reset]
			 * axe.commons.matches(elm, ['button', {
			 * 	nodeName: 'input', // nodeName match isn't case sensitive
			 * 	properties: { type: ['button', 'reset'] }
			 * }])
			 * ```
			 *
			 * @namespace matches
			 * @memberof axe.commons
			 * @param {HTMLElement|VirtualNode} node node to verify attributes against constraints
			 * @param {Array<ElementDefinition>|String|Object|Function|Regex} definition
			 * @return {Boolean} true/ false based on if node passes the constraints expected
			 */

			function matches(node, definition) {
				return matches.fromDefinition(node, definition);
			}

			commons.matches = matches;
			/* exported table */

			/*eslint no-unused-vars: 0*/

			/**
			 * Namespace for table-related utilities.
			 * @namespace table
			 * @memberof axe.commons
			 */

			var table = (commons.table = {});
			/* exported text */

			/*eslint no-unused-vars: 0*/

			/**
			 * Namespace for text-related utilities.
			 * @namespace text
			 * @memberof axe.commons
			 */

			var text = (commons.text = {
				EdgeFormDefaults: {}
			});
			/* exported utils */

			/* global axe */

			/*eslint no-unused-vars: 0*/

			/**
			 * Namespace for general utilities.
			 * @namespace utils
			 * @memberof axe.commons
			 */

			var utils = (commons.utils = axe.utils);
			/* global aria */

			/**
			 * Get the text value of aria-label, if any
			 *
			 * @deprecated Do not use Element directly. Pass VirtualNode instead
			 * @param {VirtualNode|Element} element
			 * @return {string} ARIA label
			 */

			aria.arialabelText = function arialabelText(node) {
				if (node instanceof axe.AbstractVirtualNode === false) {
					if (node.nodeType !== 1) {
						return '';
					}

					node = axe.utils.getNodeFromTree(node);
				}

				return node.attr('aria-label') || '';
			};
			/* global aria, dom, text */

			/**
			 * Get the accessible name based on aria-labelledby
			 *
			 * @param {VirtualNode} element
			 * @param {Object} context
			 * @property {Bool} inLabelledByContext Whether or not the lookup is part of aria-labelledby reference
			 * @property {Bool} inControlContext Whether or not the lookup is part of a native label reference
			 * @property {Element} startNode First node in accessible name computation
			 * @property {Bool} debug Enable logging for formControlValue
			 * @return {string} Cancatinated text value for referenced elements
			 */

			aria.arialabelledbyText = function arialabelledbyText(node) {
				var context =
					arguments.length > 1 && arguments[1] !== undefined
						? arguments[1]
						: {};
				node = node.actualNode || node;
				/**
				 * Note: The there are significant difference in how many "leads" browsers follow.
				 * - Firefox stops after the first IDREF, so it
				 * 		doesn't follow aria-labelledby after a for:>ID ref.
				 * - Chrome seems to just keep iterating no matter how many levels deep.
				 * - AccName-AAM 1.1 suggests going one level deep, but to treat
				 * 		each ref type separately.
				 *
				 * Axe-core's implementation behaves most closely like Firefox as it seems
				 *  to be the common denominator. Main difference is that Firefox
				 *  includes the value of form controls in addition to aria-label(s),
				 *  something no other browser seems to do. Axe doesn't do that.
				 */

				if (
					node.nodeType !== 1 ||
					context.inLabelledByContext ||
					context.inControlContext
				) {
					return '';
				}

				var refs = dom.idrefs(node, 'aria-labelledby').filter(function(elm) {
					return elm;
				});
				return refs.reduce(function(accessibleName, elm) {
					var accessibleNameAdd = text.accessibleText(
						elm,
						_extends(
							{
								// Prevent the infinite reference loop:
								inLabelledByContext: true,
								startNode: context.startNode || node
							},
							context
						)
					);

					if (!accessibleName) {
						return accessibleNameAdd;
					} else {
						return ''.concat(accessibleName, ' ').concat(accessibleNameAdd);
					}
				}, '');
			};
			/* global aria */

			/**
			 * Get required attributes for a given role
			 * @method requiredAttr
			 * @memberof axe.commons.aria
			 * @instance
			 * @param  {String} role The role to check
			 * @return {Array}
			 */

			aria.requiredAttr = function(role) {
				var roles = aria.lookupTable.role[role],
					attr = roles && roles.attributes && roles.attributes.required;
				return attr || [];
			};
			/**
			 * Get allowed attributes for a given role
			 * @method allowedAttr
			 * @memberof axe.commons.aria
			 * @instance
			 * @param  {String} role The role to check
			 * @return {Array}
			 */

			aria.allowedAttr = function(role) {
				var roles = aria.lookupTable.role[role],
					attr = (roles && roles.attributes && roles.attributes.allowed) || [],
					requiredAttr =
						(roles && roles.attributes && roles.attributes.required) || [];
				return attr
					.concat(aria.lookupTable.globalAttributes)
					.concat(requiredAttr);
			};
			/**
			 * Check if an aria- attribute name is valid
			 * @method validateAttr
			 * @memberof axe.commons.aria
			 * @instance
			 * @param  {String} att The attribute name
			 * @return {Boolean}
			 */

			aria.validateAttr = function validateAttr(att) {
				var attrDefinition = aria.lookupTable.attributes[att];
				return !!attrDefinition;
			};
			/* global aria */
			// dpub roles which are subclassing roles that are implicit on some native
			// HTML elements (img, link, etc.)

			var dpubRoles = [
				'doc-backlink',
				'doc-biblioentry',
				'doc-biblioref',
				'doc-cover',
				'doc-endnote',
				'doc-glossref',
				'doc-noteref'
			];
			/**
			 * Returns all roles applicable to element in a list
			 *
			 * @method getRoleSegments
			 * @private
			 * @param {Element} node
			 * @returns {Array} Roles list or empty list
			 */

			function getRoleSegments(node) {
				var roles = [];

				if (!node) {
					return roles;
				}

				if (node.hasAttribute('role')) {
					var nodeRoles = axe.utils.tokenList(
						node.getAttribute('role').toLowerCase()
					);
					roles = roles.concat(nodeRoles);
				}

				if (node.hasAttributeNS('http://www.idpf.org/2007/ops', 'type')) {
					var epubRoles = axe.utils
						.tokenList(
							node
								.getAttributeNS('http://www.idpf.org/2007/ops', 'type')
								.toLowerCase()
						)
						.map(function(role) {
							return 'doc-'.concat(role);
						});
					roles = roles.concat(epubRoles);
				} // filter invalid roles

				roles = roles.filter(function(role) {
					return axe.commons.aria.isValidRole(role);
				});
				return roles;
			}
			/**
			 * gets all unallowed roles for a given node
			 * @method getElementUnallowedRoles
			 * @param {Object} node HTMLElement to validate
			 * @param {String} tagName tag name of a node
			 * @param {String} allowImplicit option to allow implicit roles, defaults to true
			 * @return {Array<String>} retruns an array of roles that are not allowed on the given node
			 */

			aria.getElementUnallowedRoles = function getElementUnallowedRoles(node) {
				var allowImplicit =
					arguments.length > 1 && arguments[1] !== undefined
						? arguments[1]
						: true;
				var tagName = node.nodeName.toUpperCase(); // by pass custom elements

				if (!axe.utils.isHtmlElement(node)) {
					return [];
				}

				var roleSegments = getRoleSegments(node);
				var implicitRole = axe.commons.aria.implicitRole(node); // stores all roles that are not allowed for a specific element most often an element only has one explicit role

				var unallowedRoles = roleSegments.filter(function(role) {
					// if role and implicit role are same, when allowImplicit: true
					// ignore as it is a redundant role
					if (allowImplicit && role === implicitRole) {
						return false;
					} // if role is a dpub role make sure it's used on an element with a valid
					// implicit role fallback

					if (allowImplicit && dpubRoles.includes(role)) {
						var roleType = axe.commons.aria.getRoleType(role);

						if (implicitRole !== roleType) {
							return true;
						}
					} // Edge case:
					// setting implicit role row on tr element is allowed when child of table[role='grid']

					if (
						!allowImplicit &&
						!(
							role === 'row' &&
							tagName === 'TR' &&
							axe.utils.matchesSelector(node, 'table[role="grid"] > tr')
						)
					) {
						return true;
					} // check if role is allowed on element

					return !aria.isAriaRoleAllowedOnElement(node, role);
				});
				return unallowedRoles;
			};
			/* global aria, dom */

			/**
			 * Get an element's owned elements
			 *
			 * @param {VirtualNode} element
			 * @return {VirtualNode[]} Owned elements
			 */

			aria.getOwnedVirtual = function getOwned(_ref35) {
				var actualNode = _ref35.actualNode,
					children = _ref35.children;

				if (!actualNode || !children) {
					throw new Error('getOwnedVirtual requires a virtual node');
				} // TODO: Check that the element has a role
				// TODO: Descend into children with role=presentation|none
				// TODO: Exclude descendents owned by other elements

				return dom
					.idrefs(actualNode, 'aria-owns')
					.reduce(function(ownedElms, element) {
						if (element) {
							var virtualNode = axe.utils.getNodeFromTree(element);
							ownedElms.push(virtualNode);
						}

						return ownedElms;
					}, children);
			};
			/* global aria, axe */

			/**
			 * Return the accessible role of an element
			 *
			 * @method getRole
			 * @memberof axe.commons.aria
			 * @instance
			 * @param {Element} node
			 * @param {Object} options
			 * @param {boolean} options.noImplicit  Do not return the implicit role
			 * @param {boolean} options.fallback  Allow fallback roles
			 * @param {boolean} options.abstracts  Allow role to be abstract
			 * @param {boolean} options.dpub  Allow role to be any (valid) doc-* roles
			 * @returns {string|null} Role or null
			 */

			aria.getRole = function getRole(node) {
				var _ref36 =
						arguments.length > 1 && arguments[1] !== undefined
							? arguments[1]
							: {},
					noImplicit = _ref36.noImplicit,
					fallback = _ref36.fallback,
					abstracts = _ref36.abstracts,
					dpub = _ref36.dpub;

				node = node.actualNode || node;

				if (node.nodeType !== 1) {
					return null;
				}

				var roleAttr = (node.getAttribute('role') || '').trim().toLowerCase();
				var roleList = fallback ? axe.utils.tokenList(roleAttr) : [roleAttr]; // Get the first valid role:

				var validRoles = roleList.filter(function(role) {
					if (!dpub && role.substr(0, 4) === 'doc-') {
						return false;
					}

					return aria.isValidRole(role, {
						allowAbstract: abstracts
					});
				});
				var explicitRole = validRoles[0]; // Get the implicit role, if permitted

				if (!explicitRole && !noImplicit) {
					return aria.implicitRole(node);
				}

				return explicitRole || null;
			};
			/* global aria, axe, dom */

			var idRefsRegex = /^idrefs?$/;

			function cacheIdRefs(node, refAttrs) {
				if (node.hasAttribute) {
					var idRefs = axe._cache.get('idRefs');

					if (
						node.nodeName.toUpperCase() === 'LABEL' &&
						node.hasAttribute('for')
					) {
						idRefs[node.getAttribute('for')] = true;
					}

					for (var i = 0; i < refAttrs.length; ++i) {
						var attr = refAttrs[i];

						if (!node.hasAttribute(attr)) {
							continue;
						}

						var attrValue = node.getAttribute(attr);
						var tokens = axe.utils.tokenList(attrValue);

						for (var k = 0; k < tokens.length; ++k) {
							idRefs[tokens[k]] = true;
						}
					}
				}

				for (var _i3 = 0; _i3 < node.children.length; _i3++) {
					cacheIdRefs(node.children[_i3], refAttrs);
				}
			}
			/**
			 * Check that a DOM node is a reference in the accessibility tree
			 * @param {Element} node
			 * @returns {Boolean}
			 */

			aria.isAccessibleRef = function isAccessibleRef(node) {
				node = node.actualNode || node;
				var root = dom.getRootNode(node);
				root = root.documentElement || root; // account for shadow roots

				var id = node.id; // because axe.commons is not available in axe.utils, we can't do
				// this caching when we build up the virtual tree

				if (!axe._cache.get('idRefs')) {
					axe._cache.set('idRefs', {}); // Get all idref(s) attributes on the lookup table

					var refAttrs = Object.keys(aria.lookupTable.attributes).filter(
						function(attr) {
							var type = aria.lookupTable.attributes[attr].type;
							return idRefsRegex.test(type);
						}
					);
					cacheIdRefs(root, refAttrs);
				}

				return axe._cache.get('idRefs')[id] === true;
			};
			/* global aria, matches */

			/**
			 * @description validate if a given role is an allowed ARIA role for the supplied node
			 * @method isAriaRoleAllowedOnElement
			 * @param {HTMLElement} node the node to verify
			 * @param {String} role aria role to check
			 * @return {Boolean} retruns true/false
			 */

			aria.isAriaRoleAllowedOnElement = function isAriaRoleAllowedOnElement(
				node,
				role
			) {
				var nodeName = node.nodeName.toUpperCase();
				var lookupTable = axe.commons.aria.lookupTable; // if given node can have no role - return false

				if (matches(node, lookupTable.elementsAllowedNoRole)) {
					return false;
				} // if given node allows any role - return true

				if (matches(node, lookupTable.elementsAllowedAnyRole)) {
					return true;
				} // get role value (if exists) from lookupTable.role

				var roleValue = lookupTable.role[role]; // if given role does not exist in lookupTable - return false

				if (!roleValue || !roleValue.allowedElements) {
					return false;
				} // validate attributes and conditions (if any) from allowedElement to given node

				var out = matches(node, roleValue.allowedElements); // if given node type has complex condition to evaluate a given aria-role, execute the same

				if (
					Object.keys(lookupTable.evaluateRoleForElement).includes(nodeName)
				) {
					return lookupTable.evaluateRoleForElement[nodeName]({
						node: node,
						role: role,
						out: out
					});
				}

				return out;
			};
			/* global aria */

			/**
			 * Check if a given role is unsupported
			 * @method isUnsupportedRole
			 * @memberof axe.commons.aria
			 * @instance
			 * @param {String} role The role to check
			 * @return {Boolean}
			 */

			aria.isUnsupportedRole = function(role) {
				var roleDefinition = aria.lookupTable.role[role];
				return roleDefinition ? roleDefinition.unsupported : false;
			};
			/* global axe, aria, dom, text */

			/**
			 * Gets the accessible ARIA label text of a given element
			 * @see http://www.w3.org/WAI/PF/aria/roles#namecalculation
			 * @method labelVirtual
			 * @memberof axe.commons.aria
			 * @instance
			 * @param  {Object} actualNode The virtualNode to test
			 * @return {Mixed}  String of visible text, or `null` if no label is found
			 */

			aria.labelVirtual = function(_ref37) {
				var actualNode = _ref37.actualNode;
				var ref, candidate;

				if (actualNode.getAttribute('aria-labelledby')) {
					// aria-labelledby
					ref = dom.idrefs(actualNode, 'aria-labelledby');
					candidate = ref
						.map(function(thing) {
							var vNode = axe.utils.getNodeFromTree(thing);
							return vNode ? text.visibleVirtual(vNode, true) : '';
						})
						.join(' ')
						.trim();

					if (candidate) {
						return candidate;
					}
				} // aria-label

				candidate = actualNode.getAttribute('aria-label');

				if (candidate) {
					candidate = text.sanitize(candidate).trim();

					if (candidate) {
						return candidate;
					}
				}

				return null;
			};
			/**
			 * Gets the aria label for a given node
			 * @method label
			 * @memberof axe.commons.aria
			 * @instance
			 * @param  {HTMLElement} node The element to check
			 * @return {Mixed} String of visible text, or `null` if no label is found
			 */

			aria.label = function(node) {
				node = axe.utils.getNodeFromTree(node);
				return aria.labelVirtual(node);
			};
			/* global aria */

			/**
			 * Check if an element is named from contents
			 *
			 * @param {Node|VirtualNode} element
			 * @param {Object} options
			 * @property {Bool} strict Whether or not to follow the spects strictly
			 * @return {Bool}
			 */

			aria.namedFromContents = function namedFromContents(node) {
				var _ref38 =
						arguments.length > 1 && arguments[1] !== undefined
							? arguments[1]
							: {},
					strict = _ref38.strict;

				node = node.actualNode || node;

				if (node.nodeType !== 1) {
					return false;
				}

				var role = aria.getRole(node);
				var roleDef = aria.lookupTable.role[role];

				if (
					(roleDef && roleDef.nameFrom.includes('contents')) || // TODO: This is a workaround for axe-core's over-assertive implicitRole computation
					// once we fix that, this extra noImplicit check can be removed.
					node.nodeName.toUpperCase() === 'TABLE'
				) {
					return true;
				}
				/**
				 * Note: Strictly speaking if the role is null, presentation, or none, the element
				 * isn't named from contents. Axe-core often needs to know if an element
				 * has content anyway, so we're allowing it here.
				 * Use { strict: true } to disable this behavior.
				 */

				if (strict) {
					return false;
				}

				return !roleDef || ['presentation', 'none'].includes(role);
			};
			/* global aria, axe */

			/**
			 * Check if a given role is valid
			 * @method isValidRole
			 * @memberof axe.commons.aria
			 * @instance
			 * @param {String} role The role to check
			 * @param {Object} options Use `allowAbstract` if you want abstracts, and `flagUnsupported: true` to report unsupported roles
			 * @return {Boolean}
			 */

			aria.isValidRole = function(role) {
				var _ref39 =
						arguments.length > 1 && arguments[1] !== undefined
							? arguments[1]
							: {},
					allowAbstract = _ref39.allowAbstract,
					_ref39$flagUnsupporte = _ref39.flagUnsupported,
					flagUnsupported =
						_ref39$flagUnsupporte === void 0 ? false : _ref39$flagUnsupporte;

				var roleDefinition = aria.lookupTable.role[role];
				var isRoleUnsupported = roleDefinition
					? roleDefinition.unsupported
					: false;

				if (!roleDefinition || (flagUnsupported && isRoleUnsupported)) {
					return false;
				}

				return allowAbstract ? true : roleDefinition.type !== 'abstract';
			};
			/**
			 * Get the roles that get name from the element's contents
			 * @method getRolesWithNameFromContents
			 * @memberof axe.commons.aria
			 * @instance
			 * @return {Array} Array of roles that match the type
			 */

			aria.getRolesWithNameFromContents = function() {
				return Object.keys(aria.lookupTable.role).filter(function(r) {
					return (
						aria.lookupTable.role[r].nameFrom &&
						aria.lookupTable.role[r].nameFrom.indexOf('contents') !== -1
					);
				});
			};
			/**
			 * Get the roles that have a certain "type"
			 * @method getRolesByType
			 * @memberof axe.commons.aria
			 * @instance
			 * @param {String} roleType The roletype to check
			 * @return {Array} Array of roles that match the type
			 */

			aria.getRolesByType = function(roleType) {
				return Object.keys(aria.lookupTable.role).filter(function(r) {
					return aria.lookupTable.role[r].type === roleType;
				});
			};
			/**
			 * Get the "type" of role; either widget, composite, abstract, landmark or `null`
			 * @method getRoleType
			 * @memberof axe.commons.aria
			 * @instance
			 * @param {String} role The role to check
			 * @return {Mixed} String if a matching role and its type are found, otherwise `null`
			 */

			aria.getRoleType = function(role) {
				var r = aria.lookupTable.role[role];
				return (r && r.type) || null;
			};
			/**
			 * Get the required owned (children) roles for a given role
			 * @method requiredOwned
			 * @memberof axe.commons.aria
			 * @instance
			 * @param {String} role The role to check
			 * @return {Mixed} Either an Array of required owned elements or `null` if there are none
			 */

			aria.requiredOwned = function(role) {
				'use strict';

				var owned = null,
					roles = aria.lookupTable.role[role];

				if (roles) {
					owned = axe.utils.clone(roles.owned);
				}

				return owned;
			};
			/**
			 * Get the required context (parent) roles for a given role
			 * @method requiredContext
			 * @memberof axe.commons.aria
			 * @instance
			 * @param {String} role The role to check
			 * @return {Mixed} Either an Array of required context elements or `null` if there are none
			 */

			aria.requiredContext = function(role) {
				'use strict';

				var context = null,
					roles = aria.lookupTable.role[role];

				if (roles) {
					context = axe.utils.clone(roles.context);
				}

				return context;
			};
			/**
			 * Get a list of CSS selectors of nodes that have an implicit role
			 * @method implicitNodes
			 * @memberof axe.commons.aria
			 * @instance
			 * @param {String} role The role to check
			 * @return {Mixed} Either an Array of CSS selectors or `null` if there are none
			 */

			aria.implicitNodes = function(role) {
				'use strict';

				var implicit = null,
					roles = aria.lookupTable.role[role];

				if (roles && roles.implicit) {
					implicit = axe.utils.clone(roles.implicit);
				}

				return implicit;
			};
			/**
			 * Get the implicit role for a given node
			 * @method implicitRole
			 * @memberof axe.commons.aria
			 * @instance
			 * @param {HTMLElement} node The node to test
			 * @return {Mixed} Either the role or `null` if there is none
			 */

			aria.implicitRole = function(node) {
				'use strict';
				/*
				 * Filter function to reduce a list of roles to a valid list of roles for a nodetype
				 */

				var isValidImplicitRole = function isValidImplicitRole(set, role) {
					var validForNodeType = function validForNodeType(
						implicitNodeTypeSelector
					) {
						return axe.utils.matchesSelector(node, implicitNodeTypeSelector);
					};

					if (role.implicit && role.implicit.some(validForNodeType)) {
						set.push(role.name);
					}

					return set;
				};
				/*
				 * Score a set of roles and aria-attributes by its optimal score
				 * E.g. [{score: 2, name: button}, {score: 1, name: main}]
				 */

				var sortRolesByOptimalAriaContext = function sortRolesByOptimalAriaContext(
					roles,
					ariaAttributes
				) {
					var getScore = function getScore(role) {
						var allowedAriaAttributes = aria.allowedAttr(role);
						return allowedAriaAttributes.reduce(function(score, attribute) {
							return score + (ariaAttributes.indexOf(attribute) > -1 ? 1 : 0);
						}, 0);
					};

					var scored = roles.map(function(role) {
						return {
							score: getScore(role),
							name: role
						};
					});
					var sorted = scored.sort(function(scoredRoleA, scoredRoleB) {
						return scoredRoleB.score - scoredRoleA.score;
					});
					return sorted.map(function(sortedRole) {
						return sortedRole.name;
					});
				};
				/*
				 * Create a list of { name / implicit } role mappings to filter on
				 */

				var roles = Object.keys(aria.lookupTable.role).map(function(role) {
					var lookup = aria.lookupTable.role[role];
					return {
						name: role,
						implicit: lookup && lookup.implicit
					};
				});
				/* Build a list of valid implicit roles for this node */

				var availableImplicitRoles = roles.reduce(isValidImplicitRole, []);

				if (!availableImplicitRoles.length) {
					return null;
				}

				var nodeAttributes = axe.utils.getNodeAttributes(node);
				var ariaAttributes = [];
				/* Get all aria-attributes defined for this node */

				/* Should be a helper function somewhere */

				for (var i = 0, j = nodeAttributes.length; i < j; i++) {
					var attr = nodeAttributes[i];

					if (attr.name.match(/^aria-/)) {
						ariaAttributes.push(attr.name);
					}
				}
				/* Sort roles by highest score, return the first */

				return sortRolesByOptimalAriaContext(
					availableImplicitRoles,
					ariaAttributes
				).shift();
			};
			/* global aria, dom */

			/**
			 * Validate the value of an ARIA attribute
			 * @method validateAttrValue
			 * @memberof axe.commons.aria
			 * @instance
			 * @param  {HTMLElement} node The element to check
			 * @param  {String} attr The name of the attribute
			 * @return {Boolean}
			 */

			aria.validateAttrValue = function validateAttrValue(node, attr) {
				'use strict';

				var matches,
					list,
					value = node.getAttribute(attr),
					attrInfo = aria.lookupTable.attributes[attr];
				var doc = dom.getRootNode(node);

				if (!attrInfo) {
					return true;
				}

				if (attrInfo.allowEmpty && (!value || value.trim() === '')) {
					return true;
				}

				switch (attrInfo.type) {
					case 'boolean':
					case 'nmtoken':
						return (
							typeof value === 'string' &&
							attrInfo.values.includes(value.toLowerCase())
						);

					case 'nmtokens':
						list = axe.utils.tokenList(value); // Check if any value isn't in the list of values

						return list.reduce(function(result, token) {
							return result && attrInfo.values.includes(token); // Initial state, fail if the list is empty
						}, list.length !== 0);

					case 'idref':
						return !!(value && doc.getElementById(value));

					case 'idrefs':
						list = axe.utils.tokenList(value);
						return list.some(function(token) {
							return doc.getElementById(token);
						});

					case 'string':
						// Not allowed empty except with allowEmpty: true
						return value.trim() !== '';

					case 'decimal':
						matches = value.match(/^[-+]?([0-9]*)\.?([0-9]*)$/);
						return !!(matches && (matches[1] || matches[2]));

					case 'int':
						return /^[-+]?[0-9]+$/.test(value);
				}
			};
			/* global color */

			/**
			 * Get coordinates for an element's client rects or bounding client rect
			 *
			 * @method centerPointOfRect
			 * @memberof axe.commons.color
			 * @param {DOMRect} rect
			 * @returns {Object | undefined}
			 */

			color.centerPointOfRect = function centerPointOfRect(rect) {
				if (rect.left > window.innerWidth) {
					return undefined;
				}

				if (rect.top > window.innerHeight) {
					return undefined;
				}

				var x = Math.min(
					Math.ceil(rect.left + rect.width / 2),
					window.innerWidth - 1
				);
				var y = Math.min(
					Math.ceil(rect.top + rect.height / 2),
					window.innerHeight - 1
				);
				return {
					x: x,
					y: y
				};
			};
			/* global color */

			/**
			 * @class Color
			 * @memberof axe.commons.color
			 * @param {number} red
			 * @param {number} green
			 * @param {number} blue
			 * @param {number} alpha
			 */

			color.Color = function(red, green, blue, alpha) {
				/** @type {number} */
				this.red = red;
				/** @type {number} */

				this.green = green;
				/** @type {number} */

				this.blue = blue;
				/** @type {number} */

				this.alpha = alpha;
				/**
				 * Provide the hex string value for the color
				 * @method toHexString
				 * @memberof axe.commons.color.Color
				 * @instance
				 * @return {string}
				 */

				this.toHexString = function() {
					var redString = Math.round(this.red).toString(16);
					var greenString = Math.round(this.green).toString(16);
					var blueString = Math.round(this.blue).toString(16);
					return (
						'#' +
						(this.red > 15.5 ? redString : '0' + redString) +
						(this.green > 15.5 ? greenString : '0' + greenString) +
						(this.blue > 15.5 ? blueString : '0' + blueString)
					);
				};

				var rgbRegex = /^rgb\((\d+), (\d+), (\d+)\)$/;
				var rgbaRegex = /^rgba\((\d+), (\d+), (\d+), (\d*(\.\d+)?)\)/;
				/**
				 * Set the color value based on a CSS RGB/RGBA string
				 * @method parseRgbString
				 * @memberof axe.commons.color.Color
				 * @instance
				 * @param  {string}  rgb  The string value
				 */

				this.parseRgbString = function(colorString) {
					// IE can pass transparent as value instead of rgba
					if (colorString === 'transparent') {
						this.red = 0;
						this.green = 0;
						this.blue = 0;
						this.alpha = 0;
						return;
					}

					var match = colorString.match(rgbRegex);

					if (match) {
						this.red = parseInt(match[1], 10);
						this.green = parseInt(match[2], 10);
						this.blue = parseInt(match[3], 10);
						this.alpha = 1;
						return;
					}

					match = colorString.match(rgbaRegex);

					if (match) {
						this.red = parseInt(match[1], 10);
						this.green = parseInt(match[2], 10);
						this.blue = parseInt(match[3], 10); // alpha values can be between 0 and 1, with browsers having
						// different floating point precision. for example,
						// 'rgba(0,0,0,0.5)' results in 'rgba(0,0,0,0.498039)' in Safari
						// when getting the computed style background-color property. to
						// fix this, we'll round all alpha values to 2 decimal points.

						this.alpha = Math.round(parseFloat(match[4]) * 100) / 100;
						return;
					}
				};
				/**
				 * Get the relative luminance value
				 * using algorithm from http://www.w3.org/WAI/GL/wiki/Relative_luminance
				 * @method getRelativeLuminance
				 * @memberof axe.commons.color.Color
				 * @instance
				 * @return {number} The luminance value, ranges from 0 to 1
				 */

				this.getRelativeLuminance = function() {
					var rSRGB = this.red / 255;
					var gSRGB = this.green / 255;
					var bSRGB = this.blue / 255;
					var r =
						rSRGB <= 0.03928
							? rSRGB / 12.92
							: Math.pow((rSRGB + 0.055) / 1.055, 2.4);
					var g =
						gSRGB <= 0.03928
							? gSRGB / 12.92
							: Math.pow((gSRGB + 0.055) / 1.055, 2.4);
					var b =
						bSRGB <= 0.03928
							? bSRGB / 12.92
							: Math.pow((bSRGB + 0.055) / 1.055, 2.4);
					return 0.2126 * r + 0.7152 * g + 0.0722 * b;
				};
			};
			/**
			 * Combine the two given color according to alpha blending.
			 * @method flattenColors
			 * @memberof axe.commons.color.Color
			 * @instance
			 * @param {Color} fgColor Foreground color
			 * @param {Color} bgColor Background color
			 * @return {Color} Blended color
			 */

			color.flattenColors = function(fgColor, bgColor) {
				var alpha = fgColor.alpha;
				var r = (1 - alpha) * bgColor.red + alpha * fgColor.red;
				var g = (1 - alpha) * bgColor.green + alpha * fgColor.green;
				var b = (1 - alpha) * bgColor.blue + alpha * fgColor.blue;
				var a = fgColor.alpha + bgColor.alpha * (1 - fgColor.alpha);
				return new color.Color(r, g, b, a);
			};
			/**
			 * Get the contrast of two colors
			 * @method getContrast
			 * @memberof axe.commons.color.Color
			 * @instance
			 * @param  {Color}  bgcolor  Background color
			 * @param  {Color}  fgcolor  Foreground color
			 * @return {number} The contrast ratio
			 */

			color.getContrast = function(bgColor, fgColor) {
				if (!fgColor || !bgColor) {
					return null;
				}

				if (fgColor.alpha < 1) {
					fgColor = color.flattenColors(fgColor, bgColor);
				}

				var bL = bgColor.getRelativeLuminance();
				var fL = fgColor.getRelativeLuminance();
				return (Math.max(fL, bL) + 0.05) / (Math.min(fL, bL) + 0.05);
			};
			/**
			 * Check whether certain text properties meet WCAG contrast rules
			 * @method hasValidContrastRatio
			 * @memberof axe.commons.color.Color
			 * @instance
			 * @param  {Color}  bgcolor  Background color
			 * @param  {Color}  fgcolor  Foreground color
			 * @param  {number}  fontSize  Font size of text, in pixels
			 * @param  {boolean}  isBold  Whether the text is bold
			 * @return {{isValid: boolean, contrastRatio: number, expectedContrastRatio: number}}
			 */

			color.hasValidContrastRatio = function(bg, fg, fontSize, isBold) {
				var contrast = color.getContrast(bg, fg);
				var isSmallFont =
					(isBold && Math.ceil(fontSize * 72) / 96 < 14) ||
					(!isBold && Math.ceil(fontSize * 72) / 96 < 18);
				var expectedContrastRatio = isSmallFont ? 4.5 : 3;
				return {
					isValid: contrast > expectedContrastRatio,
					contrastRatio: contrast,
					expectedContrastRatio: expectedContrastRatio
				};
			};
			/* global color */

			/**
			 * Reports if an element has a background image or gradient
			 *
			 * @method elementHasImage
			 * @memberof axe.commons.color
			 * @private
			 * @param {Element} elm
			 * @param {Object|null} style
			 * @return {Boolean}
			 */

			color.elementHasImage = function elementHasImage(elm, style) {
				var graphicNodes = [
					'IMG',
					'CANVAS',
					'OBJECT',
					'IFRAME',
					'VIDEO',
					'SVG'
				];
				var nodeName = elm.nodeName.toUpperCase();

				if (graphicNodes.includes(nodeName)) {
					axe.commons.color.incompleteData.set('bgColor', 'imgNode');
					return true;
				}

				style = style || window.getComputedStyle(elm);
				var bgImageStyle = style.getPropertyValue('background-image');
				var hasBgImage = bgImageStyle !== 'none';

				if (hasBgImage) {
					var hasGradient = /gradient/.test(bgImageStyle);
					axe.commons.color.incompleteData.set(
						'bgColor',
						hasGradient ? 'bgGradient' : 'bgImage'
					);
				}

				return hasBgImage;
			};
			/* global color */

			/**
			 * Creates a string array of fonts for given CSSStyleDeclaration object
			 * @private
			 * @param {Object} style CSSStyleDeclaration object
			 * @return {Array}
			 */

			function _getFonts(style) {
				return style
					.getPropertyValue('font-family')
					.split(/[,;]/g)
					.map(function(font) {
						return font.trim().toLowerCase();
					});
			}
			/**
			 * Determine if the text content of two nodes is styled in a way that they can be distinguished without relying on color
			 * @method elementIsDistinct
			 * @memberof axe.commons.color
			 * @instance
			 * @param  {HTMLElement} node The element to check
			 * @param  {HTMLElement} ancestorNode The ancestor node element to check
			 * @return {Boolean}
			 */

			function elementIsDistinct(node, ancestorNode) {
				var nodeStyle = window.getComputedStyle(node); // Check if the link has a background

				if (nodeStyle.getPropertyValue('background-image') !== 'none') {
					return true;
				} // Check if the link has a border or outline

				var hasBorder = ['border-bottom', 'border-top', 'outline'].reduce(
					function(result, edge) {
						var borderClr = new color.Color();
						borderClr.parseRgbString(
							nodeStyle.getPropertyValue(edge + '-color')
						); // Check if a border/outline was specified

						return (
							result || // or if the current border edge / outline
							(nodeStyle.getPropertyValue(edge + '-style') !== 'none' &&
								parseFloat(nodeStyle.getPropertyValue(edge + '-width')) > 0 &&
								borderClr.alpha !== 0)
						);
					},
					false
				);

				if (hasBorder) {
					return true;
				}

				var parentStyle = window.getComputedStyle(ancestorNode); // Compare fonts

				if (_getFonts(nodeStyle)[0] !== _getFonts(parentStyle)[0]) {
					return true;
				}

				var hasStyle = [
					'text-decoration-line',
					'text-decoration-style',
					'font-weight',
					'font-style',
					'font-size'
				].reduce(function(result, cssProp) {
					return (
						result ||
						nodeStyle.getPropertyValue(cssProp) !==
							parentStyle.getPropertyValue(cssProp)
					);
				}, false);
				var tDec = nodeStyle.getPropertyValue('text-decoration');

				if (tDec.split(' ').length < 3) {
					// old style CSS text decoration
					hasStyle =
						hasStyle ||
						tDec !== parentStyle.getPropertyValue('text-decoration');
				}

				return hasStyle;
			}

			color.elementIsDistinct = elementIsDistinct;
			/* global axe, color, dom */

			/**
			 * Returns background color for element
			 * Uses getBackgroundStack() to get all elements rendered underneath the current element,
			 * to help determine the composite background color.
			 *
			 * @method getBackgroundColor
			 * @memberof axe.commons.color
			 * @param	{Element} elm Element to determine background color
			 * @param	{Array}	 [bgElms=[]] elements to inspect
			 * @param	{Boolean} [noScroll=false] should scroll
			 * @returns {Color}
			 */

			color.getBackgroundColor = function getBackgroundColor(elm) {
				var bgElms =
					arguments.length > 1 && arguments[1] !== undefined
						? arguments[1]
						: [];
				var noScroll =
					arguments.length > 2 && arguments[2] !== undefined
						? arguments[2]
						: false;

				if (noScroll !== true) {
					/**
					 * Avoid scrolling overflow:hidden containers, by only aligning to top,
					 * when not doing so would move the center point above the viewport top.
					 */
					var clientHeight = elm.getBoundingClientRect().height;
					var alignToTop = clientHeight - 2 >= window.innerHeight * 2;
					elm.scrollIntoView(alignToTop); // ensure element is scrolled into view horizontally

					var center, scrollParent;

					do {
						var rect = elm.getBoundingClientRect(); // 'x' does not exist in IE11

						var x = 'x' in rect ? rect.x : rect.left;
						center = x + rect.width / 2;

						if (center < 0) {
							scrollParent = getScrollParent(elm);
							scrollParent.scrollLeft = 0;
						}
					} while (center < 0 && scrollParent !== document.documentElement);
				}

				var bgColors = [];
				var elmStack = color.getBackgroundStack(elm); // Search the stack until we have an alpha === 1 background

				(elmStack || []).some(function(bgElm) {
					var bgElmStyle = window.getComputedStyle(bgElm); // Get the background color

					var bgColor = color.getOwnBackgroundColor(bgElmStyle);

					if (
						// abort if a node is partially obscured and obscuring element has a background
						elmPartiallyObscured(elm, bgElm, bgColor) || // OR if the background elm is a graphic
						color.elementHasImage(bgElm, bgElmStyle)
					) {
						bgColors = null;
						bgElms.push(bgElm);
						return true;
					}

					if (bgColor.alpha !== 0) {
						// store elements contributing to the br color.
						bgElms.push(bgElm);
						bgColors.push(bgColor); // Exit if the background is opaque

						return bgColor.alpha === 1;
					} else {
						return false;
					}
				});

				if (bgColors !== null && elmStack !== null) {
					// Mix the colors together, on top of a default white
					bgColors.push(new color.Color(255, 255, 255, 1));
					var colors = bgColors.reduce(color.flattenColors);
					return colors;
				}

				return null;
			};
			/**
			 * Get all elements rendered underneath the current element,
			 * In the order they are displayed (front to back)
			 *
			 * @method getBackgroundStack
			 * @memberof axe.commons.color
			 * @param {Element} elm
			 * @return {Array}
			 */

			color.getBackgroundStack = function getBackgroundStack(elm) {
				var elmStack = color.filteredRectStack(elm);

				if (elmStack === null) {
					return null;
				}

				elmStack = includeMissingElements(elmStack, elm);
				elmStack = dom.reduceToElementsBelowFloating(elmStack, elm);
				elmStack = sortPageBackground(elmStack); // Return all elements BELOW the current element, null if the element is undefined

				var elmIndex = elmStack.indexOf(elm);

				if (calculateObscuringElement(elmIndex, elmStack, elm)) {
					// if the total of the elements above our element results in total obscuring, return null
					axe.commons.color.incompleteData.set('bgColor', 'bgOverlap');
					return null;
				}

				return elmIndex !== -1 ? elmStack : null;
			};
			/**
			 * Get filtered stack of block and inline elements, excluding line breaks
			 * @method filteredRectStack
			 * @memberof axe.commons.color
			 * @param {Element} elm
			 * @return {Array}
			 */

			color.filteredRectStack = function filteredRectStack(elm) {
				var rectStack = color.getRectStack(elm);

				if (rectStack && rectStack.length === 1) {
					return rectStack[0];
				}

				if (rectStack && rectStack.length > 1) {
					var boundingStack = rectStack.shift();
					var isSame; // Safari v12.1 does not include labels as part of elementsFromPoint()
					// if they wrap an input element (UNLESS the label has a background
					// color). this results in two different rectStacks (since
					// elm.getClientRects() returns two rects for the element) which
					// returns null as isSame is false. we can fix this by adding in the
					// missing label to the boundingStack before checking for isSame
					// @see https://bugs.webkit.org/show_bug.cgi?id=197743

					includeMissingElements(boundingStack, elm); // iterating over arrays of DOMRects

					rectStack.forEach(function(rectList, index) {
						if (index === 0) {
							return;
						} // if the stacks are the same, use the first one. otherwise, return null.

						var rectA = rectStack[index - 1],
							rectB = rectStack[index]; // if elements in clientRects are the same
						// or the boundingClientRect contains the differing element, pass it

						isSame =
							rectA.every(function(element, elementIndex) {
								return element === rectB[elementIndex];
							}) || boundingStack.includes(elm);
					});

					if (!isSame) {
						axe.commons.color.incompleteData.set(
							'bgColor',
							'elmPartiallyObscuring'
						);
						return null;
					} // pass the first stack if it wasn't partially covered

					return rectStack[0];
				} // rect outside of viewport

				axe.commons.color.incompleteData.set('bgColor', 'outsideViewport');
				return null;
			};
			/**
			 * Get relevant stacks of block and inline elements, excluding line breaks
			 * @method getRectStack
			 * @memberof axe.commons.color
			 * @param {Element} elm
			 * @return {Array}
			 */

			color.getRectStack = function(elm) {
				var boundingCoords = axe.commons.color.centerPointOfRect(
					elm.getBoundingClientRect()
				);

				if (!boundingCoords) {
					return null;
				}

				var boundingStack = dom.shadowElementsFromPoint(
					boundingCoords.x,
					boundingCoords.y
				);
				var rects = Array.from(elm.getClientRects()); // If the element does not have multiple rects, like for display:block, return a single stack

				if (!rects || rects.length <= 1) {
					return [boundingStack];
				} // Handle inline elements spanning multiple lines to be evaluated

				var filteredArr = rects
					.filter(function(rect) {
						// exclude manual line breaks in Chrome/Safari
						return rect.width && rect.width > 0;
					})
					.map(function(rect) {
						var coords = axe.commons.color.centerPointOfRect(rect);

						if (coords) {
							return dom.shadowElementsFromPoint(coords.x, coords.y);
						}
					});

				if (
					filteredArr.some(function(stack) {
						return stack === undefined;
					})
				) {
					// Can be happen when one or more of the rects sits outside the viewport
					return null;
				} // add bounding client rect stack for comparison later

				filteredArr.splice(0, 0, boundingStack);
				return filteredArr;
			};
			/**
			 * Look at document and body elements for relevant background information
			 * @method sortPageBackground
			 * @private
			 * @param {Array} elmStack
			 * @returns {Array}
			 */

			function sortPageBackground(elmStack) {
				var bodyIndex = elmStack.indexOf(document.body);
				var bgNodes = elmStack; // Body can sometimes appear out of order in the stack:
				//   1) Body is not the first element due to negative z-index elements
				//   2) Elements are positioned outside of body's rect coordinates
				//      (see https://github.com/dequelabs/axe-core/issues/1456)
				// In those instances we want to reinsert body back into the element stack
				// when not using the root document element as the html canvas for bgcolor
				// prettier-ignore

				var sortBodyElement = bodyIndex > 1 || // negative z-index elements
      bodyIndex === -1; // element does not intersect with body

				if (
					sortBodyElement &&
					!color.elementHasImage(document.documentElement) &&
					color.getOwnBackgroundColor(
						window.getComputedStyle(document.documentElement)
					).alpha === 0
				) {
					// Only remove document.body if it was originally contained within the element stack
					if (bodyIndex > 1) {
						bgNodes.splice(bodyIndex, 1);
					} // Remove document element since body will be used for bgcolor

					bgNodes.splice(elmStack.indexOf(document.documentElement), 1); // Put the body background as the lowest element

					bgNodes.push(document.body);
				}

				return bgNodes;
			}
			/**
			 * Include nodes missing from initial gathering because
			 * document.elementsFromPoint misses some elements we need
			 * i.e. TR is missing from table elementStack and leaves out bgColor
			 * https://github.com/dequelabs/axe-core/issues/273
			 * @private
			 * @param {Array} elmStack
			 * @param {Element} elm
			 * @returns {Array}
			 */

			function includeMissingElements(elmStack, elm) {
				/*eslint max-depth:["error",7]*/
				var nodeName = elm.nodeName.toUpperCase();
				var elementMap = {
					TD: ['TR', 'THEAD', 'TBODY', 'TFOOT'],
					TH: ['TR', 'THEAD', 'TBODY', 'TFOOT'],
					INPUT: ['LABEL']
				};
				var tagArray = elmStack.map(function(elm) {
					return elm.nodeName.toUpperCase();
				});
				var bgNodes = elmStack;

				for (var candidate in elementMap) {
					// check that TR or LABEL has paired nodeName from elementMap, but don't expect elm to be that candidate
					if (tagArray.includes(candidate)) {
						for (
							var candidateIndex = 0;
							candidateIndex < elementMap[candidate].length;
							candidateIndex++
						) {
							// look up the tree for a matching candidate
							var ancestorMatch = axe.commons.dom.findUp(
								elm,
								elementMap[candidate][candidateIndex]
							);

							if (ancestorMatch && elmStack.indexOf(ancestorMatch) === -1) {
								// found an ancestor not in elmStack, and it overlaps
								var overlaps = axe.commons.dom.visuallyOverlaps(
									elm.getBoundingClientRect(),
									ancestorMatch
								);

								if (overlaps) {
									// if target is in the elementMap, use its position.
									bgNodes.splice(
										tagArray.indexOf(candidate) + 1,
										0,
										ancestorMatch
									);
								}
							} // nodeName matches value
							// (such as LABEL, when matching itself. It should be in the list, but Phantom skips it)

							if (
								nodeName === elementMap[candidate][candidateIndex] &&
								tagArray.indexOf(nodeName) === -1
							) {
								bgNodes.splice(tagArray.indexOf(candidate) + 1, 0, elm);
							}
						}
					}
				}

				return bgNodes;
			}
			/**
			 * Determine if element is partially overlapped, triggering a Can't Tell result
			 * @private
			 * @param {Element} elm
			 * @param {Element} bgElm
			 * @param {Object} bgColor
			 * @return {Boolean}
			 */

			function elmPartiallyObscured(elm, bgElm, bgColor) {
				var obscured =
					elm !== bgElm &&
					!dom.visuallyContains(elm, bgElm) &&
					bgColor.alpha !== 0;

				if (obscured) {
					axe.commons.color.incompleteData.set(
						'bgColor',
						'elmPartiallyObscured'
					);
				}

				return obscured;
			}
			/**
			 * Calculate alpha transparency of a background element obscuring the current node
			 * @private
			 * @param {Number} elmIndex
			 * @param {Array} elmStack
			 * @param {Element} originalElm
			 * @return {Number|undefined}
			 */

			function calculateObscuringElement(elmIndex, elmStack, originalElm) {
				if (elmIndex > 0) {
					// there are elements above our element, check if they contribute to the background
					for (var i = elmIndex - 1; i >= 0; i--) {
						var bgElm = elmStack[i];

						if (contentOverlapping(originalElm, bgElm)) {
							return true;
						} else {
							// remove elements not contributing to the background
							elmStack.splice(i, 1);
						}
					}
				}

				return false;
			}
			/**
			 * Determines overlap of node's content with a bgNode. Used for inline elements
			 * @private
			 * @param {Element} targetElement
			 * @param {Element} bgNode
			 * @return {Boolean}
			 */

			function contentOverlapping(targetElement, bgNode) {
				// get content box of target element
				// check to see if the current bgNode is overlapping
				var targetRect = targetElement.getClientRects()[0];
				var obscuringElements = dom.shadowElementsFromPoint(
					targetRect.left,
					targetRect.top
				);

				if (obscuringElements) {
					for (var i = 0; i < obscuringElements.length; i++) {
						if (
							obscuringElements[i] !== targetElement &&
							obscuringElements[i] === bgNode
						) {
							return true;
						}
					}
				}

				return false;
			}
			/**
			 * Return the scrolling parent element
			 * @see https://stackoverflow.com/questions/35939886/find-first-scrollable-parent#42543908
			 * @param {Element} element
			 * @param {Boolean} includeHidden
			 * @return {Element}
			 */

			function getScrollParent(element, includeHidden) {
				var style = getComputedStyle(element);
				var excludeStaticParent = style.position === 'absolute';
				var overflowRegex = includeHidden
					? /(auto|scroll|hidden)/
					: /(auto|scroll)/;

				if (style.position === 'fixed') {
					return document.documentElement;
				}

				for (var parent = element; (parent = parent.parentElement); ) {
					style = getComputedStyle(parent);

					if (excludeStaticParent && style.position === 'static') {
						continue;
					}

					if (
						overflowRegex.test(
							style.overflow + style.overflowY + style.overflowX
						)
					) {
						return parent;
					}
				}

				return document.documentElement;
			}
			/**
			 * Determines whether an element has a fully opaque background, whether solid color or an image
			 * @param {Element} node
			 * @return {Boolean} false if the background is transparent, true otherwise
			 */

			dom.isOpaque = function(node) {
				var style = window.getComputedStyle(node);
				return (
					color.elementHasImage(node, style) ||
					color.getOwnBackgroundColor(style).alpha === 1
				);
			};
			/* global axe, color */

			function getOpacity(node) {
				if (!node) {
					return 1;
				}

				var vNode = axe.utils.getNodeFromTree(node);

				if (vNode && vNode._opacity !== undefined && vNode._opacity !== null) {
					return vNode._opacity;
				}

				var nodeStyle = window.getComputedStyle(node);
				var opacity = nodeStyle.getPropertyValue('opacity');
				var finalOpacity = opacity * getOpacity(node.parentElement); // cache the results of the getOpacity check on the parent tree
				// so we don't have to look at the parent tree again for all its
				// descendants

				if (vNode) {
					vNode._opacity = finalOpacity;
				}

				return finalOpacity;
			}
			/**
			 * Returns the flattened foreground color of an element, or null if it can't be determined because
			 * of transparency
			 * @method getForegroundColor
			 * @memberof axe.commons.color
			 * @instance
			 * @param {Element} node
			 * @param {Boolean} noScroll (default false)
			 * @param {Color} bgColor
			 * @return {Color|null}
			 */

			color.getForegroundColor = function(node, noScroll, bgColor) {
				var nodeStyle = window.getComputedStyle(node);
				var fgColor = new color.Color();
				fgColor.parseRgbString(nodeStyle.getPropertyValue('color'));
				var opacity = getOpacity(node);
				fgColor.alpha = fgColor.alpha * opacity;

				if (fgColor.alpha === 1) {
					return fgColor;
				}

				if (!bgColor) {
					bgColor = color.getBackgroundColor(node, [], noScroll);
				}

				if (bgColor === null) {
					var reason = axe.commons.color.incompleteData.get('bgColor');
					axe.commons.color.incompleteData.set('fgColor', reason);
					return null;
				}

				return color.flattenColors(fgColor, bgColor);
			};
			/* global color */

			/**
			 * Returns the non-alpha-blended background color of an element
			 *
			 * @method getOwnBackgroundColor
			 * @memberof axe.commons.color
			 *
			 * @param {Object} elmStyle style of the element
			 * @return {Color}
			 */

			color.getOwnBackgroundColor = function getOwnBackgroundColor(elmStyle) {
				var bgColor = new color.Color();
				bgColor.parseRgbString(elmStyle.getPropertyValue('background-color'));

				if (bgColor.alpha !== 0) {
					var opacity = elmStyle.getPropertyValue('opacity');
					bgColor.alpha = bgColor.alpha * opacity;
				}

				return bgColor;
			};
			/* global color */

			/**
			 * API for handling incomplete color data
			 * @namespace axe.commons.color.incompleteData
			 * @inner
			 */

			color.incompleteData = (function() {
				var data = {};
				return {
					/**
					 * Store incomplete data by key with a string value
					 * @method set
					 * @memberof axe.commons.color.incompleteData
					 * @instance
					 * @param {String} key Identifier for missing data point (fgColor, bgColor, etc.)
					 * @param {String} reason Missing data reason to match message template
					 */
					set: function set(key, reason) {
						if (typeof key !== 'string') {
							throw new Error('Incomplete data: key must be a string');
						}

						if (reason) {
							data[key] = reason;
						}

						return data[key];
					},

					/**
					 * Get incomplete data by key
					 * @method get
					 * @memberof axe.commons.color.incompleteData
					 * @instance
					 * @param {String} key 	Identifier for missing data point (fgColor, bgColor, etc.)
					 * @return {String} String for reason we couldn't tell
					 */
					get: function get(key) {
						return data[key];
					},

					/**
					 * Clear incomplete data on demand
					 * @method clear
					 * @memberof axe.commons.color.incompleteData
					 * @instance
					 */
					clear: function clear() {
						data = {};
					}
				};
			})();
			/* global dom */

			/**
			 * Reduce an array of elements to only those that are below a 'floating' element.
			 * @method reduceToElementsBelowFloating
			 * @memberof axe.commons.dom
			 * @instance
			 * @param {Array} elements
			 * @param {Element} targetNode
			 * @returns {Array}
			 */

			dom.reduceToElementsBelowFloating = function(elements, targetNode) {
				var floatingPositions = ['fixed', 'sticky'],
					finalElements = [],
					targetFound = false,
					index,
					currentNode,
					style; // Filter out elements that are temporarily floating above the target

				for (index = 0; index < elements.length; ++index) {
					currentNode = elements[index];

					if (currentNode === targetNode) {
						targetFound = true;
					}

					style = window.getComputedStyle(currentNode);

					if (
						!targetFound &&
						floatingPositions.indexOf(style.position) !== -1
					) {
						//Target was not found yet, so it must be under this floating thing (and will not always be under it)
						finalElements = [];
						continue;
					}

					finalElements.push(currentNode);
				}

				return finalElements;
			};
			/* global axe, dom */

			/**
			 * Find elements referenced from a given context
			 * @method findElmsInContext
			 * @memberof axe.commons.dom
			 * @instance
			 * @param {Object} element
			 * @param {String} element.context Element in the same context
			 * @param {String} element.value Attribute value to search for
			 * @param {String} element.attr Attribute name to search for
			 * @param {String} element.elm NodeName to search for (optional)
			 * @return {Array<Node>}
			 */

			dom.findElmsInContext = function(_ref40) {
				var context = _ref40.context,
					value = _ref40.value,
					attr = _ref40.attr,
					_ref40$elm = _ref40.elm,
					elm = _ref40$elm === void 0 ? '' : _ref40$elm;
				var root;
				var escapedValue = axe.utils.escapeSelector(value);

				if (context.nodeType === 9 || context.nodeType === 11) {
					// It's already root
					root = context;
				} else {
					root = dom.getRootNode(context);
				}

				return Array.from(
					root.querySelectorAll(elm + '[' + attr + '=' + escapedValue + ']')
				);
			};
			/* global dom, axe */

			/**
			 * Find the virtual node and call dom.fundUpVirtual
			 *
			 * **WARNING:** this should be used sparingly, as it's not even close to being performant
			 * @method findUp
			 * @memberof axe.commons.dom
			 * @instance
			 * @param {HTMLElement} element The starting HTMLElement
			 * @param {String} target The selector for the HTMLElement
			 * @return {HTMLElement|null} Either the matching HTMLElement or `null` if there was no match
			 */

			dom.findUp = function(element, target) {
				return dom.findUpVirtual(axe.utils.getNodeFromTree(element), target);
			};
			/**
			 * recusively walk up the DOM, checking for a node which matches a selector
			 *
			 * **WARNING:** this should be used sparingly, as it's not even close to being performant
			 * @method findUpVirtual
			 * @memberof axe.commons.dom
			 * @instance
			 * @param {VirtualNode} element The starting virtualNode
			 * @param {String} target The selector for the HTMLElement
			 * @return {HTMLElement|null} Either the matching HTMLElement or `null` if there was no match
			 */

			dom.findUpVirtual = function(element, target) {
				var parent;
				parent = element.actualNode; // virtualNode will have a shadowId if the element lives inside a shadow DOM or is
				// slotted into a shadow DOM

				if (
					!element.shadowId &&
					typeof element.actualNode.closest === 'function'
				) {
					// non-shadow DOM elements
					var match = element.actualNode.closest(target);

					if (match) {
						return match;
					}

					return null;
				} // handle shadow DOM elements and older browsers

				do {
					// recursively walk up the DOM, checking each parent node
					parent = parent.assignedSlot
						? parent.assignedSlot
						: parent.parentNode;

					if (parent && parent.nodeType === 11) {
						parent = parent.host;
					}
				} while (
					parent &&
					!axe.utils.matchesSelector(parent, target) &&
					parent !== document.documentElement
				);

				if (!parent) {
					return null;
				}

				if (!axe.utils.matchesSelector(parent, target)) {
					return null;
				}

				return parent;
			};
			/* global dom */

			/**
			 * Get an element's parent in the flattened tree
			 * @method getComposedParent
			 * @memberof axe.commons.dom
			 * @instance
			 * @param {Node} element
			 * @return {Node|null} Parent element or Null for root node
			 */

			dom.getComposedParent = function getComposedParent(element) {
				if (element.assignedSlot) {
					// NOTE: If the display of a slot element isn't 'contents',
					// the slot shouldn't be ignored. Chrome does not support this (yet) so,
					// we'll skip this part for now.
					return getComposedParent(element.assignedSlot); // parent of a shadow DOM slot
				} else if (element.parentNode) {
					var parentNode = element.parentNode;

					if (parentNode.nodeType === 1) {
						return parentNode; // Regular node
					} else if (parentNode.host) {
						return parentNode.host; // Shadow root
					}
				}

				return null; // Root node
			};
			/* global dom */

			/**
			 * Returns a reference to the element matching the attr URL fragment value
			 * @method getElementByReference
			 * @memberof axe.commons.dom
			 * @instance
			 * @param {Element} node
			 * @param {String} attr Attribute name (href)
			 * @return {Element}
			 */

			dom.getElementByReference = function(node, attr) {
				var fragment = node.getAttribute(attr);

				if (!fragment) {
					return null;
				}

				if (fragment.charAt(0) === '#') {
					fragment = decodeURIComponent(fragment.substring(1));
				} else if (fragment.substr(0, 2) === '/#') {
					fragment = decodeURIComponent(fragment.substring(2));
				}

				var candidate = document.getElementById(fragment);

				if (candidate) {
					return candidate;
				}

				candidate = document.getElementsByName(fragment);

				if (candidate.length) {
					return candidate[0];
				}

				return null;
			};
			/* global dom */

			/**
			 * Get the coordinates of the element passed into the function relative to the document
			 * @method getElementCoordinates
			 * @memberof axe.commons.dom
			 * @instance
			 * @param {HTMLElement} element The HTMLElement
			 * @return {elementObj} elementObj Returns a `Object` with the following properties, which
			 * each hold a value representing the pixels for each of the
			 */

			/**
			 * @typedef elementObj
			 * @type {Object}
			 * @property {Number} top The top coordinate of the element
			 * @property {Number} right The right coordinate of the element
			 * @property {Number} bottom The bottom coordinate of the element
			 * @property {Number} left The left coordinate of the element
			 * @property {Number} width The width of the element
			 * @property {Number} height The height of the element
			 */

			dom.getElementCoordinates = function(element) {
				'use strict';

				var scrollOffset = dom.getScrollOffset(document),
					xOffset = scrollOffset.left,
					yOffset = scrollOffset.top,
					coords = element.getBoundingClientRect();
				return {
					top: coords.top + yOffset,
					right: coords.right + xOffset,
					bottom: coords.bottom + yOffset,
					left: coords.left + xOffset,
					width: coords.right - coords.left,
					height: coords.bottom - coords.top
				};
			};
			/* global dom */
			// split the page cells to group elements by the position

			var gridSize = 200; // arbitrary size, increase to reduce memory (less cells) use but increase time (more nodes per grid to check collision)

			/**
			 * Determine if node produces a stacking context.
			 * References:
			 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
			 * https://github.com/gwwar/z-context/blob/master/devtools/index.js
			 * @param {VirtualNode} vNode
			 * @return {Boolean}
			 */

			function isStackingContext(vNode) {
				var node = vNode.actualNode; //the root element (HTML)

				if (
					!node ||
					node.nodeName === 'HTML' ||
					node.nodeName === '#document-fragment'
				) {
					return true;
				} // position: fixed or sticky

				if (
					vNode.getComputedStylePropertyValue('position') === 'fixed' ||
					vNode.getComputedStylePropertyValue('position') === 'sticky'
				) {
					return true;
				} // positioned (absolutely or relatively) with a z-index value other than "auto",

				if (
					vNode.getComputedStylePropertyValue('z-index') !== 'auto' &&
					vNode.getComputedStylePropertyValue('position') !== 'static'
				) {
					return true;
				} // elements with an opacity value less than 1.

				if (vNode.getComputedStylePropertyValue('opacity') !== '1') {
					return true;
				} // elements with a transform value other than "none"

				var transform =
					vNode.getComputedStylePropertyValue('-webkit-transform') ||
					vNode.getComputedStylePropertyValue('-ms-transform') ||
					vNode.getComputedStylePropertyValue('transform') ||
					'none';

				if (transform !== 'none') {
					return true;
				} // elements with a mix-blend-mode value other than "normal"

				if (
					vNode.getComputedStylePropertyValue('mix-blend-mode') &&
					vNode.getComputedStylePropertyValue('mix-blend-mode') !== 'normal'
				) {
					return true;
				} // elements with a filter value other than "none"

				if (
					vNode.getComputedStylePropertyValue('filter') &&
					vNode.getComputedStylePropertyValue('filter') !== 'none'
				) {
					return true;
				} // elements with a perspective value other than "none"

				if (
					vNode.getComputedStylePropertyValue('perspective') &&
					vNode.getComputedStylePropertyValue('perspective') !== 'none'
				) {
					return true;
				} // element with a clip-path value other than "none"

				if (
					vNode.getComputedStylePropertyValue('clip-path') &&
					vNode.getComputedStylePropertyValue('clip-path') !== 'none'
				) {
					return true;
				} // element with a mask value other than "none"

				var mask =
					vNode.getComputedStylePropertyValue('-webkit-mask') ||
					vNode.getComputedStylePropertyValue('mask') ||
					'none';

				if (mask !== 'none') {
					return true;
				} // element with a mask-image value other than "none"

				var maskImage =
					vNode.getComputedStylePropertyValue('-webkit-mask-image') ||
					vNode.getComputedStylePropertyValue('mask-image') ||
					'none';

				if (maskImage !== 'none') {
					return true;
				} // element with a mask-border value other than "none"

				var maskBorder =
					vNode.getComputedStylePropertyValue('-webkit-mask-border') ||
					vNode.getComputedStylePropertyValue('mask-border') ||
					'none';

				if (maskBorder !== 'none') {
					return true;
				} // elements with isolation set to "isolate"

				if (vNode.getComputedStylePropertyValue('isolation') === 'isolate') {
					return true;
				} // transform or opacity in will-change even if you don't specify values for these attributes directly

				if (
					vNode.getComputedStylePropertyValue('will-change') === 'transform' ||
					vNode.getComputedStylePropertyValue('will-change') === 'opacity'
				) {
					return true;
				} // elements with -webkit-overflow-scrolling set to "touch"

				if (
					vNode.getComputedStylePropertyValue('-webkit-overflow-scrolling') ===
					'touch'
				) {
					return true;
				} // element with a contain value of "layout" or "paint" or a composite value
				// that includes either of them (i.e. contain: strict, contain: content).

				var contain = vNode.getComputedStylePropertyValue('contain');

				if (['layout', 'paint', 'strict', 'content'].includes(contain)) {
					return true;
				} // a flex item or gird item with a z-index value other than "auto", that is the parent element display: flex|inline-flex|grid|inline-grid,

				if (
					vNode.getComputedStylePropertyValue('z-index') !== 'auto' &&
					vNode.parent
				) {
					var parentDsiplay = vNode.parent.getComputedStylePropertyValue(
						'display'
					);

					if (
						[
							'flex',
							'inline-flex',
							'inline flex',
							'grid',
							'inline-grid',
							'inline grid'
						].includes(parentDsiplay)
					) {
						return true;
					}
				}

				return false;
			}
			/**
			 * Return the index order of how to position this element. return nodes in non-positioned, floating, positioned order
			 * References:
			 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/Stacking_without_z-index
			 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/Stacking_and_float
			 * https://drafts.csswg.org/css2/visuren.html#layers
			 * @param {VirtualNode} vNode
			 * @return {Number}
			 */

			function getPositionOrder(vNode) {
				if (vNode.getComputedStylePropertyValue('position') === 'static') {
					// 5. the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.
					if (
						vNode.getComputedStylePropertyValue('display').indexOf('inline') !==
						-1
					) {
						return 2;
					} // 4. the non-positioned floats.

					if (vNode.getComputedStylePropertyValue('float') !== 'none') {
						return 1;
					} // 3. the in-flow, non-inline-level, non-positioned descendants.

					if (vNode.getComputedStylePropertyValue('position') === 'static') {
						return 0;
					}
				} // 6. the child stacking contexts with stack level 0 and the positioned descendants with stack level 0.

				return 3;
			}
			/**
			 * Visually sort nodes based on their stack order
			 * References:
			 * https://drafts.csswg.org/css2/visuren.html#layers
			 * @param {VirtualNode}
			 * @param {VirtualNode}
			 */

			function visuallySort(a, b) {
				/*eslint no-bitwise: 0 */
				// 1. The root element forms the root stacking context.
				if (a.actualNode.nodeName.toLowerCase() === 'html') {
					return 1;
				}

				if (b.actualNode.nodeName.toLowerCase() === 'html') {
					return -1;
				}

				for (var i = 0; i < a._stackingOrder.length; i++) {
					if (typeof b._stackingOrder[i] === 'undefined') {
						return -1;
					} // 7. the child stacking contexts with positive stack levels (least positive first).

					if (b._stackingOrder[i] > a._stackingOrder[i]) {
						return 1;
					} // 2. the child stacking contexts with negative stack levels (most negative first).

					if (b._stackingOrder[i] < a._stackingOrder[i]) {
						return -1;
					}
				} // nodes are the same stacking order

				var docPosition = a.actualNode.compareDocumentPosition(b.actualNode);
				var DOMOrder = docPosition & 4 ? 1 : -1;
				var isDescendant = docPosition & 8 || docPosition & 16;
				var aPosition = getPositionOrder(a);
				var bPosition = getPositionOrder(b); // a child of a positioned element should also be on top of the parent

				if (aPosition === bPosition || isDescendant) {
					return DOMOrder;
				}

				return bPosition - aPosition;
			}
			/**
			 * Determine the stacking order of an element. The stacking order is an array of
			 * zIndex values for each stacking context parent.
			 * @param {VirtualNode}
			 * @return {Number[]}
			 */

			function getStackingOrder(vNode) {
				var stackingOrder = vNode.parent
					? vNode.parent._stackingOrder.slice()
					: [0];

				if (vNode.getComputedStylePropertyValue('z-index') !== 'auto') {
					stackingOrder[stackingOrder.length - 1] = parseInt(
						vNode.getComputedStylePropertyValue('z-index')
					);
				}

				if (isStackingContext(vNode)) {
					stackingOrder.push(0);
				}

				return stackingOrder;
			}
			/**
			 * Return the parent node that is a scroll region.
			 * @param {VirtualNode}
			 * @return {VirtualNode|null}
			 */

			function findScrollRegionParent(vNode) {
				var scrollRegionParent = null;
				var vNodeParent = vNode.parent;
				var checkedNodes = [vNode];

				while (vNodeParent) {
					if (vNodeParent._scrollRegionParent) {
						scrollRegionParent = vNodeParent._scrollRegionParent;
						break;
					}

					if (axe.utils.getScroll(vNodeParent.actualNode)) {
						scrollRegionParent = vNodeParent;
						break;
					}

					checkedNodes.push(vNodeParent);
					vNodeParent = vNodeParent.parent;
				} // cache result of parent scroll region so we don't have to look up the entire
				// tree again for a child node

				checkedNodes.forEach(function(vNode) {
					return (vNode._scrollRegionParent = scrollRegionParent);
				});
				return scrollRegionParent;
			}
			/**
			 * Get the DOMRect x or y value. IE11 (and Phantom) does not support x/y
			 * on DOMRect.
			 * @param {DOMRect}
			 * @param {String} pos 'x' or 'y'
			 * @return {Number}
			 */

			function getDomPosition(rect, pos) {
				if (pos === 'x') {
					return 'x' in rect ? rect.x : rect.left;
				}

				return 'y' in rect ? rect.y : rect.top;
			}
			/**
			 * Add a node to every cell of the grid it intersects with.
			 * @param {Grid}
			 * @param {VirtualNode}
			 */

			function addNodeToGrid(grid, vNode) {
				// save a reference to where this element is in the grid so we
				// can find it even if it's in a subgrid
				vNode._grid = grid;
				vNode.clientRects.forEach(function(rect) {
					var startRow = Math.floor(getDomPosition(rect, 'y') / gridSize);
					var startCol = Math.floor(getDomPosition(rect, 'x') / gridSize);
					var endRow = Math.floor(
						(getDomPosition(rect, 'y') + rect.height) / gridSize
					);
					var endCol = Math.floor(
						(getDomPosition(rect, 'x') + rect.width) / gridSize
					);

					for (var row = startRow; row <= endRow; row++) {
						grid.cells[row] = grid.cells[row] || [];

						for (var col = startCol; col <= endCol; col++) {
							grid.cells[row][col] = grid.cells[row][col] || [];

							if (!grid.cells[row][col].includes(vNode)) {
								grid.cells[row][col].push(vNode);
							}
						}
					}
				});
			}
			/**
			 * Setup the 2d grid and add every element to it.
			 */

			function createGrid() {
				var rootGrid = {
					container: null,
					cells: []
				};
				axe.utils
					.querySelectorAll(axe._tree[0], '*')
					.filter(function(vNode) {
						return vNode.actualNode.parentElement !== document.head;
					})
					.forEach(function(vNode) {
						if (vNode.actualNode.nodeType !== window.Node.ELEMENT_NODE) {
							return;
						}

						vNode._stackingOrder = getStackingOrder(vNode); // filter out any elements with 0 width or height
						// (we don't do this before so we can calculate stacking context
						// of parents with 0 width/height)

						var rect = vNode.boundingClientRect;

						if (rect.width === 0 || rect.height === 0) {
							return;
						}

						var scrollRegionParent = findScrollRegionParent(vNode);
						var grid = scrollRegionParent
							? scrollRegionParent._subGrid
							: rootGrid;

						if (axe.utils.getScroll(vNode.actualNode)) {
							var subGrid = {
								container: vNode,
								cells: []
							};
							vNode._subGrid = subGrid;
						}

						addNodeToGrid(grid, vNode);
					});
			}
			/**
			 * Return all elements that are at the center point of the passed in virtual node.
			 * @method getElementStack
			 * @memberof axe.commons.dom
			 * @param {VirtualNode} vNode
			 * @param {Boolean} [recursed] If the function has been called recursively
			 * @return {VirtualNode[]}
			 */

			dom.getElementStack = function(vNode) {
				var recursed =
					arguments.length > 1 && arguments[1] !== undefined
						? arguments[1]
						: false;

				if (!axe._cache.get('gridCreated')) {
					createGrid();

					axe._cache.set('gridCreated', true);
				}

				var grid = vNode._grid;

				if (!grid) {
					return [];
				}

				var boundingRect = vNode.boundingClientRect; // use center point of rect

				var x = getDomPosition(boundingRect, 'x') + boundingRect.width / 2;
				var y = getDomPosition(boundingRect, 'y') + boundingRect.height / 2; // NOTE: there is a very rare edge case in Chrome vs Firefox that can
				// return different results of `document.elementsFromPoint`. If the center
				// point of the element is <1px outside of another elements bounding rect,
				// Chrome appears to round the number up and return the element while Firefox
				// keeps the number as is and won't return the element. In this case, we
				// went with pixel perfect collision rather than rounding

				var row = Math.floor(y / gridSize);
				var col = Math.floor(x / gridSize);
				var stack = grid.cells[row][col].filter(function(gridCellNode) {
					return gridCellNode.clientRects.find(function(rect) {
						var pointX = x;
						var pointY = y;
						var rectWidth = rect.width;
						var rectHeight = rect.height;
						var rectX = getDomPosition(rect, 'x');
						var rectY = getDomPosition(rect, 'y'); // perform an AABB (axis-aligned bounding box) collision check for the
						// point inside the rect

						return (
							pointX < rectX + rectWidth &&
							pointX > rectX &&
							pointY < rectY + rectHeight &&
							pointY > rectY
						);
					});
				});

				if (grid.container) {
					stack = dom.getElementStack(grid.container, true).concat(stack);
				}

				if (!recursed) {
					stack.sort(visuallySort);
				}

				return stack;
			};
			/* global dom */

			/**
			 * Parse resource object for a given node from a specified attribute
			 * @method getParsedResource
			 * @param {HTMLElement} node given node
			 * @param {String} attribute attribute of the node from which resource should be parsed
			 * @returns {Object}
			 */

			dom.getParsedResource = function getParsedResource(node, attribute) {
				var value = node[attribute];

				if (!value) {
					return undefined;
				}

				var nodeName = node.nodeName.toUpperCase();
				var parser = node;
				/**
				 * Note:
				 * The need to create a parser, is to keep this function generic, to be able to parse resource from element like `iframe` with `src` attribute
				 */

				if (!['A', 'AREA'].includes(nodeName)) {
					parser = document.createElement('a');
					parser.href = value;
				}

				var _getPathnameAndFilena3 = getPathnameAndFilename(parser.pathname),
					_getPathnameAndFilena4 = _getPathnameAndFilena3.pathname,
					pathname =
						_getPathnameAndFilena4 === void 0 ? '' : _getPathnameAndFilena4,
					_getPathnameAndFilena5 = _getPathnameAndFilena3.filename,
					filename =
						_getPathnameAndFilena5 === void 0
							? undefined
							: _getPathnameAndFilena5;

				return {
					protocol: parser.protocol,
					hostname: parser.hostname,
					port: parser.port,
					pathname: pathname.replace(/\/$/, ''),
					// remove trialing slashes
					search: parser.search,
					hash: getHashRoute(parser.hash),
					filename: filename
				};
			};
			/**
			 * Resolve if a given pathname has filename & resolve the same as parts
			 * @method getPathnameAndFilename
			 * @param {String} pathname pathname part of a given uri
			 * @returns {Array<String>}
			 */

			function getPathnameAndFilename(pathname) {
				if (!pathname) {
					return;
				}

				var filename = pathname.split('/').pop();

				if (!filename || filename.indexOf('.') === -1) {
					return {
						pathname: pathname
					};
				}

				var hasIndexInFilename = /index./.test(filename);

				if (hasIndexInFilename) {
					return {
						pathname: pathname.replace(filename, '')
					};
				}

				return {
					filename: filename
				};
			}
			/**
			 * Interpret a given hash
			 * if `hash`
			 * -> is `hashbang` -or- `hash` is followed by `slash`
			 * -> it resolves to a different resource
			 * @method getHashRoute
			 * @param {String} hash hash component of a parsed uri
			 * @returns {String|undefined}
			 */

			function getHashRoute(hash) {
				if (!hash) {
					return undefined;
				}
				/**
				 * Check for any conventionally-formatted hashbang may be present
				 * eg: `#, #/, #!, #!/`
				 */

				var hashRegex = /#!?\/?/g;
				var hasMatch = hash.match(hashRegex);

				if (!hasMatch) {
					return undefined;
				} // do not resolve inline link as hash

				var _hasMatch = _slicedToArray(hasMatch, 1),
					matchedStr = _hasMatch[0];

				if (matchedStr === '#') {
					return undefined;
				}

				return hash;
			}
			/* global dom */

			/**
			 * Return the document or document fragment (shadow DOM)
			 * @method getRootNode
			 * @memberof axe.commons.dom
			 * @instance
			 * @param {Element} node
			 * @returns {DocumentFragment|Document}
			 * @deprecated use axe.utils.getRootNode
			 */

			dom.getRootNode = axe.utils.getRootNode;
			/* global dom */

			/**
			 * Get the scroll offset of the document passed in
			 * @method getScrollOffset
			 * @memberof axe.commons.dom
			 * @instance
			 * @param {Document} element The element to evaluate, defaults to document
			 * @return {Object} Contains the attributes `x` and `y` which contain the scroll offsets
			 */

			dom.getScrollOffset = function(element) {
				'use strict';

				if (!element.nodeType && element.document) {
					element = element.document;
				} // 9 === Node.DOCUMENT_NODE

				if (element.nodeType === 9) {
					var docElement = element.documentElement,
						body = element.body;
					return {
						left:
							(docElement && docElement.scrollLeft) ||
							(body && body.scrollLeft) ||
							0,
						top:
							(docElement && docElement.scrollTop) ||
							(body && body.scrollTop) ||
							0
					};
				}

				return {
					left: element.scrollLeft,
					top: element.scrollTop
				};
			};
			/* global dom */

			/**
			 * Get all elements (including given node) that are part of the tab order
			 * @method getTabbableElements
			 * @memberof axe.commons.dom
			 * @instance
			 * @param  {Object} virtualNode The virtualNode to assess
			 * @return {Boolean}
			 */

			dom.getTabbableElements = function getTabbableElements(virtualNode) {
				var nodeAndDescendents = axe.utils.querySelectorAll(virtualNode, '*');
				var tabbableElements = nodeAndDescendents.filter(function(vNode) {
					var isFocusable = vNode.isFocusable;
					var tabIndex = vNode.actualNode.getAttribute('tabindex');
					tabIndex =
						tabIndex && !isNaN(parseInt(tabIndex, 10))
							? parseInt(tabIndex)
							: null;
					return tabIndex ? isFocusable && tabIndex >= 0 : isFocusable;
				});
				return tabbableElements;
			};
			/* global dom */

			/**
			 * Gets the width and height of the viewport; used to calculate the right and bottom boundaries of the viewable area.
			 * @method getViewportSize
			 * @memberof axe.commons.dom
			 * @instance
			 * @param  {Object}  win The `window` object that should be measured
			 * @return {Object}  Object with the `width` and `height` of the viewport
			 */

			dom.getViewportSize = function(win) {
				'use strict';

				var body,
					doc = win.document,
					docElement = doc.documentElement;

				if (win.innerWidth) {
					return {
						width: win.innerWidth,
						height: win.innerHeight
					};
				}

				if (docElement) {
					return {
						width: docElement.clientWidth,
						height: docElement.clientHeight
					};
				}

				body = doc.body;
				return {
					width: body.clientWidth,
					height: body.clientHeight
				};
			};
			/* global dom, aria, axe */

			var hiddenTextElms = [
				'HEAD',
				'TITLE',
				'TEMPLATE',
				'SCRIPT',
				'STYLE',
				'IFRAME',
				'OBJECT',
				'VIDEO',
				'AUDIO',
				'NOSCRIPT'
			];

			function hasChildTextNodes(elm) {
				if (!hiddenTextElms.includes(elm.actualNode.nodeName.toUpperCase())) {
					return elm.children.some(function(_ref41) {
						var actualNode = _ref41.actualNode;
						return actualNode.nodeType === 3 && actualNode.nodeValue.trim();
					});
				}
			}
			/**
			 * Check that the element has visible content in the form of either text,
			 * an aria-label or visual content such as image
			 * @method hasContentVirtual
			 * @memberof axe.commons.dom
			 * @instance
			 * @param	{VirtualNode} elm Virtual Node to search
			 * @param	{Boolean} noRecursion If true, only the element is checked, otherwise it will search all child nodes
			 * @param {Boolean} ignoreAria if true, ignores `aria label` computation for content deduction
			 * @return {Boolean}
			 */

			dom.hasContentVirtual = function(elm, noRecursion, ignoreAria) {
				return (
					// It has text
					hasChildTextNodes(elm) || // It is a graphical element
					dom.isVisualContent(elm.actualNode) || // It has an ARIA label
					(!ignoreAria && !!aria.labelVirtual(elm)) || // or one of it's descendants does
					(!noRecursion &&
						elm.children.some(function(child) {
							return (
								child.actualNode.nodeType === 1 && dom.hasContentVirtual(child)
							);
						}))
				);
			};
			/**
			 * Find virtual node and call hasContentVirtual()
			 * IMPORTANT: This method requires the composed tree at axe._tree
			 * @see axe.commons.dom.hasContentVirtual
			 * @method hasContent
			 * @memberof axe.commons.dom
			 * @instance
			 * @param {DOMNode} elm DOMNode element to check
			 * @param	{Boolean} noRecursion If true, only the element is checked, otherwise it will search all child nodes
			 * @param {Boolean} ignoreAria if true, ignores `aria label` computation for content deduction
			 * @return {Boolean}
			 */

			dom.hasContent = function hasContent(elm, noRecursion, ignoreAria) {
				elm = axe.utils.getNodeFromTree(elm);
				return dom.hasContentVirtual(elm, noRecursion, ignoreAria);
			};
			/**
			 * @typedef VirtualNode
			 * @type {Object}
			 * @property {HTMLElement} actualNode reference to actual HTML DOM element
			 * @property {Array<VirtualNode>} children array of child virtualNodes
			 * @property {String} shadowId The shadowId indicates whether the node is in a shadow root
			 * and if it is, which one it is inside the boundary.
			 */

			/*global dom, axe */

			/**
			 * Get elements referenced via a space-separated token attribute;
			 * it will insert `null` for any Element that is not found
			 * @method idrefs
			 * @memberof axe.commons.dom
			 * @instance
			 * @param  {HTMLElement} node
			 * @param  {String} attr The name of attribute
			 * @return {Array|null} Array of elements (or `null` if not found)
			 *
			 * NOTE: When in a shadow DOM environment: ID refs (even for slotted content)
			 * refer to the document in which the element is considered to be in the
			 * "light DOM". Therefore, we use getElementById on the root node and not QSA
			 * on the flattened tree to dereference idrefs.
			 *
			 */

			dom.idrefs = function(node, attr) {
				'use strict';

				var index,
					length,
					doc = dom.getRootNode(node),
					result = [],
					idrefs = node.getAttribute(attr);

				if (idrefs) {
					idrefs = axe.utils.tokenList(idrefs);

					for (index = 0, length = idrefs.length; index < length; index++) {
						result.push(doc.getElementById(idrefs[index]));
					}
				}

				return result;
			};
			/* global dom */

			/**
			 * Determines if focusing has been disabled on an element.
			 * @param {HTMLElement} el The HTMLElement
			 * @return {Boolean} Whether focusing has been disabled on an element.
			 */

			function focusDisabled(el) {
				return (
					el.disabled ||
					(el.nodeName.toUpperCase() !== 'AREA' && dom.isHiddenWithCSS(el))
				);
			}
			/**
			 * Determines if an element is focusable
			 * @method isFocusable
			 * @memberof axe.commons.dom
			 * @instance
			 * @param {HTMLElement} el The HTMLElement
			 * @return {Boolean} The element's focusability status
			 */

			dom.isFocusable = function(el) {
				'use strict';

				if (focusDisabled(el)) {
					return false;
				} else if (dom.isNativelyFocusable(el)) {
					return true;
				} // check if the tabindex is specified and a parseable number

				var tabindex = el.getAttribute('tabindex');

				if (tabindex && !isNaN(parseInt(tabindex, 10))) {
					return true;
				}

				return false;
			};
			/**
			 * Determines if an element is focusable without considering its tabindex
			 * @method isNativelyFocusable
			 * @memberof axe.commons.dom
			 * @instance
			 * @param {HTMLElement} el The HTMLElement
			 * @return {Boolean} True if the element is in the focus order but wouldn't be
			 * if its tabindex were removed. Else, false.
			 */

			dom.isNativelyFocusable = function(el) {
				/* eslint indent: 0*/
				'use strict';

				if (!el || focusDisabled(el)) {
					return false;
				}

				switch (el.nodeName.toUpperCase()) {
					case 'A':
					case 'AREA':
						if (el.href) {
							return true;
						}

						break;

					case 'INPUT':
						return el.type !== 'hidden';

					case 'TEXTAREA':
					case 'SELECT':
					case 'DETAILS':
					case 'BUTTON':
						return true;
				}

				return false;
			};
			/**
			 * Determines if an element is in the focus order, but would not be if its
			 * tabindex were unspecified.
			 * @method insertedIntoFocusOrder
			 * @memberof axe.commons.dom
			 * @instance
			 * @param {HTMLElement} el The HTMLElement
			 * @return {Boolean} True if the element is in the focus order but wouldn't be
			 * if its tabindex were removed. Else, false.
			 */

			dom.insertedIntoFocusOrder = function(el) {
				var tabIndex = parseInt(el.getAttribute('tabindex'), 10); // an element that has an invalid tabindex will return 0 or -1 based on
				// if it is natively focusable or not, which will always be false for this
				// check as NaN is not > 1
				// @see https://www.w3.org/TR/html51/editing.html#the-tabindex-attribute

				return (
					tabIndex > -1 && dom.isFocusable(el) && !dom.isNativelyFocusable(el)
				);
			};
			/* global dom */

			/**
			 * Determine whether an element is hidden based on css
			 * @method isHiddenWithCSS
			 * @memberof axe.commons.dom
			 * @instance
			 * @param {HTMLElement} el The HTML Element
			 * @param {Boolean} descendentVisibilityValue (Optional) immediate descendant visibility value used for recursive computation
			 * @return {Boolean} the element's hidden status
			 */

			dom.isHiddenWithCSS = function isHiddenWithCSS(
				el,
				descendentVisibilityValue
			) {
				var vNode = axe.utils.getNodeFromTree(el);

				if (!vNode) {
					return _isHiddenWithCSS(el, descendentVisibilityValue);
				}

				if (vNode._isHiddenWithCSS === void 0) {
					vNode._isHiddenWithCSS = _isHiddenWithCSS(
						el,
						descendentVisibilityValue
					);
				}

				return vNode._isHiddenWithCSS;
			};

			function _isHiddenWithCSS(el, descendentVisibilityValue) {
				if (el.nodeType === 9) {
					// 9 === Node.DOCUMENT
					return false;
				}

				if (el.nodeType === 11) {
					// 11 === Node.DOCUMENT_FRAGMENT_NODE
					el = el.host; // swap to host node
				}

				if (['STYLE', 'SCRIPT'].includes(el.nodeName.toUpperCase())) {
					return false;
				}

				var style = window.getComputedStyle(el, null);

				if (!style) {
					throw new Error('Style does not exist for the given element.');
				}

				var displayValue = style.getPropertyValue('display');

				if (displayValue === 'none') {
					return true;
				}

				var HIDDEN_VISIBILITY_VALUES = ['hidden', 'collapse'];
				var visibilityValue = style.getPropertyValue('visibility');

				if (
					HIDDEN_VISIBILITY_VALUES.includes(visibilityValue) &&
					!descendentVisibilityValue
				) {
					return true;
				}

				if (
					HIDDEN_VISIBILITY_VALUES.includes(visibilityValue) &&
					descendentVisibilityValue &&
					HIDDEN_VISIBILITY_VALUES.includes(descendentVisibilityValue)
				) {
					return true;
				}

				var parent = dom.getComposedParent(el);

				if (parent && !HIDDEN_VISIBILITY_VALUES.includes(visibilityValue)) {
					return dom.isHiddenWithCSS(parent, visibilityValue);
				}

				return false;
			}
			/* global dom */

			/**
			 * Determines if a document node is HTML 5
			 * @method isHTML5
			 * @memberof axe.commons.dom
			 * @instance
			 * @param {Node} doc
			 * @return {Boolean}
			 */

			dom.isHTML5 = function(doc) {
				var node = doc.doctype;

				if (node === null) {
					return false;
				}

				return node.name === 'html' && !node.publicId && !node.systemId;
			};
			/* global axe, dom, window */

			function walkDomNode(node, functor) {
				if (functor(node.actualNode) !== false) {
					node.children.forEach(function(child) {
						return walkDomNode(child, functor);
					});
				}
			}

			var blockLike = [
				'block',
				'list-item',
				'table',
				'flex',
				'grid',
				'inline-block'
			];

			function isBlock(elm) {
				var display = window.getComputedStyle(elm).getPropertyValue('display');
				return blockLike.includes(display) || display.substr(0, 6) === 'table-';
			}

			function getBlockParent(node) {
				// Find the closest parent
				var parentBlock = dom.getComposedParent(node);

				while (parentBlock && !isBlock(parentBlock)) {
					parentBlock = dom.getComposedParent(parentBlock);
				}

				return axe.utils.getNodeFromTree(parentBlock);
			}
			/**
			 * Determines if an element is within a text block
			 * @param  {Element} node [description]
			 * @return {Boolean}      [description]
			 */

			dom.isInTextBlock = function isInTextBlock(node) {
				if (isBlock(node)) {
					// Ignore if the link is a block
					return false;
				} // Find all the text part of the parent block not in a link, and all the text in a link

				var virtualParent = getBlockParent(node);
				var parentText = '';
				var linkText = '';
				var inBrBlock = 0; // We want to ignore hidden text, and if br / hr is used, only use the section of the parent
				// that has the link we're looking at

				walkDomNode(virtualParent, function(currNode) {
					// We're already passed it, skip everything else
					if (inBrBlock === 2) {
						return false;
					}

					if (currNode.nodeType === 3) {
						// Add the text to the parent
						parentText += currNode.nodeValue;
					} // Ignore any node that's not an element (or text as above)

					if (currNode.nodeType !== 1) {
						return;
					}

					var nodeName = (currNode.nodeName || '').toUpperCase(); // BR and HR elements break the line

					if (['BR', 'HR'].includes(nodeName)) {
						if (inBrBlock === 0) {
							parentText = '';
							linkText = '';
						} else {
							inBrBlock = 2;
						} // Don't walk nodes with content not displayed on screen.
					} else if (
						currNode.style.display === 'none' ||
						currNode.style.overflow === 'hidden' ||
						!['', null, 'none'].includes(currNode.style['float']) ||
						!['', null, 'relative'].includes(currNode.style.position)
					) {
						return false; // Don't walk links, we're only interested in what's not in them.
					} else if (
						(nodeName === 'A' && currNode.href) ||
						(currNode.getAttribute('role') || '').toLowerCase() === 'link'
					) {
						if (currNode === node) {
							inBrBlock = 1;
						} // Grab all the text from this element, but don't walk down it's children

						linkText += currNode.textContent;
						return false;
					}
				});
				parentText = axe.commons.text.sanitize(parentText);
				linkText = axe.commons.text.sanitize(linkText);
				return parentText.length > linkText.length;
			};
			/* global dom */

			/**
			 * Determines if element is an instance of Node
			 * @method isNode
			 * @memberof axe.commons.dom
			 * @instance
			 * @param  {Element} element
			 * @return {Boolean}
			 */

			dom.isNode = function(element) {
				'use strict';

				return element instanceof Node;
			};
			/* global dom */

			function noParentScrolled(element, offset) {
				element = dom.getComposedParent(element);

				while (element && element.nodeName.toLowerCase() !== 'html') {
					if (element.scrollTop) {
						offset += element.scrollTop;

						if (offset >= 0) {
							return false;
						}
					}

					element = dom.getComposedParent(element);
				}

				return true;
			}
			/**
			 * Determines if element is off screen
			 * @method isOffscreen
			 * @memberof axe.commons.dom
			 * @instance
			 * @param  {Element} element
			 * @return {Boolean}
			 */

			dom.isOffscreen = function(element) {
				var leftBoundary;
				var docElement = document.documentElement;
				var styl = window.getComputedStyle(element);
				var dir = window
					.getComputedStyle(document.body || docElement)
					.getPropertyValue('direction');
				var coords = dom.getElementCoordinates(element); // bottom edge beyond

				if (
					coords.bottom < 0 &&
					(noParentScrolled(element, coords.bottom) ||
						styl.position === 'absolute')
				) {
					return true;
				}

				if (coords.left === 0 && coords.right === 0) {
					//This is an edge case, an empty (zero-width) element that isn't positioned 'off screen'.
					return false;
				}

				if (dir === 'ltr') {
					if (coords.right <= 0) {
						return true;
					}
				} else {
					leftBoundary = Math.max(
						docElement.scrollWidth,
						dom.getViewportSize(window).width
					);

					if (coords.left >= leftBoundary) {
						return true;
					}
				}

				return false;
			};
			/* global dom */
			// test for hrefs that start with # or /# (for angular)

			var isInternalLinkRegex = /^\/?#[^/!]/;
			/**
			 * Determines if element is a skip link
			 * @method isSkipLink
			 * @memberof axe.commons.dom
			 * @instance
			 * @param  {Element} element
			 * @return {Boolean}
			 */

			dom.isSkipLink = function(element) {
				if (!isInternalLinkRegex.test(element.getAttribute('href'))) {
					return false;
				}

				var firstPageLink;

				if (typeof axe._cache.get('firstPageLink') !== 'undefined') {
					firstPageLink = axe._cache.get('firstPageLink');
				} else {
					// define a skip link as any anchor element whose href starts with `#...`
					// and which precedes the first anchor element whose href doesn't start
					// with  `#...` (that is, a link to a page)
					firstPageLink = axe.utils.querySelectorAll(
						axe._tree,
						'a:not([href^="#"]):not([href^="/#"]):not([href^="javascript"])'
					)[0]; // null will signify no first page link

					axe._cache.set('firstPageLink', firstPageLink || null);
				} // if there are no page links then all all links will need to be
				// considered as skip links

				if (!firstPageLink) {
					return true;
				}

				return (
					element.compareDocumentPosition(firstPageLink.actualNode) ===
					element.DOCUMENT_POSITION_FOLLOWING
				);
			};
			/* global dom */

			var clipRegex = /rect\s*\(([0-9]+)px,?\s*([0-9]+)px,?\s*([0-9]+)px,?\s*([0-9]+)px\s*\)/;
			var clipPathRegex = /(\w+)\((\d+)/;
			/**
			 * Determines if an element is hidden with a clip or clip-path technique
			 * @method isClipped
			 * @memberof axe.commons.dom
			 * @private
			 * @param  {CSSStyleDeclaration} style Computed style
			 * @return {Boolean}
			 */

			function isClipped(style) {
				'use strict';

				var matchesClip = style.getPropertyValue('clip').match(clipRegex);
				var matchesClipPath = style
					.getPropertyValue('clip-path')
					.match(clipPathRegex);

				if (matchesClip && matchesClip.length === 5) {
					return (
						matchesClip[3] - matchesClip[1] <= 0 &&
						matchesClip[2] - matchesClip[4] <= 0
					);
				}

				if (matchesClipPath) {
					var type = matchesClipPath[1];
					var value = parseInt(matchesClipPath[2], 10);

					switch (type) {
						case 'inset':
							return value >= 50;

						case 'circle':
							return value === 0;

						default:
					}
				}

				return false;
			}
			/**
			 * Check `AREA` element is visible
			 * - validate if it is a child of `map`
			 * - ensure `map` is referred by `img` using the `usemap` attribute
			 * @param {Element} areaEl `AREA` element
			 * @retruns {Boolean}
			 */

			function isAreaVisible(el) {
				var rootEl = dom.getRootNode(el);
				/**
				 * Note:
				 * - Verified that `map` element cannot refer to `area` elements across different document trees
				 * - Verified that `map` element does not get affected by altering `display` property
				 * - using `.cloesest` fails in `phantomjs`, hence using `dom.findUp`
				 */

				var mapEl = dom.findUp(el, 'map');

				if (!mapEl) {
					return false;
				}

				var mapElName = mapEl.getAttribute('name');

				if (!mapElName) {
					return false;
				}

				var refs = rootEl.querySelectorAll(
					'img[usemap="#'.concat(axe.utils.escapeSelector(mapElName), '"]')
				);

				if (!refs.length) {
					return false;
				}

				return true;
			}
			/**
			 * Determine whether an element is visible
			 * @method isVisible
			 * @memberof axe.commons.dom
			 * @instance
			 * @param {HTMLElement} el The HTMLElement
			 * @param {Boolean} screenReader When provided, will evaluate visibility from the perspective of a screen reader
			 * @param {Boolean} recursed
			 * @return {Boolean} The element's visibilty status
			 */

			dom.isVisible = function(el, screenReader, recursed) {
				'use strict';

				var node = axe.utils.getNodeFromTree(el);
				var cacheName = '_isVisible' + (screenReader ? 'ScreenReader' : ''); // 9 === Node.DOCUMENT

				if (el.nodeType === 9) {
					return true;
				} // 11 === Node.DOCUMENT_FRAGMENT_NODE

				if (el.nodeType === 11) {
					el = el.host; // grab the host Node
				}

				if (node && typeof node[cacheName] !== 'undefined') {
					return node[cacheName];
				}

				var style = window.getComputedStyle(el, null);

				if (style === null) {
					return false;
				}

				var nodeName = el.nodeName.toUpperCase();

				if (
					/**
					 * Note:
					 * Firefox's user-agent always sets `AREA` element to `display:none`
					 * hence excluding the edge case, for visibility computation
					 */
					(nodeName !== 'AREA' &&
						style.getPropertyValue('display') === 'none') ||
					['STYLE', 'SCRIPT', 'NOSCRIPT', 'TEMPLATE'].includes(nodeName) ||
					(!screenReader && isClipped(style)) ||
					(!recursed && // visibility is only accurate on the first element
						(style.getPropertyValue('visibility') === 'hidden' || // position does not matter if it was already calculated
							(!screenReader && dom.isOffscreen(el)))) ||
					(screenReader && el.getAttribute('aria-hidden') === 'true')
				) {
					return false;
				}
				/**
				 * check visibility of `AREA`
				 */

				if (nodeName === 'AREA') {
					return isAreaVisible(el);
				}

				var parent = el.assignedSlot ? el.assignedSlot : el.parentNode;
				var isVisible = false;

				if (parent) {
					isVisible = dom.isVisible(parent, screenReader, true);
				}

				if (node) {
					node[cacheName] = isVisible;
				}

				return isVisible;
			};
			/*global dom */

			var visualRoles = [
				'checkbox',
				'img',
				'radio',
				'range',
				'slider',
				'spinbutton',
				'textbox'
			];
			/**
			 * Check if an element is an inherently visual element
			 * @method isVisualContent
			 * @memberof axe.commons.dom
			 * @instance
			 * @param  {Element} element The element to check
			 * @return {Boolean}
			 */

			dom.isVisualContent = function(element) {
				/*eslint indent: 0*/
				var role = element.getAttribute('role');

				if (role) {
					return visualRoles.indexOf(role) !== -1;
				}

				switch (element.nodeName.toUpperCase()) {
					case 'IMG':
					case 'IFRAME':
					case 'OBJECT':
					case 'VIDEO':
					case 'AUDIO':
					case 'CANVAS':
					case 'SVG':
					case 'MATH':
					case 'BUTTON':
					case 'SELECT':
					case 'TEXTAREA':
					case 'KEYGEN':
					case 'PROGRESS':
					case 'METER':
						return true;

					case 'INPUT':
						return element.type !== 'hidden';

					default:
						return false;
				}
			};
			/* global axe, dom */

			/**
			 * Get elements from point across shadow dom boundaries
			 * @method shadowElementsFromPoint
			 * @memberof axe.commons.dom
			 * @instance
			 * @param {Number} nodeX X coordinates of point
			 * @param {Number} nodeY Y coordinates of point
			 * @param {Object} [root] Shadow root or document root
			 * @return {Array}
			 */

			dom.shadowElementsFromPoint = function(nodeX, nodeY) {
				var root =
					arguments.length > 2 && arguments[2] !== undefined
						? arguments[2]
						: document;
				var i =
					arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

				if (i > 999) {
					throw new Error('Infinite loop detected');
				}

				return (
					Array.from(root.elementsFromPoint(nodeX, nodeY)) // As of Chrome 66, elementFromPoint will return elements from parent trees.
						// We only want to touch each tree once, so we're filtering out nodes on other trees.
						.filter(function(nodes) {
							return dom.getRootNode(nodes) === root;
						})
						.reduce(function(stack, elm) {
							if (axe.utils.isShadowRoot(elm)) {
								var shadowStack = dom.shadowElementsFromPoint(
									nodeX,
									nodeY,
									elm.shadowRoot,
									i + 1
								);
								stack = stack.concat(shadowStack); // filter host nodes which get included regardless of overlap
								// TODO: refactor multiline overlap checking inside shadow dom

								if (
									stack.length &&
									axe.commons.dom.visuallyContains(stack[0], elm)
								) {
									stack.push(elm);
								}
							} else {
								stack.push(elm);
							}

							return stack;
						}, [])
				);
			};
			/* global dom */

			/**
			 * Checks whether a parent element visually contains its child, either directly or via scrolling.
			 * Assumes that |parent| is an ancestor of |node|.
			 * @method visuallyContains
			 * @memberof axe.commons.dom
			 * @instance
			 * @param {Element} node
			 * @param {Element} parent
			 * @return {boolean} True if node is visually contained within parent
			 */

			dom.visuallyContains = function(node, parent) {
				var rectBound = node.getBoundingClientRect();
				var margin = 0.01;
				var rect = {
					top: rectBound.top + margin,
					bottom: rectBound.bottom - margin,
					left: rectBound.left + margin,
					right: rectBound.right - margin
				};
				var parentRect = parent.getBoundingClientRect();
				var parentTop = parentRect.top;
				var parentLeft = parentRect.left;
				var parentScrollArea = {
					top: parentTop - parent.scrollTop,
					bottom: parentTop - parent.scrollTop + parent.scrollHeight,
					left: parentLeft - parent.scrollLeft,
					right: parentLeft - parent.scrollLeft + parent.scrollWidth
				};
				var style = window.getComputedStyle(parent); // if parent element is inline, scrollArea will be too unpredictable

				if (style.getPropertyValue('display') === 'inline') {
					return true;
				} //In theory, we should just be able to look at the scroll area as a superset of the parentRect,
				//but that's not true in Firefox

				if (
					(rect.left < parentScrollArea.left && rect.left < parentRect.left) ||
					(rect.top < parentScrollArea.top && rect.top < parentRect.top) ||
					(rect.right > parentScrollArea.right &&
						rect.right > parentRect.right) ||
					(rect.bottom > parentScrollArea.bottom &&
						rect.bottom > parentRect.bottom)
				) {
					return false;
				}

				if (rect.right > parentRect.right || rect.bottom > parentRect.bottom) {
					return (
						style.overflow === 'scroll' ||
						style.overflow === 'auto' ||
						style.overflow === 'hidden' ||
						parent instanceof HTMLBodyElement ||
						parent instanceof HTMLHtmlElement
					);
				}

				return true;
			};
			/* global dom */

			/**
			 * Checks whether a parent element visually overlaps a rectangle, either directly or via scrolling.
			 * @method visuallyOverlaps
			 * @memberof axe.commons.dom
			 * @instance
			 * @param {DOMRect} rect
			 * @param {Element} parent
			 * @return {boolean} True if rect is visually contained within parent
			 */

			dom.visuallyOverlaps = function(rect, parent) {
				var parentRect = parent.getBoundingClientRect();
				var parentTop = parentRect.top;
				var parentLeft = parentRect.left;
				var parentScrollArea = {
					top: parentTop - parent.scrollTop,
					bottom: parentTop - parent.scrollTop + parent.scrollHeight,
					left: parentLeft - parent.scrollLeft,
					right: parentLeft - parent.scrollLeft + parent.scrollWidth
				}; //In theory, we should just be able to look at the scroll area as a superset of the parentRect,
				//but that's not true in Firefox

				if (
					(rect.left > parentScrollArea.right &&
						rect.left > parentRect.right) ||
					(rect.top > parentScrollArea.bottom &&
						rect.top > parentRect.bottom) ||
					(rect.right < parentScrollArea.left &&
						rect.right < parentRect.left) ||
					(rect.bottom < parentScrollArea.top && rect.bottom < parentRect.top)
				) {
					return false;
				}

				var style = window.getComputedStyle(parent);

				if (rect.left > parentRect.right || rect.top > parentRect.bottom) {
					return (
						style.overflow === 'scroll' ||
						style.overflow === 'auto' ||
						parent instanceof HTMLBodyElement ||
						parent instanceof HTMLHtmlElement
					);
				}

				return true;
			};
			/* global forms */

			/**
			 * Determines if an element is an aria combobox element
			 * @method isAriaCombobox
			 * @memberof axe.commons.forms
			 * @param {Element} node Node to determine if aria combobox
			 * @returns {Bool}
			 */

			forms.isAriaCombobox = function(node) {
				var role = axe.commons.aria.getRole(node, {
					noImplicit: true
				});
				return role === 'combobox';
			};
			/* global forms */

			/**
			 * Determines if an element is an aria listbox element
			 * @method isAriaListbox
			 * @memberof axe.commons.forms
			 * @param {Element} node Node to determine if aria listbox
			 * @returns {Bool}
			 */

			forms.isAriaListbox = function(node) {
				var role = axe.commons.aria.getRole(node, {
					noImplicit: true
				});
				return role === 'listbox';
			};
			/* global forms */

			var rangeRoles = ['progressbar', 'scrollbar', 'slider', 'spinbutton'];
			/**
			 * Determines if an element is an aria range element
			 * @method isAriaRange
			 * @memberof axe.commons.forms
			 * @param {Element} node Node to determine if aria range
			 * @returns {Bool}
			 */

			forms.isAriaRange = function(node) {
				var role = axe.commons.aria.getRole(node, {
					noImplicit: true
				});
				return rangeRoles.includes(role);
			};
			/* global forms */

			/**
			 * Determines if an element is an aria textbox element
			 * @method isAriaTextbox
			 * @memberof axe.commons.forms
			 * @param {Element} node Node to determine if aria textbox
			 * @returns {Bool}
			 */

			forms.isAriaTextbox = function(node) {
				var role = axe.commons.aria.getRole(node, {
					noImplicit: true
				});
				return role === 'textbox';
			};
			/* global forms */

			/**
			 * Determines if an element is a native select element
			 * @method isNativeSelect
			 * @memberof axe.commons.forms
			 * @param {Element} node Node to determine if select
			 * @returns {Bool}
			 */

			forms.isNativeSelect = function(node) {
				var nodeName = node.nodeName.toUpperCase();
				return nodeName === 'SELECT';
			};
			/* global forms */

			var nonTextInputTypes = [
				'button',
				'checkbox',
				'color',
				'file',
				'hidden',
				'image',
				'password',
				'radio',
				'reset',
				'submit'
			];
			/**
			 * Determines if an element is a native textbox element
			 * @method isNativeTextbox
			 * @memberof axe.commons.forms
			 * @param {Element} node Node to determine if textbox
			 * @returns {Bool}
			 */

			forms.isNativeTextbox = function(node) {
				var nodeName = node.nodeName.toUpperCase();
				return (
					nodeName === 'TEXTAREA' ||
					(nodeName === 'INPUT' && !nonTextInputTypes.includes(node.type))
				);
			};
			/* global matches */

			/**
			 * Check if a node matches some attribute(s)
			 *
			 * Note: matches.attributes(node, matcher) can be indirectly used through
			 * matches(node, { attributes: matcher })
			 *
			 * Example:
			 * ```js
			 * matches.attributes(node, {
			 *   'aria-live': 'assertive', // Simple string match
			 *   'aria-expanded': /true|false/i, // either boolean, case insensitive
			 * })
			 * ```
			 *
			 * @param {HTMLElement|VirtualNode} node
			 * @param {Object} Attribute matcher
			 * @returns {Boolean}
			 */

			matches.attributes = function matchesAttributes(node, matcher) {
				node = node.actualNode || node;
				return matches.fromFunction(function(attrName) {
					return node.getAttribute(attrName);
				}, matcher);
			};
			/* global matches */

			/**
			 * Check if a "thing" is truthy according to a "condition"
			 *
			 * Note: matches.condition(node, matcher) can be indirectly used through
			 * matches(node, { condition: matcher })
			 *
			 * Example:
			 * ```js
			 * matches.condition(node, (arg) => arg === null)
			 * ```
			 *
			 * @param {any} argument
			 * @param {Function|Null|undefined} condition
			 * @returns {Boolean}
			 */

			matches.condition = function(arg, condition) {
				return !!condition(arg);
			};
			/* global matches */

			var matchers = ['nodeName', 'attributes', 'properties', 'condition'];
			/**
			 * Check if a node matches some definition
			 *
			 * Note: matches.fromDefinition(node, definition) can be indirectly used through
			 * matches(node, definition)
			 *
			 * Example:
			 * ```js
			 * matches.fromDefinition(node, {
			 *   nodeName: ['div', 'span']
			 *   attributes: {
			 *     'aria-live': 'assertive'
			 *   }
			 * })
			 * ```
			 *
			 * @private
			 * @param {HTMLElement|VirtualNode} node
			 * @param {Object|Array<Object>} definition
			 * @returns {Boolean}
			 */

			matches.fromDefinition = function matchFromDefinition(node, definition) {
				node = node.actualNode || node;

				if (Array.isArray(definition)) {
					return definition.some(function(definitionItem) {
						return matches(node, definitionItem);
					});
				}

				if (typeof definition === 'string') {
					return axe.utils.matchesSelector(node, definition);
				}

				return Object.keys(definition).every(function(matcherName) {
					if (!matchers.includes(matcherName)) {
						throw new Error('Unknown matcher type "'.concat(matcherName, '"'));
					} // Find the specific matches method to.
					// matches.attributes, matches.nodeName, matches.properties, etc.

					var matchMethod = matches[matcherName]; // Find the matcher that goes into the matches method.
					// 'div', /^div$/, (str) => str === 'div', etc.

					var matcher = definition[matcherName];
					return matchMethod(node, matcher);
				});
			};
			/* global matches */

			/**
			 * Check if the value from a function matches some condition
			 *
			 * Each key on the matcher object is passed to getValue, the returned value must match
			 * with the value of that matcher
			 *
			 * Example:
			 * ```js
			 * matches.fromFunction(
			 * 	 (attr => node.getAttribute(attr),
			 * 	 {
			 * 	   'aria-hidden': /^true|false$/i
			 * 	 }
			 * )
			 * ```
			 *
			 * @private
			 * @param {Function} getValue
			 * @param {Object} matcher matcher
			 * @returns {Boolean}
			 */

			matches.fromFunction = function matchFromFunction(getValue, matcher) {
				var matcherType = _typeof(matcher);

				if (
					matcherType !== 'object' ||
					Array.isArray(matcher) ||
					matcher instanceof RegExp
				) {
					throw new Error('Expect matcher to be an object');
				} // Check that the property has all the expected values

				return Object.keys(matcher).every(function(propName) {
					return matches.fromPrimative(getValue(propName), matcher[propName]);
				});
			};
			/* global matches */

			/**
			 * Check if some value matches
			 *
			 * ```js
			 * match.fromPrimative('foo', 'foo') // true, string is the same
			 * match.fromPrimative('foo', ['foo', 'bar']) // true, string is included
			 * match.fromPrimative('foo', /foo/) // true, string matches regex
			 * match.fromPrimative('foo', str => str.toUpperCase() === 'FOO') // true, function return is truthy
			 * ```
			 *
			 * @private
			 * @param {String|Boolean|Array|Number|Null|Undefined} someString
			 * @param {String|RegExp|Function|Array<String>|Null|Undefined} matcher
			 * @returns {Boolean}
			 */

			matches.fromPrimative = function matchFromPrimative(someString, matcher) {
				var matcherType = _typeof(matcher);

				if (Array.isArray(matcher) && typeof someString !== 'undefined') {
					return matcher.includes(someString);
				}

				if (matcherType === 'function') {
					return !!matcher(someString);
				}

				if (matcher instanceof RegExp) {
					return matcher.test(someString);
				}

				return matcher === someString;
			};
			/* global matches */

			var isXHTMLGlobal;
			/**
			 * Check if the nodeName of a node matches some value
			 *
			 * Note: matches.nodeName(node, matcher) can be indirectly used through
			 * matches(node, { nodeName: matcher })
			 *
			 * Example:
			 * ```js
			 * matches.nodeName(node, ['div', 'span'])
			 * ```
			 *
			 * @param {HTMLElement|VirtualNode} node
			 * @param {Object} Attribute matcher
			 * @returns {Boolean}
			 */

			matches.nodeName = function matchNodeName(node, matcher) {
				var _ref42 =
						arguments.length > 2 && arguments[2] !== undefined
							? arguments[2]
							: {},
					isXHTML = _ref42.isXHTML;

				node = node.actualNode || node;

				if (typeof isXHTML === 'undefined') {
					// When the matcher is a string, use native .matches() function:
					if (typeof matcher === 'string') {
						return axe.utils.matchesSelector(node, matcher);
					}

					if (typeof isXHTMLGlobal === 'undefined') {
						isXHTMLGlobal = axe.utils.isXHTML(node.ownerDocument);
					}

					isXHTML = isXHTMLGlobal;
				}

				var nodeName = isXHTML ? node.nodeName : node.nodeName.toLowerCase();
				return matches.fromPrimative(nodeName, matcher);
			};
			/* global matches */

			/**
			 * Check if a node matches some attribute(s)
			 *
			 * Note: matches.properties(node, matcher) can be indirectly used through
			 * matches(node, { properties: matcher })
			 *
			 * Example:
			 * ```js
			 * matches.properties(node, {
			 *   type: 'text', // Simple string match
			 *   value: value => value.trim() !== '', // None-empty value, using a function matcher
			 * })
			 * ```
			 *
			 * @param {HTMLElement|VirtualNode} node
			 * @param {Object} matcher
			 * @returns {Boolean}
			 */

			matches.properties = function matchesProperties(node, matcher) {
				node = node.actualNode || node;
				var out = matches.fromFunction(function(propName) {
					return node[propName];
				}, matcher);
				return out;
			};
			/* global table */

			/**
			 * Returns all cells contained in given HTMLTableElement
			 * @method getAllCells
			 * @memberof axe.commons.table
			 * @instance
			 * @param  {HTMLTableElement} tableElm Table Element to get cells from
			 * @return {Array<HTMLTableCellElement>}
			 */

			table.getAllCells = function(tableElm) {
				var rowIndex, cellIndex, rowLength, cellLength;
				var cells = [];

				for (
					rowIndex = 0, rowLength = tableElm.rows.length;
					rowIndex < rowLength;
					rowIndex++
				) {
					for (
						cellIndex = 0, cellLength = tableElm.rows[rowIndex].cells.length;
						cellIndex < cellLength;
						cellIndex++
					) {
						cells.push(tableElm.rows[rowIndex].cells[cellIndex]);
					}
				}

				return cells;
			};
			/* global table, dom */

			/**
			 * Get the x, y coordinates of a table cell; normalized for rowspan and colspan
			 * @method getCellPosition
			 * @memberof axe.commons.table
			 * @instance
			 * @param  {HTMLTableCellElement} cell The table cell of which to get the position
			 * @return {Object} Object with `x` and `y` properties of the coordinates
			 */

			table.getCellPosition = axe.utils.memoize(function(cell, tableGrid) {
				var rowIndex, index;

				if (!tableGrid) {
					tableGrid = table.toGrid(dom.findUp(cell, 'table'));
				}

				for (rowIndex = 0; rowIndex < tableGrid.length; rowIndex++) {
					if (tableGrid[rowIndex]) {
						index = tableGrid[rowIndex].indexOf(cell);

						if (index !== -1) {
							return {
								x: index,
								y: rowIndex
							};
						}
					}
				}
			});
			/* global table */

			/**
			 * Loop through the table grid looking for headers and caching the result.
			 * @param {String} headerType The type of header to look for ("row" or "col")
			 * @param {Object} position The position of the cell to start looking
			 * @param {Array} tablegrid A matrix of the table obtained using axe.commons.table.toGrid
			 * @return {Array<HTMLTableCellElement>} Array of HTMLTableCellElements that are headers
			 */

			function traverseForHeaders(headerType, position, tableGrid) {
				var property = headerType === 'row' ? '_rowHeaders' : '_colHeaders';
				var predicate =
					headerType === 'row' ? table.isRowHeader : table.isColumnHeader;
				var rowEnd = headerType === 'row' ? position.y : 0;
				var colEnd = headerType === 'row' ? 0 : position.x;
				var headers;
				var cells = [];

				for (var row = position.y; row >= rowEnd && !headers; row--) {
					for (var col = position.x; col >= colEnd; col--) {
						var cell = tableGrid[row] ? tableGrid[row][col] : undefined;

						if (!cell) {
							continue;
						} // stop traversing once we've found a cache

						var vNode = axe.utils.getNodeFromTree(cell);

						if (vNode[property]) {
							headers = vNode[property];
							break;
						}

						cells.push(cell);
					}
				} // need to check that the cells we've traversed are headers

				headers = (headers || []).concat(cells.filter(predicate)); // cache results

				cells.forEach(function(tableCell) {
					var vNode = axe.utils.getNodeFromTree(tableCell);
					vNode[property] = headers;
				});
				return headers;
			}
			/**
			 * Get any associated table headers for a `HTMLTableCellElement`
			 * @method getHeaders
			 * @memberof axe.commons.table
			 * @instance
			 * @param  {HTMLTableCellElement} cell The cell of which to get headers
			 * @param {Array} [tablegrid] A matrix of the table obtained using axe.commons.table.toGrid
			 * @return {Array<HTMLTableCellElement>} Array of headers associated to the table cell
			 */

			table.getHeaders = function(cell, tableGrid) {
				if (cell.hasAttribute('headers')) {
					return commons.dom.idrefs(cell, 'headers');
				}

				if (!tableGrid) {
					tableGrid = commons.table.toGrid(commons.dom.findUp(cell, 'table'));
				}

				var position = commons.table.getCellPosition(cell, tableGrid); // TODO: RTL text

				var rowHeaders = traverseForHeaders('row', position, tableGrid);
				var colHeaders = traverseForHeaders('col', position, tableGrid);
				return [].concat(rowHeaders, colHeaders).reverse();
			};
			/* global table, dom */

			/**
			 * Determine if a `HTMLTableCellElement` is a column header, if so get the scope of the header
			 * @method getScope
			 * @memberof axe.commons.table
			 * @instance
			 * @param {HTMLTableCellElement} cell The table cell to test
			 * @return {Boolean|String} Returns `false` if not a column header, or the scope of the column header element
			 */

			table.getScope = function(cell) {
				var scope = cell.getAttribute('scope');
				var role = cell.getAttribute('role');

				if (
					cell instanceof Element === false ||
					['TD', 'TH'].indexOf(cell.nodeName.toUpperCase()) === -1
				) {
					throw new TypeError('Expected TD or TH element');
				}

				if (role === 'columnheader') {
					return 'col';
				} else if (role === 'rowheader') {
					return 'row';
				} else if (scope === 'col' || scope === 'row') {
					return scope;
				} else if (cell.nodeName.toUpperCase() !== 'TH') {
					return false;
				}

				var tableGrid = table.toGrid(dom.findUp(cell, 'table'));
				var pos = table.getCellPosition(cell, tableGrid); // The element is in a row with all th elements, that makes it a column header

				var headerRow = tableGrid[pos.y].reduce(function(headerRow, cell) {
					return headerRow && cell.nodeName.toUpperCase() === 'TH';
				}, true);

				if (headerRow) {
					return 'col';
				} // The element is in a column with all th elements, that makes it a row header

				var headerCol = tableGrid
					.map(function(col) {
						return col[pos.x];
					})
					.reduce(function(headerCol, cell) {
						return headerCol && cell && cell.nodeName.toUpperCase() === 'TH';
					}, true);

				if (headerCol) {
					return 'row';
				}

				return 'auto';
			};
			/* global table */

			/**
			 * Determine if a `HTMLTableCellElement` is a column header
			 * @method isColumnHeader
			 * @memberof axe.commons.table
			 * @instance
			 * @param  {HTMLTableCellElement} element The table cell to test
			 * @return {Boolean}
			 */

			table.isColumnHeader = function(element) {
				return ['col', 'auto'].indexOf(table.getScope(element)) !== -1;
			};
			/* global table */

			/**
			 * Determine if a `HTMLTableCellElement` is a data cell
			 * @method isDataCell
			 * @memberof axe.commons.table
			 * @instance
			 * @param  {HTMLTableCellElement} node The table cell to test
			 * @return {Boolean}
			 */

			table.isDataCell = function(cell) {
				// @see http://www.whatwg.org/specs/web-apps/current-work/multipage/tables.html#empty-cell
				if (!cell.children.length && !cell.textContent.trim()) {
					return false;
				}

				var role = cell.getAttribute('role');

				if (axe.commons.aria.isValidRole(role)) {
					return ['cell', 'gridcell'].includes(role);
				} else {
					return cell.nodeName.toUpperCase() === 'TD';
				}
			};
			/* global table, dom */

			/**
			 * Determines whether a table is a data table
			 * @method isDataTable
			 * @memberof axe.commons.table
			 * @instance
			 * @param  {HTMLTableElement} node The table to test
			 * @return {Boolean}
			 * @see http://asurkov.blogspot.co.uk/2011/10/data-vs-layout-table.html
			 */

			table.isDataTable = function(node) {
				var role = (node.getAttribute('role') || '').toLowerCase(); // The element is not focusable and has role=presentation

				if (
					(role === 'presentation' || role === 'none') &&
					!dom.isFocusable(node)
				) {
					return false;
				} // Table inside editable area is data table always since the table structure is crucial for table editing

				if (
					node.getAttribute('contenteditable') === 'true' ||
					dom.findUp(node, '[contenteditable="true"]')
				) {
					return true;
				} // Table having ARIA table related role is data table

				if (role === 'grid' || role === 'treegrid' || role === 'table') {
					return true;
				} // Table having ARIA landmark role is data table

				if (commons.aria.getRoleType(role) === 'landmark') {
					return true;
				} // Table having datatable="0" attribute is layout table

				if (node.getAttribute('datatable') === '0') {
					return false;
				} // Table having summary attribute is data table

				if (node.getAttribute('summary')) {
					return true;
				} // Table having legitimate data table structures is data table

				if (node.tHead || node.tFoot || node.caption) {
					return true;
				} // colgroup / col - colgroup is magically generated

				for (
					var childIndex = 0, childLength = node.children.length;
					childIndex < childLength;
					childIndex++
				) {
					if (node.children[childIndex].nodeName.toUpperCase() === 'COLGROUP') {
						return true;
					}
				}

				var cells = 0;
				var rowLength = node.rows.length;
				var row, cell;
				var hasBorder = false;

				for (var rowIndex = 0; rowIndex < rowLength; rowIndex++) {
					row = node.rows[rowIndex];

					for (
						var cellIndex = 0, cellLength = row.cells.length;
						cellIndex < cellLength;
						cellIndex++
					) {
						cell = row.cells[cellIndex];

						if (cell.nodeName.toUpperCase() === 'TH') {
							return true;
						}

						if (
							!hasBorder &&
							(cell.offsetWidth !== cell.clientWidth ||
								cell.offsetHeight !== cell.clientHeight)
						) {
							hasBorder = true;
						}

						if (
							cell.getAttribute('scope') ||
							cell.getAttribute('headers') ||
							cell.getAttribute('abbr')
						) {
							return true;
						}

						if (
							['columnheader', 'rowheader'].includes(
								(cell.getAttribute('role') || '').toLowerCase()
							)
						) {
							return true;
						} // abbr element as a single child element of table cell

						if (
							cell.children.length === 1 &&
							cell.children[0].nodeName.toUpperCase() === 'ABBR'
						) {
							return true;
						}

						cells++;
					}
				} // Table having nested table is layout table

				if (node.getElementsByTagName('table').length) {
					return false;
				} // Table having only one row or column is layout table (row)

				if (rowLength < 2) {
					return false;
				} // Table having only one row or column is layout table (column)

				var sampleRow = node.rows[Math.ceil(rowLength / 2)];

				if (sampleRow.cells.length === 1 && sampleRow.cells[0].colSpan === 1) {
					return false;
				} // Table having many columns (>= 5) is data table

				if (sampleRow.cells.length >= 5) {
					return true;
				} // Table having borders around cells is data table

				if (hasBorder) {
					return true;
				} // Table having differently colored rows is data table

				var bgColor, bgImage;

				for (rowIndex = 0; rowIndex < rowLength; rowIndex++) {
					row = node.rows[rowIndex];

					if (
						bgColor &&
						bgColor !==
							window.getComputedStyle(row).getPropertyValue('background-color')
					) {
						return true;
					} else {
						bgColor = window
							.getComputedStyle(row)
							.getPropertyValue('background-color');
					}

					if (
						bgImage &&
						bgImage !==
							window.getComputedStyle(row).getPropertyValue('background-image')
					) {
						return true;
					} else {
						bgImage = window
							.getComputedStyle(row)
							.getPropertyValue('background-image');
					}
				} // Table having many rows (>= 20) is data table

				if (rowLength >= 20) {
					return true;
				} // Wide table (more than 95% of the document width) is layout table

				if (
					dom.getElementCoordinates(node).width >
					dom.getViewportSize(window).width * 0.95
				) {
					return false;
				} // Table having small amount of cells (<= 10) is layout table

				if (cells < 10) {
					return false;
				} // Table containing embed, object, applet of iframe elements (typical advertisements elements) is layout table

				if (node.querySelector('object, embed, iframe, applet')) {
					return false;
				} // Otherwise it's data table

				return true;
			};
			/* global table, axe */

			/**
			 * Determine if a `HTMLTableCellElement` is a header
			 * @method isHeader
			 * @memberof axe.commons.table
			 * @instance
			 * @param  {HTMLTableCellElement} cell The table cell to test
			 * @return {Boolean}
			 */

			table.isHeader = function(cell) {
				if (table.isColumnHeader(cell) || table.isRowHeader(cell)) {
					return true;
				}

				if (cell.getAttribute('id')) {
					var id = axe.utils.escapeSelector(cell.getAttribute('id'));
					return !!document.querySelector('[headers~="'.concat(id, '"]'));
				}

				return false;
			};
			/* global table */

			/**
			 * Determine if a `HTMLTableCellElement` is a row header
			 * @method isRowHeader
			 * @memberof axe.commons.table
			 * @instance
			 * @param  {HTMLTableCellElement} cell The table cell to test
			 * @return {Boolean}
			 */

			table.isRowHeader = function(cell) {
				return ['row', 'auto'].includes(table.getScope(cell));
			};
			/*global table */

			/**
			 * Converts a table to an Array of arrays, normalized for row and column spans
			 * @method toGrid
			 * @memberof axe.commons.table
			 * @instance
			 * @param  {HTMLTableElement} node The table to convert
			 * @return {Array<HTMLTableCellElement>} Array of HTMLTableCellElements
			 */

			table.toGrid = axe.utils.memoize(function(node) {
				var table = [];
				var rows = node.rows;

				for (var i = 0, rowLength = rows.length; i < rowLength; i++) {
					var cells = rows[i].cells;
					table[i] = table[i] || [];
					var columnIndex = 0;

					for (var j = 0, cellLength = cells.length; j < cellLength; j++) {
						for (var colSpan = 0; colSpan < cells[j].colSpan; colSpan++) {
							for (var rowSpan = 0; rowSpan < cells[j].rowSpan; rowSpan++) {
								table[i + rowSpan] = table[i + rowSpan] || [];

								while (table[i + rowSpan][columnIndex]) {
									columnIndex++;
								}

								table[i + rowSpan][columnIndex] = cells[j];
							}

							columnIndex++;
						}
					}
				}

				return table;
			}); // This was the old name

			table.toArray = table.toGrid;
			/* global table */

			(function(table) {
				var traverseTable = function traverseTable(
					dir,
					position,
					tableGrid,
					callback
				) {
					var result;
					var cell = tableGrid[position.y]
						? tableGrid[position.y][position.x]
						: undefined;

					if (!cell) {
						return [];
					}

					if (typeof callback === 'function') {
						result = callback(cell, position, tableGrid);

						if (result === true) {
							// abort
							return [cell];
						}
					}

					result = traverseTable(
						dir,
						{
							x: position.x + dir.x,
							y: position.y + dir.y
						},
						tableGrid,
						callback
					);
					result.unshift(cell);
					return result;
				};
				/**
				 * Traverses a table in a given direction, passing the cell to the callback
				 * @method traverse
				 * @memberof axe.commons.table
				 * @instance
				 * @param  {Object|String} dir Direction that will be added recursively {x: 1, y: 0}, 'left';
				 * @param  {Object}   startPos    x/y coordinate: {x: 0, y: 0};
				 * @param  {Array}    [tablegrid]  A matrix of the table obtained using axe.commons.table.toArray (OPTIONAL)
				 * @param  {Function} callback Function to which each cell will be passed
				 * @return {NodeElement}       If the callback returns true, the traversal will end and the cell will be returned
				 */

				table.traverse = function(dir, startPos, tableGrid, callback) {
					/* eslint indent: 0 */
					if (Array.isArray(startPos)) {
						callback = tableGrid;
						tableGrid = startPos;
						startPos = {
							x: 0,
							y: 0
						};
					}

					if (typeof dir === 'string') {
						switch (dir) {
							case 'left':
								dir = {
									x: -1,
									y: 0
								};
								break;

							case 'up':
								dir = {
									x: 0,
									y: -1
								};
								break;

							case 'right':
								dir = {
									x: 1,
									y: 0
								};
								break;

							case 'down':
								dir = {
									x: 0,
									y: 1
								};
								break;
						}
					}

					return traverseTable(
						dir,
						{
							x: startPos.x + dir.x,
							y: startPos.y + dir.y
						},
						tableGrid,
						callback
					);
				};
			})(table);
			/* global text, dom, aria, axe */

			/**
			 * Finds virtual node and calls accessibleTextVirtual()
			 * IMPORTANT: This method requires the composed tree at axe._tree
			 *
			 * @param {HTMLElement} element The HTMLElement
			 * @param {Object} context
			 * @property {Bool} inControlContext
			 * @property {Bool} inLabelledByContext
			 * @return {string}
			 */

			text.accessibleText = function accessibleText(element, context) {
				var virtualNode = axe.utils.getNodeFromTree(element); // throws an exception on purpose if axe._tree not correct

				return text.accessibleTextVirtual(virtualNode, context);
			};
			/**
			 * Finds virtual node and calls accessibleTextVirtual()
			 * IMPORTANT: This method requires the composed tree at axe._tree
			 *
			 * @param {HTMLElement} element The HTMLElement
			 * @param {Object} context
			 * @property {Bool} inControlContext
			 * @property {Bool} inLabelledByContext
			 * @return {string}
			 */

			text.accessibleTextVirtual = function accessibleTextVirtual(virtualNode) {
				var context =
					arguments.length > 1 && arguments[1] !== undefined
						? arguments[1]
						: {};
				var actualNode = virtualNode.actualNode;
				context = prepareContext(virtualNode, context); // Step 2A, check visibility

				if (shouldIgnoreHidden(virtualNode, context)) {
					return '';
				}

				var computationSteps = [
					aria.arialabelledbyText, // Step 2B.1
					aria.arialabelText, // Step 2C
					text.nativeTextAlternative, // Step 2D
					text.formControlValue, // Step 2E
					text.subtreeText, // Step 2F + Step 2H
					textNodeContent, // Step 2G (order with 2H does not matter)
					text.titleText // Step 2I
				]; // Find the first step that returns a non-empty string

				var accName = computationSteps.reduce(function(accName, step) {
					if (context.startNode === virtualNode) {
						accName = text.sanitize(accName);
					}

					if (accName !== '') {
						// yes, whitespace only a11y names halt the algorithm
						return accName;
					}

					return step(virtualNode, context);
				}, '');

				if (context.debug) {
					axe.log(accName || '{empty-value}', actualNode, context);
				}

				return accName;
			};
			/**
			 * Return the textContent of a node
			 * @param {VirtualNode} element
			 * @return {String} textContent value
			 */

			function textNodeContent(_ref43) {
				var actualNode = _ref43.actualNode;

				if (actualNode.nodeType !== 3) {
					return '';
				}

				return actualNode.textContent;
			}
			/**
			 * Check if the
			 * @param {VirtualNode} element
			 * @param {Object} context
			 * @property {VirtualNode[]} processed
			 * @return {Boolean}
			 */

			function shouldIgnoreHidden(_ref44, context) {
				var actualNode = _ref44.actualNode;

				if (
					// If the parent isn't ignored, the text node should not be either
					actualNode.nodeType !== 1 || // If the target of aria-labelledby is hidden, ignore all descendents
					context.includeHidden
				) {
					return false;
				}

				return !dom.isVisible(actualNode, true);
			}
			/**
			 * Apply defaults to the context
			 * @param {VirtualNode} element
			 * @param {Object} context
			 * @return {Object} context object with defaults applied
			 */

			function prepareContext(virtualNode, context) {
				var actualNode = virtualNode.actualNode;

				if (!context.startNode) {
					context = _extends(
						{
							startNode: virtualNode
						},
						context
					);
				}
				/**
				 * When `aria-labelledby` directly references a `hidden` element
				 * the element needs to be included in the accessible name.
				 *
				 * When a descendent of the `aria-labelledby` reference is `hidden`
				 * the element should not be included in the accessible name.
				 *
				 * This is done by setting `includeHidden` for the `aria-labelledby` reference.
				 */

				if (
					actualNode.nodeType === 1 &&
					context.inLabelledByContext &&
					context.includeHidden === undefined
				) {
					context = _extends(
						{
							includeHidden: !dom.isVisible(actualNode, true)
						},
						context
					);
				}

				return context;
			}
			/**
			 * Check if the node is processed with this context before
			 * @param {VirtualNode} element
			 * @param {Object} context
			 * @property {VirtualNode[]} processed
			 * @return {Boolean}
			 */

			text.accessibleTextVirtual.alreadyProcessed = function alreadyProcessed(
				virtualnode,
				context
			) {
				context.processed = context.processed || [];

				if (context.processed.includes(virtualnode)) {
					return true;
				}

				context.processed.push(virtualnode);
				return false;
			};
			/* global text, aria, dom */

			var controlValueRoles = [
				'textbox',
				'progressbar',
				'scrollbar',
				'slider',
				'spinbutton',
				'combobox',
				'listbox'
			];
			text.formControlValueMethods = {
				nativeTextboxValue: nativeTextboxValue,
				nativeSelectValue: nativeSelectValue,
				ariaTextboxValue: ariaTextboxValue,
				ariaListboxValue: ariaListboxValue,
				ariaComboboxValue: ariaComboboxValue,
				ariaRangeValue: ariaRangeValue
			};
			/**
			 * Calculate value of a form control
			 *
			 * @param {VirtualNode} element The VirtualNode instance whose value we want
			 * @param {Object} context
			 * @property {Element} startNode First node in accessible name computation
			 * @property {String[]} unsupported List of roles where value computation is unsupported
			 * @property {Bool} debug Enable logging for formControlValue
			 * @return {string} The calculated value
			 */

			text.formControlValue = function formControlValue(virtualNode) {
				var context =
					arguments.length > 1 && arguments[1] !== undefined
						? arguments[1]
						: {};
				var actualNode = virtualNode.actualNode;
				var unsupported = text.unsupported.accessibleNameFromFieldValue || [];
				var role = aria.getRole(actualNode);

				if (
					// For the targeted node, the accessible name is never the value:
					context.startNode === virtualNode || // Only elements with a certain role can return their value
					!controlValueRoles.includes(role) || // Skip unsupported roles
					unsupported.includes(role)
				) {
					return '';
				} // Object.values:

				var valueMethods = Object.keys(text.formControlValueMethods).map(
					function(name) {
						return text.formControlValueMethods[name];
					}
				); // Return the value of the first step that returns with text

				var valueString = valueMethods.reduce(function(accName, step) {
					return accName || step(virtualNode, context);
				}, '');

				if (context.debug) {
					axe.log(valueString || '{empty-value}', actualNode, context);
				}

				return valueString;
			};
			/**
			 * Calculate value of a native textbox element (input and textarea)
			 *
			 * @param {VirtualNode|Element} element The element whose value we want
			 * @return {string} The calculated value
			 */

			function nativeTextboxValue(node) {
				node = node.actualNode || node;

				if (axe.commons.forms.isNativeTextbox(node)) {
					return node.value || '';
				}

				return '';
			}
			/**
			 * Calculate value of a select element
			 *
			 * @param {VirtualNode} element The VirtualNode instance whose value we want
			 * @return {string} The calculated value
			 */

			function nativeSelectValue(node) {
				node = node.actualNode || node;

				if (!axe.commons.forms.isNativeSelect(node)) {
					return '';
				}

				return (
					Array.from(node.options)
						.filter(function(option) {
							return option.selected;
						})
						.map(function(option) {
							return option.text;
						})
						.join(' ') || ''
				);
			}
			/**
			 * Calculate value of a an element with role=textbox
			 *
			 * @param {VirtualNode} element The VirtualNode instance whose value we want
			 * @return {string} The calculated value
			 */

			function ariaTextboxValue(virtualNode) {
				var actualNode = virtualNode.actualNode;

				if (!axe.commons.forms.isAriaTextbox(actualNode)) {
					return '';
				}

				if (!dom.isHiddenWithCSS(actualNode)) {
					return text.visibleVirtual(virtualNode, true);
				} else {
					return actualNode.textContent;
				}
			}
			/**
			 * Calculate value of an element with role=combobox or role=listbox
			 *
			 * @param {VirtualNode} element The VirtualNode instance whose value we want
			 * @param {Object} context The VirtualNode instance whose value we want
			 * @property {Element} startNode First node in accessible name computation
			 * @property {String[]} unsupported List of roles where value computation is unsupported
			 * @property {Bool} debug Enable logging for formControlValue
			 * @return {string} The calculated value
			 */

			function ariaListboxValue(virtualNode, context) {
				var actualNode = virtualNode.actualNode;

				if (!axe.commons.forms.isAriaListbox(actualNode)) {
					return '';
				}

				var selected = aria
					.getOwnedVirtual(virtualNode)
					.filter(function(owned) {
						return (
							aria.getRole(owned) === 'option' &&
							owned.actualNode.getAttribute('aria-selected') === 'true'
						);
					});

				if (selected.length === 0) {
					return '';
				} // Note: Even with aria-multiselectable, only the first value will be used
				// in the accessible name. This isn't spec'ed out, but seems to be how all
				// browser behave.

				return axe.commons.text.accessibleTextVirtual(selected[0], context);
			}
			/**
			 * Calculate value of an element with role=combobox or role=listbox
			 *
			 * @param {VirtualNode} element The VirtualNode instance whose value we want
			 * @param {Object} context The VirtualNode instance whose value we want
			 * @property {Element} startNode First node in accessible name computation
			 * @property {String[]} unsupported List of roles where value computation is unsupported
			 * @property {Bool} debug Enable logging for formControlValue
			 * @return {string} The calculated value
			 */

			function ariaComboboxValue(virtualNode, context) {
				var actualNode = virtualNode.actualNode;
				var listbox; // For combobox, find the first owned listbox:

				if (!axe.commons.forms.isAriaCombobox(actualNode)) {
					return '';
				}

				listbox = aria.getOwnedVirtual(virtualNode).filter(function(elm) {
					return aria.getRole(elm) === 'listbox';
				})[0];
				return listbox
					? text.formControlValueMethods.ariaListboxValue(listbox, context)
					: '';
			}
			/**
			 * Calculate value of an element with range-type role
			 *
			 * @param {VirtualNode|Node} element The VirtualNode instance whose value we want
			 * @return {string} The calculated value
			 */

			function ariaRangeValue(node) {
				node = node.actualNode || node;

				if (
					!axe.commons.forms.isAriaRange(node) ||
					!node.hasAttribute('aria-valuenow')
				) {
					return '';
				} // Validate the number, if not, return 0.
				// Chrome 70 typecasts this, Firefox 62 does not

				var valueNow = +node.getAttribute('aria-valuenow');
				return !isNaN(valueNow) ? String(valueNow) : '0';
			}
			/* global text */

			/**
			 * Determines if a given text is human friendly and interpretable
			 *
			 * @method isHumanInterpretable
			 * @memberof axe.commons.text
			 * @instance
			 * @param  {String} str text to be validated
			 * @returns {Number} Between 0 and 1, (0 -> not interpretable, 1 -> interpretable)
			 */

			text.isHumanInterpretable = function(str) {
				/**
				 * Steps:
				 * 1) Check for single character edge cases
				 * 		a) handle if character is alphanumeric & within the given icon mapping
				 * 					eg: x (close), i (info)
				 *
				 * 3) handle unicode from astral  (non bilingual multi plane) unicode, emoji & punctuations
				 * 					eg: Windings font
				 * 					eg: ''
				 * 					eg: I saw a shooting 
				 * 					eg: ? (help), > (next arrow), < (back arrow), need help ?
				 */
				if (!str.length) {
					return 0;
				} // Step 1

				var alphaNumericIconMap = [
					'x', // close
					'i' // info
				]; // Step 1a

				if (alphaNumericIconMap.includes(str)) {
					return 0;
				} // Step 2

				var noUnicodeStr = text.removeUnicode(str, {
					emoji: true,
					nonBmp: true,
					punctuations: true
				});

				if (!text.sanitize(noUnicodeStr)) {
					return 0;
				}

				return 1;
			};
			/* global text */

			/**
			 * Determines if a given text node is an icon ligature
			 *
			 * @method isIconLigature
			 * @memberof axe.commons.text
			 * @instance
			 * @param {VirtualNode} textVNode The virtual text node
			 * @param {Number} occuranceThreshold Number of times the font is encountered before auto-assigning the font as a ligature or not
			 * @param {Number} differenceThreshold Percent of differences in pixel data or pixel width needed to determine if a font is a ligature font
			 * @return {Boolean}
			 */

			text.isIconLigature = function(textVNode) {
				var differenceThreshold =
					arguments.length > 1 && arguments[1] !== undefined
						? arguments[1]
						: 0.15;
				var occuranceThreshold =
					arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;

				/**
				 * Determine if the visible text is a ligature by comparing the
				 * first letters image data to the entire strings image data.
				 * If the two images are significantly different (typical set to 5%
				 * statistical significance, but we'll be using a slightly higher value
				 * of 15% to help keep the size of the canvas down) then we know the text
				 * has been replaced by a ligature.
				 *
				 * Example:
				 * If a text node was the string "File", looking at just the first
				 * letter "F" would produce the following image:
				 *
				 * 
				 *     
				 * 
				 *     
				 * 
				 *              
				 * 
				 *              
				 * 
				 *         
				 * 
				 *         
				 * 
				 *              
				 * 
				 *              
				 * 
				 *              
				 * 
				 *
				 * But if the entire string "File" produced an image which had at least
				 * a 15% difference in pixels, we would know that the string was replaced
				 * by a ligature:
				 *
				 * 
				 *      
				 * 
				 *             
				 * 
				 *       
				 * 
				 *           
				 * 
				 *        
				 * 
				 *              
				 * 
				 *     
				 * 
				 *              
				 * 
				 *   
				 * 
				 */
				var nodeValue = textVNode.actualNode.nodeValue.trim(); // text with unicode or non-bmp letters cannot be ligature icons

				if (
					!text.sanitize(nodeValue) ||
					text.hasUnicode(nodeValue, {
						emoji: true,
						nonBmp: true
					})
				) {
					return false;
				}

				if (!axe._cache.get('canvasContext')) {
					axe._cache.set(
						'canvasContext',
						document.createElement('canvas').getContext('2d')
					);
				}

				var canvasContext = axe._cache.get('canvasContext');

				var canvas = canvasContext.canvas; // keep track of each font encountered and the number of times it shows up
				// as a ligature.

				if (!axe._cache.get('fonts')) {
					axe._cache.set('fonts', {});
				}

				var fonts = axe._cache.get('fonts');

				var style = window.getComputedStyle(textVNode.parent.actualNode);
				var fontFamily = style.getPropertyValue('font-family');

				if (!fonts[fontFamily]) {
					fonts[fontFamily] = {
						occurances: 0,
						numLigatures: 0
					};
				}

				var font = fonts[fontFamily]; // improve the performance by only comparing the image data of a font
				// a certain number of times

				if (font.occurances >= occuranceThreshold) {
					// if the font has always been a ligature assume it's a ligature font
					if (font.numLigatures / font.occurances === 1) {
						return true;
					} // inversely, if it's never been a ligature assume it's not a ligature font
					else if (font.numLigatures === 0) {
						return false;
					} // we could theoretically get into an odd middle ground scenario in which
					// the font family is being used as normal text sometimes and as icons
					// other times. in these cases we would need to always check the text
					// to know if it's an icon or not
				}

				font.occurances++; // 30px was chosen to account for common ligatures in normal fonts
				// such as fi, ff, ffi. If a ligature would add a single column of
				// pixels to a 30x30 grid, it would not meet the statistical significance
				// threshold of 15% (30x30 = 900; 30/900 = 3.333%). this also allows for
				// more than 1 column differences (60/900 = 6.666%) and things like
				// extending the top of the f in the fi ligature.

				var fontSize = 30;
				var fontStyle = ''.concat(fontSize, 'px ').concat(fontFamily); // set the size of the canvas to the width of the first letter

				canvasContext.font = fontStyle;
				var firstChar = nodeValue.charAt(0);
				var width = canvasContext.measureText(firstChar).width; // ensure font meets the 30px width requirement (30px font-size doesn't
				// necessarily mean its 30px wide when drawn)

				if (width < 30) {
					var diff = 30 / width;
					width *= diff;
					fontSize *= diff;
					fontStyle = ''.concat(fontSize, 'px ').concat(fontFamily);
				}

				canvas.width = width;
				canvas.height = fontSize; // changing the dimensions of a canvas resets all properties (include font)
				// and clears it

				canvasContext.font = fontStyle;
				canvasContext.textAlign = 'left';
				canvasContext.textBaseline = 'top';
				canvasContext.fillText(firstChar, 0, 0);
				var compareData = new Uint32Array(
					canvasContext.getImageData(0, 0, width, fontSize).data.buffer
				); // if the font doesn't even have character data for a single char then
				// it has to be an icon ligature (e.g. Material Icon)

				if (
					!compareData.some(function(pixel) {
						return pixel;
					})
				) {
					font.numLigatures++;
					return true;
				}

				canvasContext.clearRect(0, 0, width, fontSize);
				canvasContext.fillText(nodeValue, 0, 0);
				var compareWith = new Uint32Array(
					canvasContext.getImageData(0, 0, width, fontSize).data.buffer
				); // calculate the number of differences between the first letter and the
				// entire string, ignoring color differences

				var differences = compareData.reduce(function(diff, pixel, i) {
					if (pixel === 0 && compareWith[i] === 0) {
						return diff;
					}

					if (pixel !== 0 && compareWith[i] !== 0) {
						return diff;
					}

					return ++diff;
				}, 0); // calculate the difference between the width of each character and the
				// combined with of all characters

				var expectedWidth = nodeValue.split('').reduce(function(width, _char) {
					return width + canvasContext.measureText(_char).width;
				}, 0);
				var actualWidth = canvasContext.measureText(nodeValue).width;
				var pixelDifference = differences / compareData.length;
				var sizeDifference = 1 - actualWidth / expectedWidth;

				if (
					pixelDifference >= differenceThreshold &&
					sizeDifference >= differenceThreshold
				) {
					font.numLigatures++;
					return true;
				}

				return false;
			};
			/* global text */

			var autocomplete = {
				stateTerms: ['on', 'off'],
				standaloneTerms: [
					'name',
					'honorific-prefix',
					'given-name',
					'additional-name',
					'family-name',
					'honorific-suffix',
					'nickname',
					'username',
					'new-password',
					'current-password',
					'organization-title',
					'organization',
					'street-address',
					'address-line1',
					'address-line2',
					'address-line3',
					'address-level4',
					'address-level3',
					'address-level2',
					'address-level1',
					'country',
					'country-name',
					'postal-code',
					'cc-name',
					'cc-given-name',
					'cc-additional-name',
					'cc-family-name',
					'cc-number',
					'cc-exp',
					'cc-exp-month',
					'cc-exp-year',
					'cc-csc',
					'cc-type',
					'transaction-currency',
					'transaction-amount',
					'language',
					'bday',
					'bday-day',
					'bday-month',
					'bday-year',
					'sex',
					'url',
					'photo'
				],
				qualifiers: ['home', 'work', 'mobile', 'fax', 'pager'],
				qualifiedTerms: [
					'tel',
					'tel-country-code',
					'tel-national',
					'tel-area-code',
					'tel-local',
					'tel-local-prefix',
					'tel-local-suffix',
					'tel-extension',
					'email',
					'impp'
				],
				locations: ['billing', 'shipping']
			};
			text.autocomplete = autocomplete;

			text.isValidAutocomplete = function isValidAutocomplete(autocomplete) {
				var _ref45 =
						arguments.length > 1 && arguments[1] !== undefined
							? arguments[1]
							: {},
					_ref45$looseTyped = _ref45.looseTyped,
					looseTyped = _ref45$looseTyped === void 0 ? false : _ref45$looseTyped,
					_ref45$stateTerms = _ref45.stateTerms,
					stateTerms = _ref45$stateTerms === void 0 ? [] : _ref45$stateTerms,
					_ref45$locations = _ref45.locations,
					locations = _ref45$locations === void 0 ? [] : _ref45$locations,
					_ref45$qualifiers = _ref45.qualifiers,
					qualifiers = _ref45$qualifiers === void 0 ? [] : _ref45$qualifiers,
					_ref45$standaloneTerm = _ref45.standaloneTerms,
					standaloneTerms =
						_ref45$standaloneTerm === void 0 ? [] : _ref45$standaloneTerm,
					_ref45$qualifiedTerms = _ref45.qualifiedTerms,
					qualifiedTerms =
						_ref45$qualifiedTerms === void 0 ? [] : _ref45$qualifiedTerms;

				autocomplete = autocomplete.toLowerCase().trim();
				stateTerms = stateTerms.concat(text.autocomplete.stateTerms);

				if (stateTerms.includes(autocomplete) || autocomplete === '') {
					return true;
				}

				qualifiers = qualifiers.concat(text.autocomplete.qualifiers);
				locations = locations.concat(text.autocomplete.locations);
				standaloneTerms = standaloneTerms.concat(
					text.autocomplete.standaloneTerms
				);
				qualifiedTerms = qualifiedTerms.concat(
					text.autocomplete.qualifiedTerms
				);
				var autocompleteTerms = autocomplete.split(/\s+/g);

				if (!looseTyped) {
					if (
						autocompleteTerms[0].length > 8 &&
						autocompleteTerms[0].substr(0, 8) === 'section-'
					) {
						autocompleteTerms.shift();
					}

					if (locations.includes(autocompleteTerms[0])) {
						autocompleteTerms.shift();
					}

					if (qualifiers.includes(autocompleteTerms[0])) {
						autocompleteTerms.shift(); // only quantifiers allowed at this point

						standaloneTerms = [];
					}

					if (autocompleteTerms.length !== 1) {
						return false;
					}
				}

				var purposeTerm = autocompleteTerms[autocompleteTerms.length - 1];
				return (
					standaloneTerms.includes(purposeTerm) ||
					qualifiedTerms.includes(purposeTerm)
				);
			};
			/* global dom, text */

			/**
			 * Return accessible text for an implicit and/or explicit HTML label element
			 * @param {VirtualNode} element
			 * @param {Object} context
			 * @property {Bool} inControlContext
			 * @property {Bool} inLabelledByContext
			 * @return {String} Label text
			 */

			text.labelText = function labelText(virtualNode) {
				var context =
					arguments.length > 1 && arguments[1] !== undefined
						? arguments[1]
						: {};
				var alreadyProcessed = text.accessibleTextVirtual.alreadyProcessed;

				if (
					context.inControlContext ||
					context.inLabelledByContext ||
					alreadyProcessed(virtualNode, context)
				) {
					return '';
				}

				if (!context.startNode) {
					context.startNode = virtualNode;
				}

				var labelContext = _extends(
					{
						inControlContext: true
					},
					context
				);

				var explicitLabels = getExplicitLabels(virtualNode);
				var implicitLabel = dom.findUpVirtual(virtualNode, 'label');
				var labels;

				if (implicitLabel) {
					labels = [].concat(_toConsumableArray(explicitLabels), [
						implicitLabel
					]);
					labels.sort(axe.utils.nodeSorter);
				} else {
					labels = explicitLabels;
				}

				return labels
					.map(function(label) {
						return text.accessibleText(label, labelContext);
					})
					.filter(function(text) {
						return text !== '';
					})
					.join(' ');
			};
			/**
			 * Find a non-ARIA label for an element
			 * @private
			 * @param {VirtualNode} element The VirtualNode instance whose label we are seeking
			 * @return {HTMLElement} The label element, or null if none is found
			 */

			function getExplicitLabels(_ref46) {
				var actualNode = _ref46.actualNode;

				if (!actualNode.id) {
					return [];
				}

				return dom.findElmsInContext({
					elm: 'label',
					attr: 'for',
					value: actualNode.id,
					context: actualNode
				});
			}
			/* global text, dom, axe, aria */

			/**
			 * Gets the visible text of a label for a given input
			 * @see http://www.w3.org/WAI/PF/aria/roles#namecalculation
			 * @method labelVirtual
			 * @memberof axe.commons.text
			 * @instance
			 * @param  {VirtualNode} node The virtual node mapping to the input to test
			 * @return {Mixed} String of visible text, or `null` if no label is found
			 */

			text.labelVirtual = function(node) {
				var ref, candidate, doc;
				candidate = aria.labelVirtual(node);

				if (candidate) {
					return candidate;
				} // explicit label

				if (node.actualNode.id) {
					var id = axe.utils.escapeSelector(node.actualNode.getAttribute('id'));
					doc = axe.commons.dom.getRootNode(node.actualNode);
					ref = doc.querySelector('label[for="' + id + '"]');
					candidate = ref && text.visible(ref, true);

					if (candidate) {
						return candidate;
					}
				}

				ref = dom.findUpVirtual(node, 'label');
				candidate = ref && text.visible(ref, true);

				if (candidate) {
					return candidate;
				}

				return null;
			};
			/**
			 * Finds virtual node and calls labelVirtual()
			 * IMPORTANT: This method requires the composed tree at axe._tree
			 * @see axe.commons.text.virtualLabel
			 * @method label
			 * @memberof axe.commons.text
			 * @instance
			 * @param  {Element} node The virtual node mapping to the input to test
			 * @return {Mixed} String of visible text, or `null` if no label is found
			 */

			text.label = function(node) {
				node = axe.utils.getNodeFromTree(node);
				return text.labelVirtual(node);
			};
			/* global text */

			text.nativeElementType = [
				{
					// 5.1 input type="text", input type="password", input type="search", input type="tel", input type="url" and textarea Element
					matches: [
						{
							nodeName: 'textarea'
						},
						{
							nodeName: 'input',
							properties: {
								type: ['text', 'password', 'search', 'tel', 'email', 'url']
							}
						}
					],
					namingMethods: 'labelText'
				},
				{
					// 5.2 input type="button", input type="submit" and input type="reset"
					matches: {
						nodeName: 'input',
						properties: {
							type: ['button', 'submit', 'reset']
						}
					},
					namingMethods: ['valueText', 'titleText', 'buttonDefaultText']
				},
				{
					// 5.3 input type="image"
					matches: {
						nodeName: 'input',
						properties: {
							type: 'image'
						}
					},
					namingMethods: [
						'altText',
						'valueText',
						'labelText',
						'titleText',
						'buttonDefaultText'
					]
				},
				{
					// 5.4 button Element
					matches: 'button',
					namingMethods: 'subtreeText'
				},
				{
					// 5.5 fieldset and legend Elements
					matches: 'fieldset',
					namingMethods: 'fieldsetLegendText'
				},
				{
					// 5.6 output Element
					matches: 'OUTPUT',
					namingMethods: 'subtreeText'
				},
				{
					// 5.7 Other Form Elements
					matches: [
						{
							nodeName: 'select'
						},
						{
							nodeName: 'input',
							properties: {
								// Regex: Everything other than these
								type: /^(?!text|password|search|tel|email|url|button|submit|reset)/
							}
						}
					],
					namingMethods: 'labelText'
				},
				{
					// 5.8 summary Element
					matches: 'summary',
					namingMethods: 'subtreeText'
				},
				{
					// 5.9 figure and figcaption Elements
					matches: 'figure',
					namingMethods: ['figureText', 'titleText']
				},
				{
					// 5.10 img Element
					matches: 'img',
					namingMethods: 'altText'
				},
				{
					// 5.11 table Element
					matches: 'table',
					namingMethods: ['tableCaptionText', 'tableSummaryText']
				},
				{
					matches: ['hr', 'br'],
					namingMethods: ['titleText', 'singleSpace']
				} // All else defaults to just title
			];
			/* global text, aria */

			/**
			 * Get the accessible text using native HTML methods only
			 * @param {VirtualNode} element
			 * @param {Object} context
			 * @property {Bool} debug Enable logging for formControlValue
			 * @return {String} Accessible text
			 */

			text.nativeTextAlternative = function nativeTextAlternative(virtualNode) {
				var context =
					arguments.length > 1 && arguments[1] !== undefined
						? arguments[1]
						: {};
				var actualNode = virtualNode.actualNode;

				if (
					actualNode.nodeType !== 1 ||
					['presentation', 'none'].includes(aria.getRole(actualNode))
				) {
					return '';
				}

				var textMethods = findTextMethods(virtualNode); // Find the first step that returns a non-empty string

				var accName = textMethods.reduce(function(accName, step) {
					return accName || step(virtualNode, context);
				}, '');

				if (context.debug) {
					axe.log(accName || '{empty-value}', actualNode, context);
				}

				return accName;
			};
			/**
			 * Get accessible text functions for a specific native HTML element
			 * @private
			 * @param {VirtualNode} element
			 * @return {Function[]} Array of native accessible name computation methods
			 */

			function findTextMethods(virtualNode) {
				var nativeElementType = text.nativeElementType,
					nativeTextMethods = text.nativeTextMethods;
				var nativeType = nativeElementType.find(function(_ref47) {
					var matches = _ref47.matches;
					return axe.commons.matches(virtualNode, matches);
				}); // Use concat because namingMethods can be a string or an array of strings

				var methods = nativeType ? [].concat(nativeType.namingMethods) : [];
				return methods.map(function(methodName) {
					return nativeTextMethods[methodName];
				});
			}
			/* global text */

			var defaultButtonValues = {
				submit: 'Submit',
				image: 'Submit',
				reset: 'Reset',
				button: '' // No default for "button"
			};
			text.nativeTextMethods = {
				/**
				 * Return the value of a DOM node
				 * @param {VirtualNode} element
				 * @return {String} value text
				 */
				valueText: function valueText(_ref48) {
					var actualNode = _ref48.actualNode;
					return actualNode.value || '';
				},

				/**
				 * Return default value of a button
				 * @param {VirtualNode} element
				 * @return {String} default button text
				 */
				buttonDefaultText: function buttonDefaultText(_ref49) {
					var actualNode = _ref49.actualNode;
					return defaultButtonValues[actualNode.type] || '';
				},

				/**
				 * Return caption text of an HTML table element
				 * @param {VirtualNode} element
				 * @param {Object} context
				 * @return {String} caption text
				 */
				tableCaptionText: descendantText.bind(null, 'caption'),

				/**
				 * Return figcaption text of an HTML figure element
				 * @param {VirtualNode} element
				 * @param {Object} context
				 * @return {String} figcaption text
				 */
				figureText: descendantText.bind(null, 'figcaption'),

				/**
				 * Return legend text of an HTML fieldset element
				 * @param {VirtualNode} element
				 * @param {Object} context
				 * @return {String} legend text
				 */
				fieldsetLegendText: descendantText.bind(null, 'legend'),

				/**
				 * Return the alt text
				 * @param {VirtualNode} element
				 * @return {String} alt text
				 */
				altText: attrText.bind(null, 'alt'),

				/**
				 * Return summary text for an HTML table element
				 * @param {VirtualNode} element
				 * @return {String} summary text
				 */
				tableSummaryText: attrText.bind(null, 'summary'),

				/**
				 * Return the title text
				 * @param {VirtualNode} element
				 * @return {String} title text
				 */
				titleText: function titleText(virtualNode, context) {
					return text.titleText(virtualNode, context);
				},

				/**
				 * Return accessible text of the subtree
				 * @param {VirtualNode} element
				 * @param {Object} context
				 * @return {String} Subtree text
				 */
				subtreeText: function subtreeText(virtualNode, context) {
					return text.subtreeText(virtualNode, context);
				},

				/**
				 * Return accessible text for an implicit and/or explicit HTML label element
				 * @param {VirtualNode} element
				 * @param {Object} context
				 * @return {String} Label text
				 */
				labelText: function labelText(virtualNode, context) {
					return text.labelText(virtualNode, context);
				},

				/**
				 * Return a single space
				 * @return {String} Returns ` `
				 */
				singleSpace: function singleSpace() {
					return ' ';
				}
			};

			function attrText(attr, _ref50) {
				var actualNode = _ref50.actualNode;
				return actualNode.getAttribute(attr) || '';
			}
			/**
			 * Get the accessible text of first matching node
			 * IMPORTANT: This method does not look at the composed tree
			 * @private
			 */

			function descendantText(nodeName, _ref51, context) {
				var actualNode = _ref51.actualNode;
				nodeName = nodeName.toLowerCase(); // Prevent accidently getting the nested element, like:
				// fieldset > fielset > legend (1st fieldset has no legend)

				var nodeNames = [nodeName, actualNode.nodeName.toLowerCase()].join(',');
				var candidate = actualNode.querySelector(nodeNames);

				if (!candidate || candidate.nodeName.toLowerCase() !== nodeName) {
					return '';
				}

				return text.accessibleText(candidate, context);
			}
			/* global text */

			/**
			 * Removes carriage returns, newline characters, tabs, non-breaking spaces, and trailing spaces from string
			 * @method sanitize
			 * @memberof axe.commons.text
			 * @instance
			 * @param  {String} str String to be cleaned
			 * @return {String} Sanitized string
			 */

			text.sanitize = function(str) {
				'use strict';

				return str
					.replace(/\r\n/g, '\n')
					.replace(/\u00A0/g, ' ')
					.replace(/[\s]{2,}/g, ' ')
					.trim();
			};
			/* global text, aria */

			/**
			 * Get the accessible text for an element that can get its name from content
			 *
			 * @param {VirtualNode} element
			 * @param {Object} context
			 * @property {Bool} strict Should the name computation strictly follow AccName 1.1
			 * @return {String} Accessible text
			 */

			text.subtreeText = function subtreeText(virtualNode) {
				var context =
					arguments.length > 1 && arguments[1] !== undefined
						? arguments[1]
						: {};
				var alreadyProcessed = text.accessibleTextVirtual.alreadyProcessed;
				context.startNode = context.startNode || virtualNode;
				var strict = context.strict;

				if (
					alreadyProcessed(virtualNode, context) ||
					!aria.namedFromContents(virtualNode, {
						strict: strict
					})
				) {
					return '';
				}

				return aria
					.getOwnedVirtual(virtualNode)
					.reduce(function(contentText, child) {
						return appendAccessibleText(contentText, child, context);
					}, '');
			}; // TODO: Could do with an "HTML" lookup table, similar to ARIA,
			//  where this sort of stuff can live.

			var phrasingElements = [
				'A',
				'EM',
				'STRONG',
				'SMALL',
				'MARK',
				'ABBR',
				'DFN',
				'I',
				'B',
				'S',
				'U',
				'CODE',
				'VAR',
				'SAMP',
				'KBD',
				'SUP',
				'SUB',
				'Q',
				'CITE',
				'SPAN',
				'BDO',
				'BDI',
				'WBR',
				'INS',
				'DEL',
				'MAP',
				'AREA',
				'NOSCRIPT',
				'RUBY',
				'BUTTON',
				'LABEL',
				'OUTPUT',
				'DATALIST',
				'KEYGEN',
				'PROGRESS',
				'COMMAND',
				'CANVAS',
				'TIME',
				'METER',
				'#TEXT'
			];

			function appendAccessibleText(contentText, virtualNode, context) {
				var nodeName = virtualNode.actualNode.nodeName.toUpperCase();
				var contentTextAdd = text.accessibleTextVirtual(virtualNode, context);

				if (!contentTextAdd) {
					return contentText;
				}

				if (!phrasingElements.includes(nodeName)) {
					// Append space, if necessary
					if (contentTextAdd[0] !== ' ') {
						contentTextAdd += ' ';
					} // Prepend space, if necessary

					if (contentText && contentText[contentText.length - 1] !== ' ') {
						contentTextAdd = ' ' + contentTextAdd;
					}
				}

				return contentText + contentTextAdd;
			}
			/* global text, aria */

			var alwaysTitleElements = [
				'button',
				'iframe',
				'a[href]',
				{
					nodeName: 'input',
					properties: {
						type: 'button'
					}
				}
			];
			/**
			 * Get title text
			 * @param {HTMLElement}node the node to verify
			 * @return {String}
			 */

			text.titleText = function titleText(node) {
				node = node.actualNode || node;

				if (node.nodeType !== 1 || !node.hasAttribute('title')) {
					return '';
				} // Some elements return the title even with role=presentation
				// This does appear in any spec, but its remarkably consistent

				if (
					!axe.commons.matches(node, alwaysTitleElements) &&
					['none', 'presentation'].includes(aria.getRole(node))
				) {
					return '';
				}

				return node.getAttribute('title');
			};
			/* global text */

			/**
			 * Determine if a given string contains unicode characters, specified in options
			 *
			 * @method hasUnicode
			 * @memberof axe.commons.text
			 * @instance
			 * @param {String} str string to verify
			 * @param {Object} options config containing which unicode character sets to verify
			 * @property {Boolean} options.emoji verify emoji unicode
			 * @property {Boolean} options.nonBmp verify nonBmp unicode
			 * @property {Boolean} options.punctuations verify punctuations unicode
			 * @returns {Boolean}
			 */

			text.hasUnicode = function hasUnicode(str, options) {
				var emoji = options.emoji,
					nonBmp = options.nonBmp,
					punctuations = options.punctuations;

				if (emoji) {
					return axe.imports.emojiRegexText().test(str);
				}

				if (nonBmp) {
					return getUnicodeNonBmpRegExp().test(str);
				}

				if (punctuations) {
					return getPunctuationRegExp().test(str);
				}

				return false;
			};
			/**
			 * Remove specified type(s) unicode characters
			 *
			 * @method removeUnicode
			 * @memberof axe.commons.text
			 * @instance
			 * @param {String} str string to operate on
			 * @param {Object} options config containing which unicode character sets to remove
			 * @property {Boolean} options.emoji remove emoji unicode
			 * @property {Boolean} options.nonBmp remove nonBmp unicode
			 * @property {Boolean} options.punctuations remove punctuations unicode
			 * @returns {String}
			 */

			text.removeUnicode = function removeUnicode(str, options) {
				var emoji = options.emoji,
					nonBmp = options.nonBmp,
					punctuations = options.punctuations;

				if (emoji) {
					str = str.replace(axe.imports.emojiRegexText(), '');
				}

				if (nonBmp) {
					str = str.replace(getUnicodeNonBmpRegExp(), '');
					str = str.replace(getSupplementaryPrivateUseRegExp(), '');
				}

				if (punctuations) {
					str = str.replace(getPunctuationRegExp(), '');
				}

				return str;
			};
			/**
			 * Regex for matching unicode values out of Basic Multilingual Plane (BMP)
			 * Reference:
			 * - https://github.com/mathiasbynens/regenerate
			 * - https://unicode-table.com/
			 * - https://mathiasbynens.be/notes/javascript-unicode
			 *
			 * @returns {RegExp}
			 */

			function getUnicodeNonBmpRegExp() {
				/**
				 * Regex for matching astral plane unicode
				 * - http://kourge.net/projects/regexp-unicode-block
				 */
				return new RegExp(
					'[' +
					'\u1D00-\u1D7F' + // Phonetic Extensions
					'\u1D80-\u1DBF' + // Phonetic Extensions Supplement
					'\u1DC0-\u1DFF' + // Combining Diacritical Marks Supplement
					// '\u2000-\u206F' + // General punctuation - handled in -> getPunctuationRegExp
					'\u20A0-\u20CF' + // Currency symbols
					'\u20D0-\u20FF' + // Combining Diacritical Marks for Symbols
					'\u2100-\u214F' + // Letter like symbols
					'\u2150-\u218F' + // Number forms (eg: Roman numbers)
					'\u2190-\u21FF' + // Arrows
					'\u2200-\u22FF' + // Mathematical operators
					'\u2300-\u23FF' + // Misc Technical
					'\u2400-\u243F' + // Control pictures
					'\u2440-\u245F' + // OCR
					'\u2460-\u24FF' + // Enclosed alpha numerics
					'\u2500-\u257F' + // Box Drawing
					'\u2580-\u259F' + // Block Elements
					'\u25A0-\u25FF' + // Geometric Shapes
					'\u2600-\u26FF' + // Misc Symbols
					'\u2700-\u27BF' + // Dingbats
					'\uE000-\uF8FF' + // Private Use
						']'
				);
			}
			/**
			 * Get regular expression for matching punctuations
			 *
			 * @returns {RegExp}
			 */

			function getPunctuationRegExp() {
				/**
				 * Reference: http://kunststube.net/encoding/
				 * US-ASCII
				 * -> !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
				 *
				 * General Punctuation block
				 * -> \u2000-\u206F
				 *
				 * Supplemental Punctuation block
				 * Reference: https://en.wikipedia.org/wiki/Supplemental_Punctuation
				 * -> \u2E00-\u2E7F Reference
				 */
				return /[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,\-.\/:;<=>?@\[\]^_`{|}~]/g;
			}
			/**
			 * Get regular expression for supplementary private use
			 *
			 * @returns {RegExp}
			 */

			function getSupplementaryPrivateUseRegExp() {
				/**
				 * Reference: https://www.unicode.org/charts/PDF/UD800.pdf
				 * https://www.unicode.org/charts/PDF/UDC00.pdf
				 */
				return /[\uDB80-\uDBBF][\uDC00-\uDFFD]/g;
			}
			/* global text */

			text.unsupported = {
				accessibleNameFromFieldValue: ['combobox', 'listbox', 'progressbar']
			};
			/* global text */

			/**
     * Returns an array of visible text virtual nodes
    
     * @method visibleTextNodes
     * @memberof axe.commons.text
     * @instance
     * @param {VirtualNode} vNode
     * @return {VitrualNode[]}
     */

			text.visibleTextNodes = function(vNode) {
				var parentVisible = axe.commons.dom.isVisible(vNode.actualNode);
				var nodes = [];
				vNode.children.forEach(function(child) {
					if (child.actualNode.nodeType === 3) {
						if (parentVisible) {
							nodes.push(child);
						}
					} else {
						nodes = nodes.concat(text.visibleTextNodes(child));
					}
				});
				return nodes;
			};
			/* global text, dom, axe */

			/**
			 * Returns the visible text of the virtual node
			 * NOTE: when calculating the text or accessible text of a node that includes shadow
			 * roots attached to it or its children, the flattened tree must be considered
			 * rather than the "light DOM"
			 * @method visibleVirtual
			 * @memberof axe.commons.text
			 * @instance
			 * @param  {VirtualNode} element
			 * @param  {Boolean} screenReader When provided, will evaluate visibility from the perspective of a screen reader
			 * @param  {Boolean} noRecursing When False, the result will contain text from the element and it's children.
			 * When True, the result will only contain text from the element
			 * @return {String}
			 */

			text.visibleVirtual = function(element, screenReader, noRecursing) {
				var result = element.children
					.map(function(child) {
						if (child.actualNode.nodeType === 3) {
							// filter on text nodes
							var nodeValue = child.actualNode.nodeValue;

							if (
								nodeValue &&
								dom.isVisible(element.actualNode, screenReader)
							) {
								return nodeValue;
							}
						} else if (!noRecursing) {
							return text.visibleVirtual(child, screenReader);
						}
					})
					.join('');
				return text.sanitize(result);
			};
			/**
			 * Finds virtual node and calls visibleVirtual()
			 * IMPORTANT: This method requires the composed tree at axe._tree
			 * @param  {Element} element
			 * @param  {Boolean} screenReader When provided, will evaluate visibility from the perspective of a screen reader
			 * @param  {Boolean} noRecursing When False, the result will contain text from the element and it's children.
			 * When True, the result will only contain text from the element
			 * @return {String}
			 */

			text.visible = function(element, screenReader, noRecursing) {
				element = axe.utils.getNodeFromTree(element);
				return text.visibleVirtual(element, screenReader, noRecursing);
			};

			return commons;
		})()
	});
})(typeof window === 'object' ? window : this);
